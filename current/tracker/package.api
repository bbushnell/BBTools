#version 1
#package tracker
#generated 2025-09-06T20:39:27

<class AdapterTracker>
*Tracks counts of base types per position to make a consensus sequence.
*Designed for use with BBMerge since adapters are inferred by insert size;
*could be used with alignment too.
public class AdapterTracker

#Fields
final LongList[][] counts=new LongList[2][4]

public String seq1=null

public String seq2=null

public long reads=0

public long shortInserts=0

public long phixLike=0

private static final byte[] phixPrefix="AGATCGGAAGAGCG".getBytes()

public static boolean ignorePhixAdapters=false

public static boolean trimPolyAorG=true

public static boolean trimJunk=true


#Methods
public AdapterTracker()

public void storeAdapterSequence(Read r, int insert)

private boolean looksLikePhix(Read r, int insert)

private boolean looksLikePhix(byte[] bases, int insert)

public boolean makeSequence()

public boolean hasSequence()

public long writeAdapterConsensus(String fname)

private static String toAdapterSequence(LongList[] lists, boolean trimPolyAorG)

private static String trimPoly(String adapter, char trim)

private static String trimPoly2(String adapter, char poly)

private static String trimJunk(String s, int minScore)

public void merge(AdapterTracker b)

</class AdapterTracker>
<class CrisprTracker>
*Tracks crispr stats.
*@author Brian Bushnell
*@date Sept 5, 2023
public class CrisprTracker

#Fields
private final int[] acgtn=new int[5]

public long crisprsFound=0

public long readsWithCrisprs=0

public long trimmedByConsensus=0

public long partialTipRepeats=0

public long alignedToRef=0

public long modifiedByRef=0

public long failedAlignment=0

public long alignments=0

public long alignmentRequested=0

*Repeat length
public LongList rlenList=new LongList()

*Spacer length
public LongList slenList=new LongList()

*Length of a spacer+repeat
public LongList ulenList=new LongList()

*Total length
public LongList tlenList=new LongList()

*Number of matches
public LongList matchList=new LongList()

*Number of mismatches between repeats
public LongList mismatchList=new LongList()

*Copy count of this repeat
public LongList copyList=new LongList()

*Repeat gc, in 2% increments
public LongList rgcList=new LongList(51)

*Spacer gc, in 2% increments
public LongList sgcList=new LongList(51)

*Number of mismatches with reference
public LongList refMismatchList=new LongList(51)

*Number of mismatches with reference for valid alignments
public LongList refMismatchListValid=new LongList(51)

public final LongList[] lists={rlenList,slenList,ulenList,tlenList,rgcList,sgcList,matchList,mismatchList,copyList,refMismatchList,refMismatchListValid}

public static int histmax=150

public static int gcMult=100


#Methods
public void add(Crispr p, byte[] s)

public CrisprTracker add(CrisprTracker p)

public ByteBuilder appendTo(ByteBuilder bb)

@Override public String toString()

</class CrisprTracker>
<class EntropyTracker>
*Tracks entropy over a sliding window.
*@author Brian Bushnell
*@date Oct 6, 2017
public class EntropyTracker

#Fields
*Current leading kmer; rightmost k bases of window
int kmer=0

*Current trailing kmer; leftmost k-1 bases of window plus the removed base
int kmer2=0

*Position in ring buffer to place incoming bases
int pos=0

*Position in ring buffer to read next base for kmer2
int pos2=0

*Current number of processed bases. Equal to pos without being reset at buffer wrap.
int len=0

*Number of unique kmers in the current window
int unique=0

*Number of undefined bases in the current window
int ns

*Current sum of entropy from kmers in the current window
double currentEsum=0

*Number of times each base occurs in current window.
*Equivalent to counts if k=1.
private final short[] baseCounts

*Number of times each kmer occurs in current window.
*Indexed by the kmer's numeric value.
*counts[0] stores the count of the kmer AAA, if k=3.
private final short[] counts

*Number of instances of each number in counts.
*countCounts[0] stores the number of kmers with count 0.
*This is only needed in medium speed mode (or verify mode).
private final short[] countCounts

*Ring buffer of bases in current window.
*Not strictly necessary, but convenient.
private final byte[] baseRingBuffer

*Kmer length for entropy calculation
private final int k

*Window length for entropy calculation
private final int windowBases

*Number of kmers in the window
private final int windowKmers

*Amino acid mode
private final boolean amino

*Bits per symbol
private final int bitsPerBase

*Mask for sliding kmers
private final int mask

*Minimum entropy to be considered "complex", on a scale of 0-1; optional
private final float entropyCutoff

*Pass entropy values above the cutoff
private final boolean highPass

*Number of possible unique kmers
private final int kmerSpace

*A precalculated constant
private final double entropyMult

*Array of precalculated constants
private final double[] entropy

*Precalculated constant equal to 1f/windowBases
private final float baseCountMult

*Translation table yielding 0 if undefined
private final byte[] symbolToNumber0

*Translation table yielding -1 if undefined
private final byte[] symbolToNumber

*Entropy calculation speed constants.
*FAST is less precise for long sequences.
*MEDIUM is probably most precise.
public static final int FAST=0

*Entropy calculation speed constants.
*FAST is less precise for long sequences.
*MEDIUM is probably most precise.
public static final int MEDIUM=1

*Entropy calculation speed constants.
*FAST is less precise for long sequences.
*MEDIUM is probably most precise.
public static final int SLOW=2

*Entropy calculation speed constants.
*FAST is less precise for long sequences.
*MEDIUM is probably most precise.
public static final int SUPERSLOW=3

*Kmer length for entropy calculation
public static int defaultK=5

public static boolean setDefaultK=false

*Window length for entropy calculation
public static int defaultWindowBases=50

public static boolean setDefaultWindow=false

*Entropy calculation mode
public static int speed=FAST

*Verify consistency of related data structures (slow)
public static boolean verify=false

*Verbose output
public static final boolean verbose=false


#Methods
public static void main(String[] args)

*Normal constructor.
*@param k_ Kmer length.
*@param window_ Window size in bases.
public EntropyTracker(int k_, int window_, boolean amino_)

*Allows the use of passes() based on entropy.
*@param k_ Kmer length.
*@param window_ Window size in bases.
*@param cutoff_ Entropy cutoff, 0 (no entropy) to 1 (max entropy).
*@param highPass_ True passes entropy of at least cutoff; false fails.
public EntropyTracker(boolean amino_, float cutoff_, boolean highPass_)

*Allows the use of passes() based on entropy.
*@param k_ Kmer length.
*@param window_ Window size in bases.
*@param cutoff_ Entropy cutoff, 0 (no entropy) to 1 (max entropy).
*@param highPass_ True passes entropy of at least cutoff; false fails.
public EntropyTracker(int k_, int window_, boolean amino_, float cutoff_, boolean highPass_)

*@param maxCount Highest possible count; equal to window size in kmers.
*@return Entropy array
private static final double[] makeEntropyArray(int maxCount)

*@param entropy Entropy array
*@param entropyMult Multiplier applied to each array element
*@return entropyDeltaPlus array
@SuppressWarnings private static final double[] makeEntropyDeltaPlus(double[] entropy, double entropyMult)

*@param entropy Entropy array
*@param entropyMult Multiplier applied to each array element
*@return entropyDeltaMinus array
@SuppressWarnings private static final double[] makeEntropyDeltaMinus(double[] entropy, double entropyMult)

*@return Number of unique kmers in current window.
public int unique()

*@return Number of undefined bases in current window.
public int ns()

*@return Sequence position of rightmost base in window.
public int rightPos()

*@return Sequence position of leftmost base in window.
public int leftPos()

*@return Window size in bases.
public int windowBases()

public int k()

*@return Entropy cutoff.
public float cutoff()

public float calcMaxMonomerFraction()

*Calculate entropy in current window.
*@return Entropy in current window.
public float calcEntropy()

*Sub-method of calcEntropy()
private float calcEntropyFast()

*Sub-method of calcEntropy()
*Calculates entropy from countCounts using precalculated entropy array and early exit.
private float calcEntropyMedium()

*Sub-method of calcEntropy()
*Calculates entropy from counts using precalculated entropy array.
private float calcEntropySlow()

*Sub-method of calcEntropy()
*Demonstrates explicit entropy calculation.
*Definition:
*Entropy, or information content, can be calculated using kmer counts of a sequence.
*Probability of an event (unique kmer), pk, is that kmer's count divided by the number of kmers.
*Entropy contribution from that kmer is -pk*log(pk).
*Total entropy is sum of (-pk*log(pk)) for all kmer counts.
*entropyMult is simply a multiplier to convert the entropy measure (in bits) to a convenient 0-1 scale,
*corresponding to the inverse of the maximum possible entropy.
private float calcEntropySuperSlow()

public static float strandedness(byte[] bases, int[] counts, int k)

public static float strandedness(int[] counts, int k)

public static float strandedness(long[] counts, int k)

public static float strandednessK2(int[] counts)

public static float strandednessWindowed(byte[] bases, int[] counts, int k, int window)

public static float strandednessWindowedK2(byte[] bases, int[] counts, int window)

public static float calcEntropy(byte[] bases, int[] counts, int k)

*Static, non-windowed version.
*Demonstrates explicit entropy calculation.
*Definition:
*Entropy, or information content, can be calculated using kmer counts of a sequence.
*Probability of an event (unique kmer), pk, is that kmer's count divided by the number of kmers.
*Entropy contribution from that kmer is -pk*log(pk).
*Total entropy is sum of (-pk*log(pk)) for all kmer counts.
*entropyMult is simply a multiplier to convert the entropy measure (in bits) to a convenient 0-1 scale,
*corresponding to the inverse of the maximum possible entropy.
public static float calcEntropyFromCounts(int[] counts)

public static int countKmers(byte[] bases, int[] counts, int k)

*Calculate the average entropy of a sequence.
*@param bases Sequence as bytes
*@param allowNs True if windows containing undefined bases should be included
*@return Average entropy
public float averageEntropy(byte[] bases, boolean allowNs)

*Calculate the average entropy of a sequence.
*@param bases Sequence as bytes
*@param allowNs True if windows containing undefined bases should be included
*@return Average entropy
public float averageEntropy(byte[] bases, boolean allowNs, int from, int to)

*Reports the longest block of consecutive bases in which all windows
*are below the entropy cutoff and at least the (optional) monomer fraction.
*@param bases
*@param allowNs
*@param maxMonomer
*@return
public int longestLowEntropyBlock(byte[] bases, boolean allowNs, float maxMonomerFraction)

*Calculate entropy in the window and compare to the cutoff.
*If Ns are important they should be handled externally with ns().
*@return True if the entropy passes the cutoff.
public boolean passes()

*Calculate average entropy of the sequence and compare to the cutoff.
*@param sequence Sequence to measure.
*@param allowNs True if entropy should be calculated in windows containing Ns.
*@return True if the average entropy passes the cutoff.
public boolean passes(byte[] sequence, boolean allowNs)

*Slide the window by adding a new base.
*@param b Base to add.
public void add(byte b)

*Reset fields to prepare for a new sequence.
public void clear()

*Verify that mutable fields were properly cleared.
*Throws an assertion error upon failure.
*@return True.
public boolean verifyClear()

*Verify that internal state is consistent.
*Throws an assertion error upon failure.
*@return True.
public boolean verify()

@Override public String toString()

*Returns the ring buffer as a String in its correct order.
public String basesToString()

final boolean isFullyDefined(byte symbol)

</class EntropyTracker>
<class PalindromeTracker>
*Tracks palindrome stats to determine which kind occur in a given feature.
*@author Brian Bushnell
*@date Sept 3, 2023
public class PalindromeTracker

#Fields
public long found=0

public LongList plenList=new LongList()

public LongList loopList=new LongList()

public LongList tailList=new LongList()

public LongList tailDifList=new LongList()

public LongList matchList=new LongList()

public LongList mismatchList=new LongList()

public LongList rlenList=new LongList()

public final LongList[] lists={plenList,loopList,tailList,tailDifList,matchList,mismatchList,rlenList}

public static int histmax=50


#Methods
public void add(Palindrome p, int a0, int b0)

public PalindromeTracker add(PalindromeTracker p)

public ByteBuilder appendTo(ByteBuilder bb)

@Override public String toString()

*Can be used to make generic histograms
public static ByteBuilder append(ByteBuilder bb, String header, LongList[] lists, int histmax)

</class PalindromeTracker>
<class PolymerTracker>
*Tracks the number of homopolymers observed of given lengths.
*Only the longest homopolymer for a given base is counted per sequence.
*@author Brian Bushnell
*@date August 27, 2018
public class PolymerTracker

#Fields
private final int[] maxACGTN=KillSwitch.allocInt1D(5)

final LongList[] countsACGTN=new LongList[5]

private LongList[] cumulativeACGTN

public static boolean PER_SEQUENCE=true

public static boolean CUMULATIVE=true


#Methods
public PolymerTracker()

public void reset()

public void addPair(Read r)

public void add(Read r)

public void add(PolymerTracker pt)

public void add(byte[] bases)

public LongList[] accumulate()

public String toHistogram()

public String toHistogramCumulative()

public double calcRatio(byte base1, byte base2, int length)

public long getCount(byte base, int length)

public double calcRatioCumulative(byte base1, byte base2, int length)

public long getCountCumulative(byte base, int length)

*Increment once per sequence,
*for the longest homopolymer of each base
private void addPerSequence(byte[] bases)

*Increment once per homopolymer
private void addPerPolymer(byte[] bases)

private void recordMax(byte base, int len)

private void recordCounts(byte base, int len)

private int longest()

</class PolymerTracker>
<class QualityTracker>
public class QualityTracker
</class QualityTracker>
<class ReadStats>
*@author Brian Bushnell
*@date Mar 18, 2013
public class ReadStats

#Fields
private long read2Count=0

public long pairedCount=0

public long unpairedCount=0

private final int QMIN=Read.MIN_CALLED_QUALITY()

private final int QMAX=Read.MAX_CALLED_QUALITY()

private final int QMAX2=QMAX + 1

public final long[][] aqualArray

public final long[][] qualLength

public final long[][] qualSum

public final long[][][] bqualHist

public final long[] bqualHistOverall

public final long[][] qcountHist

public final double[][] qualSumDouble

public final long[][] matchSum

public final long[][] delSum

public final long[][] insSum

public final long[][] subSum

public final long[][] nSum

public final long[][] clipSum

public final long[][] otherSum

public final long[] qualMatch

public final long[] qualSub

public final long[] qualIns

public final long[] qualDel

public final long[] gcHist

public final long[] entropyHist

public final EntropyTracker eTracker

public final long[] idHist

public final long[] idBaseHist

private int gcMaxReadLen=1

private int idMaxReadLen=1

public final LongList[][] baseHist

public final HashMap<String,Barcode> barcodeMap

*Insert size
public final LongList insertHist

*Read length
public final SuperLongList lengthHist

*Number errors per read
public final LongList errorHist

*Insertion length
public final LongList insHist

*Deletion length
public final LongList delHist

*Deletion length, binned
public final LongList delHist2

*Time
public final LongList timeHist

public static boolean REQUIRE_PROPER_PAIR=true

public static int MAXLEN=6000

public static int MAXINSERTLEN=80000

public static int MAXLENGTHLEN=80000

public static final int MAXTIMELEN=80000

public static final int MAXINSLEN=1000

public static final int MAXDELLEN=1000

public static final int MAXDELLEN2=1000000

public static final int DEL_BIN=100

public static int ID_BINS=100

public static boolean ID_BINS_AUTO=false

public static int GC_BINS=100

public static boolean GC_BINS_AUTO=false

public static boolean GC_PLOT_X=false

public static int ENTROPY_BINS=1000

public static double GCMean

public static double GCMedian

public static double GCMode

public static double GCSTDev

public boolean errorState=false

public static ReadStats merged=null

public static ArrayList<ReadStats> objectList=new ArrayList<ReadStats>()

public static boolean COLLECT_QUALITY_STATS=false

public static boolean COLLECT_QUALITY_ACCURACY=false

public static boolean COLLECT_MATCH_STATS=false

public static boolean COLLECT_INSERT_STATS=false

public static boolean COLLECT_BASE_STATS=false

public static boolean COLLECT_INDEL_STATS=false

public static boolean COLLECT_GC_STATS=false

public static boolean COLLECT_ENTROPY_STATS=false

public static boolean COLLECT_ERROR_STATS=false

public static boolean COLLECT_LENGTH_STATS=false

public static boolean COLLECT_IDENTITY_STATS=false

public static boolean COLLECT_TIME_STATS=false

public static boolean COLLECT_BARCODE_STATS=false

public static boolean usePairGC=true

public static boolean allowEntropyNs=true

public static String AVG_QUAL_HIST_FILE=null

public static String QUAL_HIST_FILE=null

public static String BQUAL_HIST_FILE=null

public static String QUAL_COUNT_HIST_FILE=null

public static String BQUAL_HIST_OVERALL_FILE=null

public static String QUAL_ACCURACY_FILE=null

public static String MATCH_HIST_FILE=null

public static String INSERT_HIST_FILE=null

public static String BASE_HIST_FILE=null

public static String INDEL_HIST_FILE=null

public static String ERROR_HIST_FILE=null

public static String LENGTH_HIST_FILE=null

public static String GC_HIST_FILE=null

public static String ENTROPY_HIST_FILE=null

public static String IDENTITY_HIST_FILE=null

public static String TIME_HIST_FILE=null

public static String BARCODE_STATS_FILE=null

public static boolean overwrite=true

public static boolean append=false

public static final boolean verbose=false

public static boolean skipZeroInsertCount=true

public static boolean skipZeroIndel=true


#Methods
public ReadStats()

public ReadStats(boolean addToList)

public static ReadStats mergeAll()

public void addToHistograms(Read r)

public void addToQualityHistogram(Read r)

private void addToQualityHistogram2(Read r)

public void addToQualityHistogram(byte[] qual, int pairnum)

private void addToBQualityHistogram(byte[] qual, int pairnum)

private void addToQCountHistogram(byte[] qual, int pairnum)

public void addToQualityAccuracy(Read r)

public void addToQualityAccuracy(Read r, int pairnum)

public void addToErrorHistogram(Read r)

private void addToErrorHistogram(Read r, int pairnum)

public void addToLengthHistogram(Read r)

private void addToLengthHistogram(Read r, int pairnum)

public void addToGCHistogram(Read r1)

private void addToGCHistogram(float gc, int len)

public void addToEntropyHistogram(Read r1)

private void addToEntropyHistogram(float entropy, int len)

public void addToIdentityHistogram(Read r)

private void addToIdentityHistogram(Read r, int pairnum)

public void addToTimeHistogram(Read r)

private void addToTimeHistogram(Read r, int pairnum)

public boolean addToIndelHistogram(Read r)

*Handles short match, long match, and reads with attached SamLines
private boolean addToIndelHistogram(Read r, int pairnum)

private boolean addToIndelHistogram(SamLine sl)

public void addToMatchHistogram(Read r)

private void addToMatchHistogram2(Read r)

public void addToInsertHistogram(Read r, boolean ignoreMappingStrand)

public void addToInsertHistogram(SamLine r1)

public void addToInsertHistogram(SamLine r1, SamLine r2)

*This is untested and only gives approximate answers when overlapping reads contain indels.
*It may give incorrect answers for same-strange pairs that are shorter than read length.
*It might give negative answers but that would be a bug.
public static int insertSizeMapped(SamLine r1, SamLine r2, boolean requireProperPair)

public void addToBaseHistogram(Read r)

public void addToBaseHistogram2(Read r)

public void addToBarcodeStats(Read r)

public static boolean testFiles(boolean allowDuplicates)

public static boolean writeAll()

public void writeAverageQualityToFile(String fname, boolean writePaired)

public void writeQCountToFile(String fname, boolean writePaired)

public int q30(int pairnum)

public int lengthAboveAverageQscore(float limit, int pairnum)

public void writeQualityToFile(String fname, boolean writePaired)

private double calcQualityAtPosition(int pos, int pairnum)

public void writeBQualityOverallToFile(String fname)

public void writeBQualityToFile(String fname, boolean writePaired)

public void writeQualityAccuracyToFile(String fname)

private float calcEntropySuperSlow(long[] counts)

public void writeMatchToFile(String fname, boolean writePaired)

public void writeMatchToFileUnpaired(String fname)

public void writeInsertToFile(String fname)

public void writeBaseContentToFile(String fname, boolean paired)

private static int writeBaseContentToFile2(ByteStreamWriter bsw, LongList[] lists, int offset)

public void writeIndelToFile(String fname)

public void writeErrorToFile(String fname)

public void writeLengthToFile(String fname)

public void writeTimeToFile(String fname)

public void writeBarcodesToFile(String fname)

public void writeHistogramToFile(String fname, String header, LongList hist, boolean printZeros)

public void writeHistogramToFile(String fname, String header, SuperLongList hist, boolean printZeros)

public void writeGCToFile(String fname, boolean printZeros)

public void writeEntropyToFile(String fname, boolean printZeros)

public void writeIdentityToFile(String fname, boolean printZeros)

public static void clear()

public static boolean collectingStats()

</class ReadStats>
<class SealStats>
public class SealStats

#Fields
public String fname

public long totalReads

public long totalBases

public long matchedReads

public long matchedBases

public LinkedHashMap<String,SealStatsLine> map=new LinkedHashMap<String,SealStatsLine>()


#Methods
public SealStats(String fname_)

void load(String fname)

public SealStatsLine countNonmatching(String name)

public SealStatsLine countNonprimary(String name)

public SealStatsLine primary()

public String fnamePrefix()

</class SealStats>
<class SealStats.SealStatsLine>
public static class SealStats.SealStatsLine

#Fields
public String name

public long reads

public long bases


#Methods
public SealStatsLine(String name_, long reads_, long bases_)

public void add(SealStatsLine ssl)

@Override public int compareTo(SealStatsLine o)

@Override public boolean equals(Object o)

public boolean equals(SealStatsLine o)

</class SealStats.SealStatsLine>
