#version 1
#package align2
#generated 2025-09-06T20:34:41

<class AbstractIndex>
*@author Brian Bushnell
*@date Oct 15, 2013
public abstract class AbstractIndex

#Fields
long callsToScore=0

long callsToExtendScore=0

long initialKeys=0

long initialKeyIterations=0

long initialKeys2=0

long initialKeyIterations2=0

long usedKeys=0

long usedKeyIterations=0

static final int HIT_HIST_LEN=40

final long[] hist_hits=new long[HIT_HIST_LEN + 1]

final long[] hist_hits_score=new long[HIT_HIST_LEN + 1]

final long[] hist_hits_extend=new long[HIT_HIST_LEN + 1]

final int minChrom

final int maxChrom

static int MINCHROM=1

static int MAXCHROM=Integer.MAX_VALUE

static final boolean SUBSUME_SAME_START_SITES=true

static final boolean SUBSUME_SAME_STOP_SITES=true

*True: Slightly slower.
*False: Faster, but may mask detection of some ambiguously mapping reads.
static final boolean LIMIT_SUBSUMPTION_LENGTH_TO_2X=true

*Not recommended if slow alignment is disabled. Can conceal sites that should be marked as amiguous.
static final boolean SUBSUME_OVERLAPPING_SITES=false

static final boolean SHRINK_BEFORE_WALK=true

*More accurate but uses chromosome arrays while mapping
static final boolean USE_EXTENDED_SCORE=true

*Even more accurate but even slower than normal extended score calculation.
*Scores are compatible with slow-aligned scores.
static final boolean USE_AFFINE_SCORE=true && USE_EXTENDED_SCORE

public static final boolean RETAIN_BEST_SCORES=true

public static final boolean RETAIN_BEST_QCUTOFF=true

public static boolean QUIT_AFTER_TWO_PERFECTS=true

static final boolean DYNAMICALLY_TRIM_LOW_SCORES=true

static final boolean REMOVE_CLUMPY=true

*If no hits are found, search again with slower parameters (less of genome excluded)
static final boolean DOUBLE_SEARCH_NO_HIT=false

*Only this fraction of the originally removed genome fraction (FRACTION_GENOME_TO_EXCLUDE)
*is removed for the second pass
static final float DOUBLE_SEARCH_THRESH_MULT=0.25f

static boolean PERFECTMODE=false

static boolean SEMIPERFECTMODE=false

static boolean REMOVE_FREQUENT_GENOME_FRACTION=true

static boolean TRIM_BY_GREEDY=true

*Ignore longest site list(s) when doing a slow walk.
static final boolean TRIM_LONG_HIT_LISTS=false

public static int MIN_APPROX_HITS_TO_KEEP=1

public static final boolean TRIM_BY_TOTAL_SITE_COUNT=false

*Length histogram index of maximum average hit list length to use.
*The max number of sites to search is calculated by (#keys)*(lengthHistogram[chrom][MAX_AVERAGE_SITES_TO_SEARCH]).
*Then, while the actual number of sites exceeds this, the longest hit list should be removed.
static int MAX_USABLE_LENGTH=Integer.MAX_VALUE

static int MAX_USABLE_LENGTH2=Integer.MAX_VALUE

static Block[] index

static int[] lengthHistogram=null

static int[] COUNTS=null

final int KEYLEN

final int KEYSPACE

*Site must have at least this many contiguous matches
final int KFILTER

final MSA msa

final int BASE_KEY_HIT_SCORE

boolean verbose=false

static boolean verbose2=false

static boolean SLOW=false

static boolean VSLOW=false

static int NUM_CHROM_BITS=3

static int CHROMS_PER_BLOCK=(1 << (NUM_CHROM_BITS))

static final int MINGAP=Shared.MINGAP

static final int MINGAP2=(MINGAP + 128)

static boolean USE_CAMELWALK=false

static final boolean ADD_LIST_SIZE_BONUS=false

static final byte[] LIST_SIZE_BONUS=new byte[100]

public static boolean GENERATE_KEY_SCORES_FROM_QUALITY=true

public static boolean GENERATE_BASE_SCORES_FROM_QUALITY=true


#Methods
AbstractIndex(int keylen, int kfilter, int pointsMatch, int minChrom_, int maxChrom_, MSA msa_)

final int count(int key)

static final boolean overlap(int a1, int b1, int a2, int b2)

*Is (a1, b1) within (a2, b2) ?
static final boolean isWithin(int a1, int b1, int a2, int b2)

*Generates a term that increases score with how far apart the two farthest perfect matches are.
*Assumes that the centerIndex corresponds to the leftmost perfect match.
static final int scoreY(int[] locs, int centerIndex, int offsets)

float[] keyProbArray()

byte[] getBaseScoreArray(int len, int strand)

int[] getKeyScoreArray(int len, int strand)

int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public ArrayList<SiteScore> findAdvanced(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsets, long id)

public static void clear()

static final int calcListSizeBonus(int[] array)

static final int calcListSizeBonus(int size)

</class AbstractIndex>
<class AbstractMapper>
*Abstract superclass created from BBMap variants.
*Handles argument parsing, I/O stream initialization and shutdown,
*thread management, statistics collection and formatting.
*@author Brian Bushnell
*@date Oct 15, 2013
public abstract class AbstractMapper

#Fields
ConcurrentReadInputStream cris

ConcurrentReadOutputStream rosA=null

ConcurrentReadOutputStream rosM=null

ConcurrentReadOutputStream rosU=null

ConcurrentReadOutputStream rosB=null

float fractionGenomeToExclude=-1

int maxIndel1=-1

int maxIndel2=-1

int minApproxHits=-1

int expectedSites=-1

int ambigMode=AMBIG_BEST

boolean fast=false

boolean slow=false

boolean vslow=false

float excludeFraction=-1

boolean verbose=false

boolean rcompMate=false

boolean outputSitesOnly=false

long targetGenomeSize=-1

int ziplevel=-1

int build=1

String reference=null

int keylen=13

boolean printSettings=true

boolean printStats=true

int idmodulo=1

float samplerate=1f

double minid=-1

long sampleseed=1

boolean ambiguousRandom=false

boolean ambiguousAll=false

boolean forceanalyze=false

boolean setxs=false

boolean setintron=false

String bamscript=null

String in1=null

String in2=null

String qfin1=null

String qfin2=null

String qfout=null

String qfout2=null

String qfoutM=null

String qfoutM2=null

String qfoutU=null

String qfoutU2=null

String qfoutB=null

String qfoutB2=null

*Scores below the (max possible alignment score)*(MINIMUM_ALIGNMENT_SCORE_RATIO) will be discarded.
*Default: 0.4 ~ 0.5 for clean data against raw PacBio data.
*Very sensitive! A value of 0.2 will potentially produce many false positives.
float MINIMUM_ALIGNMENT_SCORE_RATIO

float keyDensity

float maxKeyDensity

float minKeyDensity

int maxDesiredKeys

*Additional ref bases on each end of site mapping location in alignment window.
*If there are no insertions or deletions, 0 is fine.
int SLOW_ALIGN_PADDING

int SLOW_RESCUE_PADDING

int TIP_SEARCH_DIST

*Class name of MSA to use
String MSA_TYPE

int MAX_SITESCORES_TO_PRINT

boolean PRINT_SECONDARY_ALIGNMENTS

boolean makeBloomFilter=false

int bloomFilterHashes=2

int bloomFilterMinHits=3

int bloomFilterK=31

BloomFilter bloomFilter

boolean bloomSerial=true

CoveragePileup pileup

String coverageStats=null

String coverageBinned=null

String coverageBase=null

String rangeCov=null

String coverageHist=null

String coverageRPKM=null

String normcov=null

String normcovOverall=null

*Force coverage calculation even if there is no output file
boolean calcCov=false

int coverageMinScaf=0

boolean coveragePhysical=false

boolean cov32bit=false

boolean covBitset=false

boolean covSetbs=false

boolean covArrays=true

boolean covNzo=false

boolean scafNzo=true

boolean sortStats=true

boolean covTwocolumn=false

boolean covKsb=true

boolean covStranded=false

boolean covStartOnly=false

boolean covStopOnly=false

int covBinSize=1000

int covK=0

public static long lastBothUnmapped=0

public static long lastBothUnmappedBases=0

public static long lastEitherMapped=0

public static long lastEitherMappedBases=0

public static long lastReadsUsed=0

public static long lastBasesUsed=0

public static long lastReadsIn=0

public static long lastBasesIn=0

public static long lastReadsPassedBloomFilter=0

public static long lastBasesPassedBloomFilter=0

static final int AMBIG_BEST=0

static final int AMBIG_TOSS=1

static final int AMBIG_RANDOM=2

static final int AMBIG_ALL=3

static int MIN_MAPQ=0

static int MIN_MAPQ_UNPAIRED=0

static int CORRECT_THRESH=0

static int synthReadlen=150

static int maxInsLen=30

static int maxSubLen=30

static int maxDelLen=40

static byte minQuality=3

static byte midQuality=23

static byte maxQuality=35

static int maxSnps=4

static int maxInss=3

static int maxDels=3

static int maxSubs=3

static float baseSnpRate=0.50f

static float baseInsRate=0.30f

static float baseDelRate=0.30f

static float baseSubRate=0.30f

static float PERFECT_READ_RATIO=0.0f

static boolean SAVE_AMBIGUOUS_XY=false

static boolean TRIM_LIST=true

static boolean PAIRED_RANDOM_READS=false

static boolean REQUIRE_CORRECT_STRANDS_PAIRS=true

static boolean SAME_STRAND_PAIRS=false

static boolean KILL_BAD_PAIRS=false

static boolean INDEX_LOADED=false

static final boolean SLOW_ALIGN=true

static boolean MAKE_MATCH_STRING=SLOW_ALIGN

*Rescue paired reads by searching near mate
static boolean RESCUE=true

*Generally should be set to false unless SLOW_ALIGN==true
static boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS=false

*Forbid alignments with indels longer than MAX_INDEL
static boolean STRICT_MAX_INDEL=false

*Don't allow reads to map to their origin location in the reference. Useful for self-correcting reads.
static boolean FORBID_SELF_MAPPING=false

*Only allow perfect and semiperfect mappings
static boolean SEMIPERFECTMODE=false

*Only allow perfect mappings
static boolean PERFECTMODE=false

*Only allow sites with at least this many contiguous matches
static int KFILTER=-1

*Only allow sites with identity of at least this
static float MIN_IDFILTER=0f

*Rename reads to indicate their mapped insert size
static boolean RenameByInsert=false

*Quality-trim left side of read before mapping
static boolean qtrimLeft=false

*Quality-trim right side of read before mapping
static boolean qtrimRight=false

*Restore read to untrimmed state after mapping (and destroy match string)
static boolean untrim=false

*Trim bases with quality less than or equal to this value
static float TRIM_QUALITY=6

*Don't trim reads to be shorter than this
static int minTrimLength=60

*Produce local alignments instead of global alignments
static boolean LOCAL_ALIGN=false

public static int minChrom=1

public static int maxChrom=Integer.MAX_VALUE

static long maxReads=-1

static boolean CALC_STATISTICS=true

static boolean QUICK_MATCH_STRINGS=false

static boolean OUTPUT_READS=false

static boolean OUTPUT_MAPPED_ONLY=false

static boolean DONT_OUTPUT_BLACKLISTED_READS=false

static boolean ORDERED=false

static boolean DOUBLE_PRINT_ERROR_RATE=false

static boolean PRINT_UNMAPPED_COUNT=false

static String outFile=null

static String outFile2=null

static String outFileM=null

static String outFileM2=null

static String outFileU=null

static String outFileU2=null

static String outFileB=null

static String outFileB2=null

static ArrayList<String> blacklist=null

static ArrayList<String> splitterOutputs=null

static boolean useRandomReads=false

static int sequentialOverlap=5

static boolean sequentialStrandAlt=false

static boolean overwrite=true

static boolean append=false

static boolean SYNTHETIC=false

static boolean ERROR_ON_NO_OUTPUT=false

static boolean MACHINE_OUTPUT=false

static boolean USE_MODULO=false

static String statsOutputFile="stderr.txt"

static final String DELIMITER="="

static PrintStream outstream=System.err

static boolean SYSIN=false

static int verbose_stats=0

static boolean waitForMemoryClear=false

static int DEFAULT_OUTPUT_FORMAT=FileFormat.SAM

public static boolean errorState=false


#Methods
public AbstractMapper(String[] args)

final void abort(AbstractMapThread[] mtts, String message)

*In megabytes
final void adjustThreadsforMemory(long threadMem)

void setDefaults()

String[] preparse(String[] args)

void postparse(String[] args)

void setup()

void loadIndex()

void processAmbig2()

void testSpeed(String[] args)

void setSemiperfectMode()

void setPerfectMode()

void printSettings(int k)

private final void parse(String[] args)

private final void checkFiles()

private final String[] preparse0(String[] args)

static final String padPercent(double value, int places)

static final String pad(long value, int places)

static final String padPercentMachine(double value, int places)

boolean openStreams(Timer t, String[] args)

static final int shutDownThreads(AbstractMapThread[] mtts, boolean force)

static final boolean closeStreams(ConcurrentReadInputStream cris, ConcurrentReadOutputStream rosA, ConcurrentReadOutputStream rosM, ConcurrentReadOutputStream rosU, ConcurrentReadOutputStream rosB)

static final ConcurrentReadInputStream getReadInputStream(String in1, String in2, String qf1, String qf2)

void printOutput(AbstractMapThread[] mtts, Timer t, int keylen, boolean paired, boolean SKIMMER, CoveragePileup pile, boolean nzoStats, boolean sortStats, String dest)

static void printOutputStats(AbstractMapThread[] mtts, Timer t, int keylen, boolean paired, boolean SKIMMER, boolean nzoStats, boolean sortStats, String dest)

static void printOutput_Machine(AbstractMapThread[] mtts, Timer t, int keylen, boolean paired, boolean SKIMMER, boolean nzoStats, boolean sortStats, String dest)

static final void printSettings0(int k, int maxindel, float minratio)

static final int absdif(int a, int b)

static void clearStatics()

</class AbstractMapper>
<class AbstractMapThread>
*@author Brian Bushnell
*@date Feb 27, 2013
public abstract class AbstractMapThread

#Fields
private boolean finished=false

private static final float[] CZ3_MULTS=new float[]{0f,1f,.75f,0.5f,0.25f,0.125f,0.0625f}

*Input read source.
protected final ConcurrentReadInputStream cris

*All reads go here.
*If outputunmapped=false, omit unmapped single reads and double-unmapped paired reads.
protected final ConcurrentReadOutputStream outStream

*All mapped reads (and half-mapped pairs) go here except reads that only map to the blacklist.
protected final ConcurrentReadOutputStream outStreamMapped

*All unmapped reads (and double-unmapped pairs) go here.
protected final ConcurrentReadOutputStream outStreamUnmapped

*All reads (and half-mapped pairs) that map best to the blacklist go here.
protected final ConcurrentReadOutputStream outStreamBlack

public final String MSA_TYPE

final MSA msa

public final ReadStats readstats

public final CoveragePileup pileup

public final int POINTS_MATCH

public final int POINTS_MATCH2

public final int KEYLEN

protected final boolean PERFECTMODE

protected final boolean SEMIPERFECTMODE

protected final boolean FORBID_SELF_MAPPING

protected final boolean RCOMP_MATE

protected static boolean RCOMP=false

*True if this thread should generate a match string for the best match
protected final boolean MAKE_MATCH_STRING

protected final boolean OUTPUT_MAPPED_ONLY

protected final boolean DONT_OUTPUT_BLACKLISTED_READS

protected final boolean PRINT_SECONDARY_ALIGNMENTS

protected final boolean QUICK_MATCH_STRINGS

protected final boolean USE_SS_MATCH_FOR_PRIMARY=true

protected final int MAX_SITESCORES_TO_PRINT

*Scores below the (max possible alignment score)*(MINIMUM_ALIGNMENT_SCORE_RATIO) will be discarded.
*Default: 0.4 for synthetic data.
protected final float MINIMUM_ALIGNMENT_SCORE_RATIO

protected final float MINIMUM_ALIGNMENT_SCORE_RATIO_PRE_RESCUE

protected final float MINIMUM_ALIGNMENT_SCORE_RATIO_PAIRED

protected final float keyDensity

protected final float maxKeyDensity

protected final float minKeyDensity

protected final int maxDesiredKeys

final int CLEARZONE1e

final int MIN_APPROX_HITS_TO_KEEP

final boolean USE_EXTENDED_SCORE

public static final boolean GENERATE_BASE_SCORES_FROM_QUALITY=AbstractIndex.GENERATE_BASE_SCORES_FROM_QUALITY

final int BASE_HIT_SCORE

final int BASE_KEY_HIT_SCORE

final boolean USE_AFFINE_SCORE

final int EXPECTED_LEN_LIMIT

final int MAX_INDEL

final boolean TRIM_LIST

final int TIP_DELETION_SEARCH_RANGE

final boolean FIND_TIP_DELETIONS

final int ALIGN_COLUMNS_ABSTRACT

*Use dynamic programming slow-alignment phase to increase quality. Program may not run anymore if this is disabled.
protected final boolean SLOW_ALIGN

*Produce local alignments instead of global alignments
protected final boolean LOCAL_ALIGN

*Discard reads with ambiguous alignments (consider them unmapped).
protected final boolean AMBIGUOUS_TOSS

*Choose a random site for reads with ambiguous alignments.
protected final boolean AMBIGUOUS_RANDOM

*Output all sites for reads with ambiguous alignments.
protected final boolean AMBIGUOUS_ALL

*Quality-trim left side of reads before mapping.
protected final boolean TRIM_LEFT

*Quality-trim right side of reads before mapping.
protected final boolean TRIM_RIGHT

*Undo quality trimming after mapping.
protected final boolean UNTRIM

*Trim until 2 consecutive bases are encountered with at least this quality.
protected final float TRIM_QUAL

protected final float TRIM_ERROR_RATE

*Don't trim reads to be shorter than this
protected final int TRIM_MIN_LENGTH

*Distance cutoff for classifying a read as loosely correct
protected final int THRESH

*Semi-deprecated. Minimum chrom to index or load.
protected final int minChrom

*Semi-deprecated. Maximum chrom to index or load.
protected final int maxChrom

*Disallow sites that do not have at least k consecutive matching bases.
protected final int KFILTER

*Disallow sites with identity below this.
protected final float IDFILTER

*Do advanced filtering on number of specific types of edits
protected final boolean PROCESS_EDIT_FILTER

*Rename reads to indicate their mapped insert size
protected final boolean RenameByInsert

*When reads are not in valid pairing orientation, eliminate (mark unmapped) the lower-scoring read.
protected final boolean KILL_BAD_PAIRS

*For human genome, map ambiguous reads in the PAR to the X chromosome.
protected final boolean SAVE_AMBIGUOUS_XY

*Deprecated. Must be set to true.
protected final boolean GEN_MATCH_FAST=true

*Padding for dynamic-programming slow alignment.
protected final int SLOW_ALIGN_PADDING

*Padding for dynamic-programming slow alignment for rescued reads (which typically may need more padding).
protected final int SLOW_RESCUE_PADDING

*If a site is unpaired, search nearby for a possible site for the other read.
protected final boolean DO_RESCUE

*Forbid alignments with indels longer than MAX_INDEL
protected final boolean STRICT_MAX_INDEL

*Bandwidth of banded MSA
protected final int BANDWIDTH

protected final boolean PAIRED

protected final boolean REQUIRE_CORRECT_STRANDS_PAIRS

protected final boolean SAME_STRAND_PAIRS

protected final BloomFilter bloomFilter

static int INITIAL_AVERAGE_PAIR_DIST=100

protected int AVERAGE_PAIR_DIST

protected float AVERAGE_PAIRING_RATE=0

*Extra padding for when slow alignment fails.
protected int EXTRA_PADDING=10

protected final boolean GENERATE_KEY_SCORES_FROM_QUALITY

protected static boolean PENALIZE_AMBIG=true

protected static int SUBFILTER=-1

protected static int DELFILTER=-1

protected static int INSFILTER=-1

protected static int INDELFILTER=-1

protected static int DELLENFILTER=-1

protected static int INSLENFILTER=-1

protected static int EDITFILTER=-1

protected static int NFILTER=-1

protected static boolean OUTPUT_SAM=false

protected static float SECONDARY_SITE_SCORE_RATIO=.95f

protected static boolean PRINT_SECONDARY_ALIGNMENTS_ONLY_FOR_AMBIGUOUS_READS=false

protected static boolean CALC_STATISTICS=true

protected static int MIN_PAIR_DIST=-160

protected static int MAX_PAIR_DIST=32000

protected static int MAX_RESCUE_DIST=1200

protected static int MAX_RESCUE_MISMATCHES=32

*IMPORTANT!!!! This option causes non-deterministic output.
protected static boolean DYNAMIC_INSERT_LENGTH=true

*Counts undefined bases.
protected static final boolean DISCARD_MOSTLY_UNDEFINED_READS=true

protected static float MIN_AVERAGE_QUALITY=0

protected static int MIN_AVERAGE_QUALITY_BASES=0

protected static boolean TIME_TAG=false

protected static boolean CLEAR_ATTACHMENT=true

protected static final byte TIP_DELETION_MIN_QUALITY=6

protected static final byte TIP_DELETION_AVG_QUALITY=14

protected static final int TIP_DELETION_MAX_TIPLEN=8

protected static final int OUTER_DIST_MULT=14

protected static final int OUTER_DIST_DIV=32

protected static long SKIP_INITIAL=0

protected static boolean OUTPUT_PAIRED_ONLY=false

protected static int MAX_READ_LENGTH=0

protected static int MIN_READ_LENGTH=0

protected static boolean USE_MODULO=false

protected static int MAX_TRIM_SITES_TO_RETAIN=800

public long totalNumCorrect1=0

public long totalNumIncorrect1=0

public long totalNumIncorrectPrior1=0

public long totalNumCapturedAllCorrect1=0

public long totalNumCapturedAllCorrectTop1=0

public long totalNumCapturedAllCorrectOnly1=0

public long totalNumCorrect2=0

public long totalNumIncorrect2=0

public long totalNumIncorrectPrior2=0

public long totalNumCapturedAllCorrect2=0

public long totalNumCapturedAllCorrectTop2=0

public long totalNumCapturedAllCorrectOnly2=0

public boolean verbose=false

public static final boolean verboseS=false

public long readsUsed1=0

public long readsUsed2=0

public long basesUsed1=0

public long basesUsed2=0

public long readsIn1=0

public long readsIn2=0

public long basesIn1=0

public long basesIn2=0

public long readsPassedBloomFilter=0

public long basesPassedBloomFilter=0

public long numMated=0

public long numMatedBases=0

public long badPairs=0

public long badPairBases=0

public long innerLengthSum=0

public long outerLengthSum=0

public long insertSizeSum=0

public long keysUsed=0

public long syntheticReads=0

public long bothUnmapped=0

public long bothUnmappedBases=0

public long eitherMapped=0

public long eitherMappedBases=0

public long mapped1=0

public long mappedRetained1=0

public long mappedRetainedBases1=0

public long rescuedP1=0

public long rescuedM1=0

public long truePositiveP1=0

public long truePositiveM1=0

public long falsePositive1=0

public long totalCorrectSites1=0

public long firstSiteCorrectP1=0

public long firstSiteCorrectM1=0

public long firstSiteIncorrect1=0

public long firstSiteCorrectLoose1=0

public long firstSiteIncorrectLoose1=0

public long firstSiteCorrectPaired1=0

public long firstSiteCorrectSolo1=0

public long firstSiteCorrectRescued1=0

public long matchCountS1=0

public long matchCountI1=0

public long matchCountD1=0

public long matchCountM1=0

public long matchCountN1=0

public long readCountE1=0

public long readCountS1=0

public long readCountI1=0

public long readCountD1=0

public long readCountN1=0

public long readCountSplice1=0

public long perfectHit1=0

public long uniqueHit1=0

public long correctUniqueHit1=0

public long correctMultiHit1=0

public long correctLowHit1=0

public long noHit1=0

*Number of perfect hit sites found
public long perfectHitCount1=0

*Number of sites found that are perfect except for no-ref
public long semiPerfectHitCount1=0

public long perfectMatch1=0

public long semiperfectMatch1=0

public long perfectMatchBases1=0

public long semiperfectMatchBases1=0

public long ambiguousBestAlignment1=0

public long ambiguousBestAlignmentBases1=0

public long initialSiteSum1=0

public long postTrimSiteSum1=0

public long postRescueSiteSum1=0

public long siteSum1=0

public long topSiteSum1=0

public long lowQualityReadsDiscarded1=0

public long lowQualityBasesDiscarded1=0

public long mapped2=0

public long mappedRetained2=0

public long mappedRetainedBases2=0

public long rescuedP2=0

public long rescuedM2=0

public long truePositiveP2=0

public long truePositiveM2=0

public long falsePositive2=0

public long totalCorrectSites2=0

public long firstSiteCorrectP2=0

public long firstSiteCorrectM2=0

public long firstSiteIncorrect2=0

public long firstSiteCorrectLoose2=0

public long firstSiteIncorrectLoose2=0

public long firstSiteCorrectPaired2=0

public long firstSiteCorrectSolo2=0

public long firstSiteCorrectRescued2=0

public long matchCountS2=0

public long matchCountI2=0

public long matchCountD2=0

public long matchCountM2=0

public long matchCountN2=0

public long readCountE2=0

public long readCountS2=0

public long readCountI2=0

public long readCountD2=0

public long readCountN2=0

public long readCountSplice2=0

public long perfectHit2=0

public long uniqueHit2=0

public long correctUniqueHit2=0

public long correctMultiHit2=0

public long correctLowHit2=0

public long noHit2=0

*Number of perfect hit sites found
public long perfectHitCount2=0

*Number of sites found that are perfect except for no-ref
public long semiPerfectHitCount2=0

public long perfectMatch2=0

public long semiperfectMatch2=0

public long perfectMatchBases2=0

public long semiperfectMatchBases2=0

public long ambiguousBestAlignment2=0

public long ambiguousBestAlignmentBases2=0

public long initialSiteSum2=0

public long postTrimSiteSum2=0

public long postRescueSiteSum2=0

public long siteSum2=0

public long topSiteSum2=0

public long lowQualityReadsDiscarded2=0

public long lowQualityBasesDiscarded2=0

int idmodulo


#Methods
AbstractMapThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, CoveragePileup pileup_, boolean SLOW_ALIGN_, boolean LOCAL_ALIGN_, boolean AMBIGUOUS_TOSS_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int MIN_TRIM_LEN_, int THRESH_, int minChrom_, int maxChrom_, int KFILTER_, float IDFILTER_, boolean KILL_BAD_PAIRS_, boolean SAVE_AMBIGUOUS_XY_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean DO_RESCUE_, boolean STRICT_MAX_INDEL_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, String MSA_TYPE_, int keylen_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, boolean RCOMP_MATE_, boolean MAKE_MATCH_STRING_, boolean OUTPUT_MAPPED_ONLY_, boolean DONT_OUTPUT_BLACKLISTED_READS_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean QUICK_MATCH_STRINGS_, int MAX_SITESCORES_TO_PRINT_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, int MIN_APPROX_HITS_TO_KEEP_, boolean USE_EXTENDED_SCORE_, int BASE_HIT_SCORE_, boolean USE_AFFINE_SCORE_, int MAX_INDEL_, boolean TRIM_LIST_, int TIP_DELETION_SEARCH_RANGE_, BloomFilter bloomFilter_)

public int ALIGN_COLUMNS()

public int ALIGN_ROWS()

int CLEARZONE1()

AbstractIndex index()

public final void postFilterRead(Read r, byte[] basesM, int maxImperfectSwScore, int maxSwScore)

final int ensureMatchStringsOnSiteScores(Read r, byte[] basesM, int maxImperfectSwScore, int maxSwScore)

final int ensureMatchStringOnPrimary(Read r, byte[] basesM, int maxImperfectSwScore, int maxSwScore)

public final boolean processMapqFilter(Read r, int minMapq, int minMapqUnpaired)

public final boolean processIDFilter(Read r, byte[] basesM, int maxImperfectSwScore, int maxSwScore)

public final boolean processEditFilter(Read r, byte[] basesM, int maxImperfectSwScore, int maxSwScore)

public final void run()

private final void writeList(ArrayList<Read> readlist, boolean black, long listNumID)

*Returns max possible quick score for this read, or -1 if it cannot be mapped for quality reasons.
*A positive score will be returned if it CAN be mapped, but no hits are found.
public final int quickMap(Read r, byte[] basesM)

*Returns number of scores of at least maxImperfectSwScore.
*If problems are encountered such that it is prudent to do slow-alignment, a number lower than 1 will be returned.
final int scoreNoIndels(Read r, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

*Assumes list is sorted
public final void genMatchString(Read r, byte[] basesP, byte[] basesM, int maxImperfectSwScore, int maxSwScore, boolean setSSScore, boolean recur)

protected final int genMatchStringForSite(long id, SiteScore ss, byte[] basesP, byte[] basesM, int maxImperfectSwScore, int maxSwScore, Read mate, boolean secondary)

*Returns the number of additional bases away that should be searched for slow align.
*This should probably be called between quickMap and slowAlign, only on
*sites where stop-start<=bases.length-1
final void findTipDeletions(Read r, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectScore)

final boolean findTipDeletions(SiteScore ss, byte[] bases, int maxImperfectScore, boolean lookRight, boolean lookLeft)

final void rescue(Read anchor, Read loose, byte[] basesP, byte[] basesM, int searchDist)

final void slowRescue(byte[] bases, SiteScore ss, int maxScore, int maxImperfectScore, boolean findTipDeletionsRight, boolean findTipDeletionsLeft)

protected static final void capSiteList(Read r, int cap, boolean printSecondary)

protected static final int removeDuplicateBestSites(Read r)

protected static final void removeUnmapped(ArrayList<Read> list)

protected static final void removeBlacklisted(ArrayList<Read> list)

protected static final void removeMapped(ArrayList<Read> list)

public int trimList(ArrayList<SiteScore> list, boolean retainPaired, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain)

public static final int trimListAdvanced(ArrayList<SiteScore> list, boolean retainPaired, boolean retainSemiperfect, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain, boolean indexUsesExtendedScore, float thresh)

public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

*This is only for saving ambiguous xy which is now irrelevant.
public static final boolean processAmbiguous(ArrayList<SiteScore> list, boolean primary, boolean removeAmbiguous, int clearzone, boolean save_xy)

int calcTrimmed(Read r)

public void calcStatistics1(Read r, int maxSwScore, int maxPossibleQuickScore)

public void calcStatistics2(Read r, int maxSwScore, int maxPossibleQuickScore)

public void processRead(Read r, byte[] basesM)

@Deprecated protected static final boolean applyClearzone3_old(Read r, int CLEARZONE3, float INV_CLEARZONE3)

protected final boolean applyClearzone3(Read r, int CLEARZONE3, float INV_CLEARZONE3)

protected float calcCZ3_fraction(int score1, int score2, int CLEARZONE3, float INV_CLEARZONE3)

*Returns number of perfect pairs
public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

protected static void pairSiteScoresFinal(Read r, Read r2, boolean trim, boolean setScore, int MAX_PAIR_DIST, int AVERAGE_PAIR_DIST, boolean SAME_STRAND_PAIRS, boolean REQUIRE_CORRECT_STRANDS_PAIRS, int maxTrimSitesToRetain)

protected static final boolean canPair(SiteScore ss1, SiteScore ss2, int len1, int len2, boolean REQUIRE_CORRECT_STRANDS_PAIRS, boolean SAME_STRAND_PAIRS, int MAX_PAIR_DIST)

*Returns the number of additional bases away that should be searched for slow align.
*This should probably be called between quickMap and slowAlign, only on
*sites where stop-start<=bases.length-1
protected static final int findTipDeletionsRight(byte[] bases, int chrom, int originalStop, int searchDist, int tiplen)

*Returns the number of additional bases away that should be searched for slow align.
*This should probably be called between quickMap and slowAlign, only on
*sites where stop-start<=bases.length-1
protected static final int findTipDeletionsLeft(byte[] bases, int chrom, int originalStart, int searchDist, int tiplen)

*Assumes bases are already on the correct strand
public final SiteScore quickRescue(byte[] bases, int chrom, byte strand, int loc, int searchDist, boolean searchRight, int idealStart, int maxAllowedMismatches, int POINTS_MATCH, int POINTS_MATCH2)

*Assumes bases are already on the correct strand
protected static final int[] quickerRescue(byte[] bases, int chrom, int loc, int searchDist)

public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

*TODO: Iterate through loop backwards when removing sites.
*@param r
*@param DONT_OUTPUT_UNMAPPED_READS
*@param SAM_OUT
*@param EXPECTED_LEN_LIMIT
*@return Number of sites removed
protected static final int removeOutOfBounds(Read r, boolean DONT_OUTPUT_UNMAPPED_READS, boolean SAM_OUT, int EXPECTED_LEN_LIMIT)

protected static final int forbidSelfMapping(ArrayList<SiteScore> ssl, SiteScore original)

*Generate a score penalty based on the presence of errors near the read tips.
public static int calcTipScorePenalty(Read r, int maxScore, int tiplen)

public static void applyScorePenalty(Read r, int penalty)

*{group of correct hit (or -1), size of correct group, number of groups,
*number of elements, correctScore, maxScore, size of top group, num correct, firstElementCorrect,
*firstElementCorrectLoose, firstGroupCorrectLoose}
protected int[] calcCorrectness(Read r, int thresh)

public static final boolean isCorrectHit(SiteScore ss, int trueChrom, byte trueStrand, int trueStart, int trueStop, int thresh)

public static final boolean isCorrectHitLoose(SiteScore ss, int trueChrom, byte trueStrand, int trueStart, int trueStop, int thresh)

protected static final byte[] makePerfectMatchString(int len)

protected static final int absdif(int a, int b)

*Returns maximum read length supported by this mapper
public int maxReadLength()

*Ensure top site is congruent with read
protected static final boolean checkTopSite(Read r)

protected static final int removeLongIndels(ArrayList<SiteScore> list, int maxlen)

protected static final boolean hasLongIndel(byte[] match, int maxlen)

*TODO
final void processReadSplit(Read r, byte[] basesM, int minlen, int maxlen)

public final boolean finished()

public final boolean working()

final void finish()

</class AbstractMapThread>
<class BandedAligner>
*@author Brian Bushnell
*@date Aug 5, 2013
public abstract class BandedAligner

#Fields
*Final row aligned in last alignment.
public int lastRow

*Final edits value in last alignment.
public int lastEdits

*Position of min value in array (meaning the best alignment) relative to the middle of the array.
*Positive value is to the right (ref sequence longer than query), negative value left (ref shorter than query)
protected int lastOffset

public int lastRefLoc

public int lastQueryLoc

public final int maxWidth

public static final int big=99999999

public static boolean verbose=false

*Penalizes non-length-neutral alignments.
*This causes query-to-ref alignment to yield same score as ref-to-query alignment, which is useful for assertions.
public static boolean penalizeOffCenter=true


#Methods
public BandedAligner(int width_)

public static final BandedAligner makeBandedAligner(int width_)

public final int alignQuadrupleProgressive(byte[] query, byte[] ref, int minEdits, int maxEdits, boolean exact)

public final int alignQuadruple(byte[] query, byte[] ref, int maxEdits, boolean exact)

public final int alignDouble(byte[] query, byte[] ref, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
public int alignForward(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
public int alignForwardRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
public int alignReverse(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
public int alignReverseRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

protected void fillBig(int[] array)

*Score is lastRow-edits
public final int score()

*Position of min value in array (meaning the best alignment) relative to the middle of the array.
protected int lastOffset(int[] array, int halfWidth)

protected int penalizeOffCenter_old(int[] array, int halfWidth)

protected int penalizeOffCenter(int[] array, int halfWidth)

</class BandedAligner>
<class BandedAlignerConcrete>
*@author Brian Bushnell
*@date Aug 5, 2013
public class BandedAlignerConcrete

#Fields
private final int[] array1

private final int[] array2

private int[] arrayCurrent

private int[] arrayPrev

private int[] arrayTemp


#Methods
public static void main(String[] args)

public BandedAlignerConcrete(int width_)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignForward(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignForwardRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignReverse(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignReverseRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

</class BandedAlignerConcrete>
<class BandedAlignerJNI>
*@author Jonathan Rood
*@date Jul 18, 2014
public class BandedAlignerJNI

#Methods
private int alignForwardJNI(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact, int maxWidth, byte[] baseToNumber, int[] returnVals)

private int alignForwardRCJNI(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact, int maxWidth, byte[] baseToNumber, byte[] baseToComplementExtended, int[] returnVals)

private int alignReverseJNI(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact, int maxWidth, byte[] baseToNumber, int[] returnVals)

private int alignReverseRCJNI(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact, int maxWidth, byte[] baseToNumber, byte[] baseToComplementExtended, int[] returnVals)

public static void main(String[] args)

public BandedAlignerJNI(int width_)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignForward(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignForwardRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignReverse(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

*@param query
*@param ref
*@param qstart
*@param rstart
*@return Edit distance
@Override public int alignReverseRC(byte[] query, byte[] ref, int qstart, int rstart, int maxEdits, boolean exact)

</class BandedAlignerJNI>
<class BBIndex>
*Based on Index11f
*Index stored in single array per block.
*@author Brian Bushnell
*@date Dec 22, 2012
public final class BBIndex

#Fields
private static final int KEY_BUFFER_LENGTH=256

private final int[][] locArrays=new int[601][]

private final int[] valueArray=new int[KEY_BUFFER_LENGTH]

private final int[] sizeArray=new int[KEY_BUFFER_LENGTH]

private final int[][] offsetArrays=new int[KEY_BUFFER_LENGTH][]

private final int[][] greedyListArrays=new int[KEY_BUFFER_LENGTH][]

private final int[][] genericArrays=new int[KEY_BUFFER_LENGTH][]

private final int[] startArray=new int[KEY_BUFFER_LENGTH]

private final int[] stopArray=new int[KEY_BUFFER_LENGTH]

private final Quad[] tripleStorage=makeQuadStorage(KEY_BUFFER_LENGTH)

private final int[] greedyReturn=KillSwitch.allocInt1D(2)

private final int[][] shrinkReturn2=new int[3][]

private final int[][] shrinkReturn3=new int[5][]

private final int[][] prescanReturn=new int[2][]

private final int[] prescoreArray

private final int[] precountArray

private final byte[][][] baseScoreArrays=new byte[2][601][]

private final int[][][] keyScoreArrays=new int[2][KEY_BUFFER_LENGTH][]

final float[] keyProbArray=new float[601]

private final float[][] keyWeightArrays=new float[KEY_BUFFER_LENGTH][]

private final QuadHeap heap=new QuadHeap(KEY_BUFFER_LENGTH - 1)

private final QuadHeap active=new QuadHeap(KEY_BUFFER_LENGTH - 1)

static int SHIFT_LENGTH=(32 - 1 - NUM_CHROM_BITS)

static int MAX_ALLOWED_CHROM_INDEX=~((-1) << SHIFT_LENGTH)

*Mask the number to get the site, which is in the lower bits
static int SITE_MASK=((-1) >>> (NUM_CHROM_BITS + 1))

*Mask the chromosome's high bits to get the low bits
static int CHROM_MASK_LOW=CHROMS_PER_BLOCK - 1

*Mask the chromosome's lower bits to get the high bits
static int CHROM_MASK_HIGH=~CHROM_MASK_LOW

private final int cycles

public static final int BASE_HIT_SCORE=100

public static final int ALIGN_COLUMNS=3000

public static int MAX_INDEL=16000

public static int MAX_INDEL2=2 * MAX_INDEL

private final float INV_BASE_KEY_HIT_SCORE

private final int INDEL_PENALTY

private final int INDEL_PENALTY_MULT

private final int MAX_PENALTY_FOR_MISALIGNED_HIT

private final int SCOREZ_1KEY

public static final boolean ADD_SCORE_Z=true

public static final int Z_SCORE_MULT=20

public static final int Y_SCORE_MULT=10

static float FRACTION_GENOME_TO_EXCLUDE=0.03f

*Default .75. Range: 0 to 1 (but 0 will break everything). Lower is faster and less accurate.
static final float HIT_FRACTION_TO_RETAIN=0.85f

*Range: 0 to 1000. Lower should be faster and less accurate.
static int MIN_INDEX_TO_DROP_LONG_HIT_LIST=(int)(1000 * (1 - 3.5 * FRACTION_GENOME_TO_EXCLUDE))

*Range: 2 to infinity. Lower should be faster and less accurate.
static final int MIN_HIT_LISTS_TO_RETAIN=6

static int MAX_AVERAGE_LIST_TO_SEARCH=(int)(1000 * (1 - 2.3 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_AVERAGE_LIST_TO_SEARCH2=(int)(1000 * (1 - 1.4 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SINGLE_LIST_TO_SEARCH=(int)(1000 * (1 - 1.0 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SHORTEST_LIST_TO_SEARCH=(int)(1000 * (1 - 2.8 * FRACTION_GENOME_TO_EXCLUDE))

*To increase accuracy on small genomes, override greedy list dismissal when the list is at most this long.
public static final int SMALL_GENOME_LIST=20

static final int CLUMPY_MAX_DIST=5

*Minimum length of list before clumpiness is considered. This is an index in the length histogram, from 0 to 1000.
static final int CLUMPY_MIN_LENGTH_INDEX=2000

static final float CLUMPY_FRACTION=0.75f

static final int MAX_SUBSUMPTION_LENGTH=MAX_INDEL2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION1 when slowWalk3 is first entered
public static final int MAX_HITS_REDUCTION1=0

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION2 dynamically when best score is exceeded
public static int MAX_HITS_REDUCTION2=2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION_PERFECT when perfect score is found
public static final int MAX_HITS_REDUCTION_PERFECT=0

public static int MAXIMUM_MAX_HITS_REDUCTION=3

public static int HIT_REDUCTION_DIV=5

public static final boolean USE_SLOWALK3=true && USE_EXTENDED_SCORE

public static boolean PRESCAN_QSCORE=true && USE_EXTENDED_SCORE

public static final boolean FILTER_BY_QSCORE=true

public static final float MIN_SCORE_MULT=(USE_AFFINE_SCORE ? 0.15f : USE_EXTENDED_SCORE ? .3f : 0.10f)

public static final float MIN_QSCORE_MULT=0.025f

public static final float MIN_QSCORE_MULT2=0.1f

static final float DYNAMIC_SCORE_THRESH=(USE_AFFINE_SCORE ? 0.84f : USE_EXTENDED_SCORE ? .84f : 0.6f)

static final float DYNAMIC_QSCORE_THRESH=0.6f

static final float DYNAMIC_QSCORE_THRESH_PERFECT=0.8f

static final float PRESCAN_QSCORE_THRESH=DYNAMIC_QSCORE_THRESH * .95f


#Methods
public static void main(String[] args)

public BBIndex(int k_, int minChrom_, int maxChrom_, int kfilter_, MSA msa_)

*Load or generate index from minChrom to maxChrom, inclusive, with keylength k.
*This range can encompass multiple blocks.
*Should only be called once in a process.
public static final void loadIndex(int minChrom, int maxChrom, int k, boolean writeToDisk, boolean diskInvalid)

*Calculate statistics of index, such as list lengths, and find clumpy keys
public static final void analyzeIndex(int minChrom, int maxChrom, float fractionToExclude, int k)

*Returns the filename for the block holding this chrom
public static final String fname(int chrom, int k)

*Ensure key offsets are strictly ascending.
private static boolean checkOffsets(int[] offsets)

@Deprecated private final int trimExcessHitLists(int[] keys, int[][] hits)

*Remove least useful keys to accelerate search
private final int trimExcessHitListsByGreedy(int[] offsets, int[] keyScores, int maxHitLists, int[] keys)

private final int getHits(int[] keys, int chrom, int maxLen, int[] starts, int[] stops)

private final int countHits(int[] keys, int maxLen, boolean clearBadKeys)

@Override public final ArrayList<SiteScore> findAdvanced(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsets, long id)

public final ArrayList<SiteScore> find(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsetsP, boolean obeyLimits, long id)

*Search blocks rapidly to find max hits, and perfect sites. May indicate some blocks can be skipped.
private final int[][] prescanAllBlocks(int[] bestScores, int[] keysP, int[] keyScoresP, int[] offsetsP, int[] keysM, int[] keyScoresM, int[] offsetsM, boolean allBasesCovered)

*Search a single block and strand
public final ArrayList<SiteScore> find(int[] keys, byte[] bases, byte[] baseScores, int[] keyScores, int chrom, byte strand, int[] offsets, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Compress arrays by removing null/empty lists
private final int[][] shrink(int[] starts, int[] stops, int[] offsets, int[] keyScores, int len)

*Removes "-1" keys.
private final int[][] shrink2(int[] offsets, int[] keys, int[] keyScores)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk2(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, boolean fullyDefined)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Uses dual heaps - reserve (big) and active (small).
private final ArrayList<SiteScore> camelWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

private final int[] findMaxQscore2(int[] starts, int[] stops, int[] offsets, int[] keyScores, int baseChrom_, Quad[] triples, int[] values, int prevMaxHits, boolean earlyExit, boolean perfectOnly)

private static final int absdif(int a, int b)

@Override final int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public final int maxQuickScore(int[] offsets, int[] keyScores)

private final int quickScore(int[] locs, int[] keyScores, int centerIndex, int offsets, int[] sizes, boolean penalizeIndels, int numApproxHits, int numHits)

private final int extendScore(byte[] bases, byte[] baseScores, int[] offsets, int[] values, int chrom, int centerIndex, int[] locArray, int numHits, int numApproxHits)

*NOTE! This destroys the locArray, so use a copy if needed.
private static final int[] makeGapArray(int[] locArray, int minLoc, int minGap)

*Generates a term that increases score with how many bases in the read match the ref.
private final int scoreZ2(int[] locs, int centerIndex, int offsets, int numApproxHits, int numHits)

@Deprecated private final int scoreZslow(int[] locs, int centerIndex, int offsets, boolean display, int numHits)

*Generates a term that increases score with how many bases in the read match the ref.
private final int maxScoreZ(int offsets)

private final int scoreRight(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels, int numHits)

private final int scoreLeft(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels)

*Encode a (location, chrom) pair to an index
private static final int toNumber(int site, int chrom)

*Decode an (index, baseChrom) pair to a chromosome
private static final int numberToChrom(int number, int baseChrom)

*Decode an index to a location
private static final int numberToSite(int number)

private static final int minChrom(int chrom)

private static final int baseChrom(int chrom)

private static final int maxChrom(int chrom)

private final int[] getOffsetArray(int len)

private final int[] getLocArray(int len)

private final int[] getGreedyListArray(int len)

private final int[] getGenericArray(int len)

@Override final byte[] getBaseScoreArray(int len, int strand)

@Override final int[] getKeyScoreArray(int len, int strand)

private final float[] getKeyWeightArray(int len)

@Override float[] keyProbArray()

private static final Quad[] makeQuadStorage(int number)

static void setChromBits(int x)

*Return only sites that match completely or with partial no-reference
public static void setSemiperfectMode()

*Return only sites that match completely
public static void setPerfectMode()

public static final void setFractionToExclude(float f)

private static final int calcApproxHitsCutoff(int keys, int hits, int currentCutoff, boolean perfect)

</class BBIndex>
<class BBIndex5>
*Based on Index11f
*Index stored in single array per block.
*Supports 32-bit unsigned index.
*@author Brian Bushnell
*@date Jan 3, 2013
public final class BBIndex5

#Fields
private final int[][] locArrays=new int[601][]

private final int[] valueArray=new int[128]

private final int[] sizeArray=new int[128]

private final int[][] offsetArrays=new int[128][]

private final int[][] greedyListArrays=new int[128][]

private final int[][] genericArrays=new int[128][]

private final int[] startArray=new int[128]

private final int[] stopArray=new int[128]

private final Quad64[] tripleStorage=makeQuad64Storage(128)

private final int[] greedyReturn=KillSwitch.allocInt1D(2)

private final int[][] shrinkReturn2=new int[3][]

private final int[][] shrinkReturn3=new int[5][]

private final int[][] prescanReturn=new int[2][]

private final int[] prescoreArray

private final int[] precountArray

private final byte[][][] baseScoreArrays=new byte[2][601][]

private final int[][][] keyScoreArrays=new int[2][128][]

final float[] keyProbArray=new float[601]

private final float[][] keyWeightArrays=new float[128][]

private final Quad64Heap heap=new Quad64Heap(127)

static int SHIFT_LENGTH=(32 - NUM_CHROM_BITS)

static int MAX_ALLOWED_CHROM_INDEX=~((-1) << SHIFT_LENGTH)

*Mask the number to get the site, which is in the lower bits
static int SITE_MASK=((-1) >>> (NUM_CHROM_BITS))

*Mask the chromosome's high bits to get the low bits
static int CHROM_MASK_LOW=CHROMS_PER_BLOCK - 1

*Mask the chromosome's lower bits to get the high bits
static int CHROM_MASK_HIGH=~CHROM_MASK_LOW

private final int cycles

public static final int BASE_HIT_SCORE=100

public static final int ALIGN_COLUMNS=3000

public static int MAX_INDEL=16000

public static int MAX_INDEL2=2 * MAX_INDEL

private final float INV_BASE_KEY_HIT_SCORE

private final int INDEL_PENALTY

private final int INDEL_PENALTY_MULT

private final int MAX_PENALTY_FOR_MISALIGNED_HIT

private final int SCOREZ_1KEY

public static final boolean ADD_SCORE_Z=true

public static final int Z_SCORE_MULT=20

public static final int Y_SCORE_MULT=10

static float FRACTION_GENOME_TO_EXCLUDE=0.03f

*Default .75. Range: 0 to 1 (but 0 will break everything). Lower is faster and less accurate.
static final float HIT_FRACTION_TO_RETAIN=0.85f

*Range: 0 to 1000. Lower should be faster and less accurate.
static int MIN_INDEX_TO_DROP_LONG_HIT_LIST=(int)(1000 * (1 - 3.5 * FRACTION_GENOME_TO_EXCLUDE))

*Range: 2 to infinity. Lower should be faster and less accurate.
static final int MIN_HIT_LISTS_TO_RETAIN=6

static int MAX_AVERAGE_LIST_TO_SEARCH=(int)(1000 * (1 - 2.3 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_AVERAGE_LIST_TO_SEARCH2=(int)(1000 * (1 - 1.4 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SINGLE_LIST_TO_SEARCH=(int)(1000 * (1 - 1.0 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SHORTEST_LIST_TO_SEARCH=(int)(1000 * (1 - 2.8 * FRACTION_GENOME_TO_EXCLUDE))

*To increase accuracy on small genomes, override greedy list dismissal when the list is at most this long.
public static final int SMALL_GENOME_LIST=20

static final int CLUMPY_MAX_DIST=5

*Minimum length of list before clumpiness is considered. This is an index in the length histogram, from 0 to 1000.
static final int CLUMPY_MIN_LENGTH_INDEX=2000

static final float CLUMPY_FRACTION=0.75f

static final int MAX_SUBSUMPTION_LENGTH=MAX_INDEL2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION1 when slowWalk3 is first entered
public static final int MAX_HITS_REDUCTION1=0

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION2 dynamically when best score is exceeded
public static int MAX_HITS_REDUCTION2=2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION_PERFECT when perfect score is found
public static final int MAX_HITS_REDUCTION_PERFECT=0

public static int MAXIMUM_MAX_HITS_REDUCTION=3

public static int HIT_REDUCTION_DIV=5

public static final boolean USE_SLOWALK3=true && USE_EXTENDED_SCORE

public static boolean PRESCAN_QSCORE=true && USE_EXTENDED_SCORE

public static final boolean FILTER_BY_QSCORE=true

public static final float MIN_SCORE_MULT=(USE_AFFINE_SCORE ? 0.15f : USE_EXTENDED_SCORE ? .3f : 0.10f)

public static final float MIN_QSCORE_MULT=0.025f

public static final float MIN_QSCORE_MULT2=0.1f

static final float DYNAMIC_SCORE_THRESH=(USE_AFFINE_SCORE ? 0.84f : USE_EXTENDED_SCORE ? .84f : 0.6f)

static final float DYNAMIC_QSCORE_THRESH=0.6f

static final float DYNAMIC_QSCORE_THRESH_PERFECT=0.8f

static final float PRESCAN_QSCORE_THRESH=DYNAMIC_QSCORE_THRESH * .95f


#Methods
public static void main(String[] args)

public BBIndex5(int k_, int minChrom_, int maxChrom_, int kfilter_, MSA msa_)

*Load or generate index from minChrom to maxChrom, inclusive, with keylength k.
*This range can encompass multiple blocks.
*Should only be called once in a process.
public static final void loadIndex(int minChrom, int maxChrom, int k, boolean writeToDisk, boolean diskInvalid)

*Calculate statistics of index, such as list lengths, and find clumpy keys
public static final void analyzeIndex(int minChrom, int maxChrom, float fractionToExclude, int k)

private final int getHits(int[] keys, int chrom, int maxLen, int[] starts, int[] stops)

private final int countHits(int[] keys, int maxLen, boolean clearBadKeys)

@Override public final ArrayList<SiteScore> findAdvanced(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsets, long id)

public final ArrayList<SiteScore> find(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsetsP, boolean obeyLimits, long id)

*Search blocks rapidly to find max hits, and perfect sites. May indicate some blocks can be skipped.
private final int[][] prescanAllBlocks(int[] bestScores, int[] keysP, int[] keyScoresP, int[] offsetsP, int[] keysM, int[] keyScoresM, int[] offsetsM, boolean allBasesCovered)

*Search a single block and strand
public final ArrayList<SiteScore> find(int[] keys, byte[] bases, byte[] baseScores, int[] keyScores, int chrom, byte strand, int[] offsets, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Compress arrays by removing null/empty lists
private final int[][] shrink(int[] starts, int[] stops, int[] offsets, int[] keyScores, int len)

*Removes "-1" keys.
private final int[][] shrink2(int[] offsets, int[] keys, int[] keyScores)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk2(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, boolean fullyDefined)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

private final int[] findMaxQscore2(int[] starts, int[] stops, int[] offsets, int[] keyScores, int baseChrom_, Quad64[] triples, int[] values, int prevMaxHits, boolean earlyExit, boolean perfectOnly)

*Uses unsigned math
private static final int absdif(int a, int b)

@Override final int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public final int maxQuickScore(int[] offsets, int[] keyScores)

private final int quickScore(int[] values, int[] keyScores, int centerIndex, int offsets, int[] sizes, boolean penalizeIndels, int numApproxHits, int numHits)

private final int extendScore(byte[] bases, byte[] baseScores, int[] offsets, int[] values, int chrom, int centerIndex, int[] locArray, int numHits, int numApproxHits)

*NOTE! This destroys the locArray, so use a copy if needed.
private static final int[] makeGapArray(int[] locArray, int minLoc, int minGap)

*Generates a term that increases score with how many bases in the read match the ref.
private final int scoreZ2(int[] values, int centerIndex, int offsets, int numApproxHits, int numHits)

@Deprecated private final int scoreZslow(int[] locs, int centerIndex, int offsets, boolean display, int numHits)

*Generates a term that increases score with how many bases in the read match the ref.
private final int maxScoreZ(int offsets)

private final int scoreRight(int[] values, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels, int numHits)

private final int scoreLeft(int[] values, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels)

*Encode a (location, chrom) pair to an index
private static final int toNumber(int site, int chrom)

*Decode an (index, baseChrom) pair to a chromosome
private static final int numberToChrom(int number, int baseChrom)

*Decode an index to a location
private static final int numberToSite(int number)

private static int subUnsigned(int a, int b)

private static int addUnsigned(int a, int b)

private static final int minChrom(int chrom)

private static final int baseChrom(int chrom)

private static final int maxChrom(int chrom)

private final int[] getOffsetArray(int len)

private final int[] getLocArray(int len)

private final int[] getGreedyListArray(int len)

private final int[] getGenericArray(int len)

@Override final byte[] getBaseScoreArray(int len, int strand)

@Override final int[] getKeyScoreArray(int len, int strand)

private final float[] getKeyWeightArray(int len)

@Override float[] keyProbArray()

private static final Quad64[] makeQuad64Storage(int number)

static void setChromBits(int x)

*Return only sites that match completely or with partial no-reference
public static void setSemiperfectMode()

*Return only sites that match completely
public static void setPerfectMode()

public static final void setFractionToExclude(float f)

private static final int calcApproxHitsCutoff(int keys, int hits, int currentCutoff, boolean perfect)

</class BBIndex5>
<class BBIndexAcc>
*Based on Index11a
*@author Brian Bushnell
*@date Jul 11, 2012
public final class BBIndexAcc

#Fields
private final int[][] locArrays=new int[601][]

private final int[] valueArray=new int[256]

private final int[] sizeArray=new int[256]

private final int[][] offsetArrays=new int[256][]

private final int[][] greedyListArrays=new int[256][]

private final int[][] genericArrays=new int[256][]

private final int[] startArray=new int[256]

private final int[] stopArray=new int[256]

private final Quad[] tripleStorage=makeQuadStorage(256)

private final int[] greedyReturn=KillSwitch.allocInt1D(2)

private final int[][] shrinkReturn2=new int[3][]

private final int[][] shrinkReturn3=new int[5][]

private final int[][] prescanReturn=new int[2][]

private final int[] prescoreArray

private final int[] precountArray

private final byte[][][] baseScoreArrays=new byte[2][601][]

private final int[][][] keyScoreArrays=new int[2][256][]

final float[] keyProbArray=new float[601]

private final float[][] keyWeightArrays=new float[256][]

private final QuadHeap heap=new QuadHeap(255)

static int SHIFT_LENGTH=(32 - 1 - NUM_CHROM_BITS)

static int MAX_ALLOWED_CHROM_INDEX=~((-1) << SHIFT_LENGTH)

*Mask the number to get the site, which is in the lower bits
static int SITE_MASK=((-1) >>> (NUM_CHROM_BITS + 1))

*Mask the chromosome's high bits to get the low bits
static int CHROM_MASK_LOW=CHROMS_PER_BLOCK - 1

*Mask the chromosome's lower bits to get the high bits
static int CHROM_MASK_HIGH=~CHROM_MASK_LOW

private final int cycles

public static final int BASE_HIT_SCORE=100

public static final int ALIGN_COLUMNS=3000

public static int MAX_INDEL=16000

public static int MAX_INDEL2=2 * MAX_INDEL

private final float INV_BASE_KEY_HIT_SCORE

private final int INDEL_PENALTY

private final int INDEL_PENALTY_MULT

private final int MAX_PENALTY_FOR_MISALIGNED_HIT

private final int SCOREZ_1KEY

public static final boolean ADD_SCORE_Z=true

public static final int Z_SCORE_MULT=20

public static final int Y_SCORE_MULT=10

static float FRACTION_GENOME_TO_EXCLUDE=0.003f

*Default .75. Range: 0 to 1 (but 0 will break everything). Lower is faster and less accurate.
static final float HIT_FRACTION_TO_RETAIN=0.85f

*Range: 0 to 1000. Lower should be faster and less accurate.
static int MIN_INDEX_TO_DROP_LONG_HIT_LIST=(int)(1000 * (1 - 3.5 * FRACTION_GENOME_TO_EXCLUDE))

*Range: 2 to infinity. Lower should be faster and less accurate.
static final int MIN_HIT_LISTS_TO_RETAIN=8

static int MAX_AVERAGE_LIST_TO_SEARCH=(int)(1000 * (1 - 2.3 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_AVERAGE_LIST_TO_SEARCH2=(int)(1000 * (1 - 1.4 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SINGLE_LIST_TO_SEARCH=(int)(1000 * (1 - 1.0 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SHORTEST_LIST_TO_SEARCH=(int)(1000 * (1 - 2.8 * FRACTION_GENOME_TO_EXCLUDE))

*To increase accuracy on small genomes, override greedy list dismissal when the list is at most this long.
public static final int SMALL_GENOME_LIST=80

static final int CLUMPY_MAX_DIST=4

*Minimum length of list before clumpiness is considered. This is an index in the length histogram, from 0 to 1000.
static final int CLUMPY_MIN_LENGTH_INDEX=6000

static final float CLUMPY_FRACTION=0.8f

static final int MAX_SUBSUMPTION_LENGTH=MAX_INDEL2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION1 when slowWalk3 is first entered
public static final int MAX_HITS_REDUCTION1=3

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION2 dynamically when best score is exceeded
public static int MAX_HITS_REDUCTION2=3

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION_PERFECT when perfect score is found
public static int MAX_HITS_REDUCTION_PERFECT=5

public static int MAXIMUM_MAX_HITS_REDUCTION=7

public static int HIT_REDUCTION_DIV=4

public static final boolean USE_SLOWALK3=false && USE_EXTENDED_SCORE

public static boolean PRESCAN_QSCORE=false && USE_EXTENDED_SCORE

public static final boolean FILTER_BY_QSCORE=false

public static final float MIN_SCORE_MULT=(USE_AFFINE_SCORE ? 0.08f : USE_EXTENDED_SCORE ? .3f : 0.10f)

public static final float MIN_QSCORE_MULT=0.01f

public static final float MIN_QSCORE_MULT2=0.1f

static final float DYNAMIC_SCORE_THRESH=(USE_AFFINE_SCORE ? 0.5f : USE_EXTENDED_SCORE ? .84f : 0.6f)

static final float DYNAMIC_QSCORE_THRESH=0.40f

static final float DYNAMIC_QSCORE_THRESH_PERFECT=0.6f

static final float PRESCAN_QSCORE_THRESH=DYNAMIC_QSCORE_THRESH * .8f


#Methods
public static void main(String[] args)

public BBIndexAcc(int k_, int minChrom_, int maxChrom_, int kfilter_, MSA msa_)

*Load or generate index from minChrom to maxChrom, inclusive, with keylength k.
*This range can encompass multiple blocks.
*Should only be called once in a process.
public static final void loadIndex(int minChrom, int maxChrom, int k, boolean writeToDisk, boolean diskInvalid)

*Calculate statistics of index, such as list lengths, and find clumpy keys
public static final void analyzeIndex(int minChrom, int maxChrom, float fractionToExclude, int k)

*Returns the filename for the block holding this chrom
public static final String fname(int chrom, int k)

*Ensure key offsets are strictly ascending.
private static boolean checkOffsets(int[] offsets)

@Deprecated private static final int trimExcessHitLists(int[] keys, int[][] hits)

*Remove least useful keys to accelerate search
private final int trimExcessHitListsByGreedy(int[] offsets, int[] keyScores, int maxHitLists, int[] keys)

private final int getHits(int[] keys, int chrom, int maxLen, int[] starts, int[] stops)

private final int countHits(int[] keys, int maxLen, boolean clearBadKeys)

@Override public final ArrayList<SiteScore> findAdvanced(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsets, long id)

public final ArrayList<SiteScore> find(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsetsP, boolean obeyLimits, long id)

*Search blocks rapidly to find max hits, and perfect sites. May indicate some blocks can be skipped.
private final int[][] prescanAllBlocks(int[] bestScores, int[] keysP, int[] keyScoresP, int[] offsetsP, int[] keysM, int[] keyScoresM, int[] offsetsM, boolean allBasesCovered)

*Search a single block and strand
public final ArrayList<SiteScore> find(int[] keys, byte[] bases, byte[] baseScores, int[] keyScores, int chrom, byte strand, int[] offsets, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Compress arrays by removing null/empty lists
private final int[][] shrink(int[] starts, int[] stops, int[] offsets, int[] keyScores, int len)

*Removes "-1" keys.
private final int[][] shrink2(int[] offsets, int[] keys, int[] keyScores)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk2(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, boolean fullyDefined)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

private final int[] findMaxQscore2(int[] starts, int[] stops, int[] offsets, int[] keyScores, int baseChrom_, Quad[] triples, int[] values, int prevMaxHits, boolean earlyExit, boolean perfectOnly)

private static final int absdif(int a, int b)

@Override final int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public final int maxQuickScore(int[] offsets, int[] keyScores)

private final int quickScore(int[] locs, int[] keyScores, int centerIndex, int offsets, int[] sizes, boolean penalizeIndels, int numApproxHits, int numHits)

private final int extendScore(byte[] bases, byte[] baseScores, int[] offsets, int[] values, int chrom, int centerIndex, int[] locArray, int numHits, int numApproxHits)

*NOTE! This destroys the locArray, so use a copy if needed.
private static final int[] makeGapArray(int[] locArray, int minLoc, int minGap)

*Generates a term that increases score with how many bases in the read match the ref.
private final int scoreZ2(int[] locs, int centerIndex, int offsets, int numApproxHits, int numHits)

@Deprecated private final int scoreZslow(int[] locs, int centerIndex, int offsets, boolean display, int numHits)

*Generates a term that increases score with how many bases in the read match the ref.
private final int maxScoreZ(int offsets)

private final int scoreRight(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels, int numHits)

private final int scoreLeft(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels)

*Encode a (location, chrom) pair to an index
private static final int toNumber(int site, int chrom)

*Decode an (index, baseChrom) pair to a chromosome
private static final int numberToChrom(int number, int baseChrom)

*Decode an index to a location
private static final int numberToSite(int number)

private static final int minChrom(int chrom)

private static final int baseChrom(int chrom)

private static final int maxChrom(int chrom)

private final int[] getOffsetArray(int len)

private final int[] getLocArray(int len)

private final int[] getGreedyListArray(int len)

private final int[] getGenericArray(int len)

@Override final byte[] getBaseScoreArray(int len, int strand)

@Override final int[] getKeyScoreArray(int len, int strand)

private final float[] getKeyWeightArray(int len)

@Override float[] keyProbArray()

private static final Quad[] makeQuadStorage(int number)

static void setChromBits(int x)

*Return only sites that match completely or with partial no-reference
public static void setSemiperfectMode()

*Return only sites that match completely
public static void setPerfectMode()

public static final void setFractionToExclude(float f)

private static final int calcApproxHitsCutoff(int keys, int hits, int currentCutoff, boolean perfect)

</class BBIndexAcc>
<class BBIndexPacBio>
*Based on Index11f
*@author Brian Bushnell
*@date Jul 11, 2012
public final class BBIndexPacBio

#Fields
public static final int KMER_ARRAY_LENGTH=1201

public static final int HEAP_LENGTH=2047

public static final int BASE_ARRAY_LENGTH=6001

private final int[][] locArrays=new int[BASE_ARRAY_LENGTH][]

private final int[] valueArray=new int[HEAP_LENGTH]

private final int[] sizeArray=new int[HEAP_LENGTH]

private final int[][] offsetArrays=new int[KMER_ARRAY_LENGTH][]

private final int[][] greedyListArrays=new int[KMER_ARRAY_LENGTH][]

private final int[][] genericArrays=new int[KMER_ARRAY_LENGTH][]

private final int[] startArray=new int[HEAP_LENGTH]

private final int[] stopArray=new int[HEAP_LENGTH]

private final Quad[] tripleStorage=makeQuadStorage(HEAP_LENGTH)

private final int[] greedyReturn=KillSwitch.allocInt1D(2)

private final int[][] shrinkReturn2=new int[3][]

private final int[][] shrinkReturn3=new int[5][]

private final int[][] prescanReturn=new int[2][]

private final int[] prescoreArray

private final int[] precountArray

private final byte[][][] baseScoreArrays=new byte[2][BASE_ARRAY_LENGTH][]

private final int[][][] keyScoreArrays=new int[2][KMER_ARRAY_LENGTH][]

final float[] keyProbArray=new float[BASE_ARRAY_LENGTH]

private final float[][] keyWeightArrays=new float[KMER_ARRAY_LENGTH][]

private final QuadHeap heap=new QuadHeap(HEAP_LENGTH)

static int SHIFT_LENGTH=(32 - 1 - NUM_CHROM_BITS)

static int MAX_ALLOWED_CHROM_INDEX=~((-1) << SHIFT_LENGTH)

*Mask the number to get the site, which is in the lower bits
static int SITE_MASK=((-1) >>> (NUM_CHROM_BITS + 1))

*Mask the chromosome's high bits to get the low bits
static int CHROM_MASK_LOW=CHROMS_PER_BLOCK - 1

*Mask the chromosome's lower bits to get the high bits
static int CHROM_MASK_HIGH=~CHROM_MASK_LOW

private final int cycles

public static final int BASE_HIT_SCORE=100

public static final int ALIGN_COLUMNS=7600

public static int MAX_INDEL=100

public static int MAX_INDEL2=8 * MAX_INDEL

private final float INV_BASE_KEY_HIT_SCORE

private final int INDEL_PENALTY

private final int INDEL_PENALTY_MULT

private final int MAX_PENALTY_FOR_MISALIGNED_HIT

private final int SCOREZ_1KEY

public static final boolean ADD_SCORE_Z=true

public static final int Z_SCORE_MULT=25

public static final int Y_SCORE_MULT=10

static float FRACTION_GENOME_TO_EXCLUDE=0.005f

*Default .75. Range: 0 to 1 (but 0 will break everything). Lower is faster and less accurate.
static final float HIT_FRACTION_TO_RETAIN=.97f

*Range: 0 to 1000. Lower should be faster and less accurate.
static int MIN_INDEX_TO_DROP_LONG_HIT_LIST=(int)(1000 * (1 - 3.5 * FRACTION_GENOME_TO_EXCLUDE))

*Range: 2 to infinity. Lower should be faster and less accurate.
static final int MIN_HIT_LISTS_TO_RETAIN=12

static int MAX_AVERAGE_LIST_TO_SEARCH=(int)(1000 * (1 - 2.3 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_AVERAGE_LIST_TO_SEARCH2=(int)(1000 * (1 - 1.4 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SINGLE_LIST_TO_SEARCH=(int)(1000 * (1 - 1.0 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SHORTEST_LIST_TO_SEARCH=(int)(1000 * (1 - 2.8 * FRACTION_GENOME_TO_EXCLUDE))

*To increase accuracy on small genomes, override greedy list dismissal when the list is at most this long.
public static final int SMALL_GENOME_LIST=80

static final int CLUMPY_MAX_DIST=5

*Minimum length of list before clumpiness is considered. This is an index in the length histogram, from 0 to 1000.
static final int CLUMPY_MIN_LENGTH_INDEX=2800

static final float CLUMPY_FRACTION=0.8f

static final int MAX_SUBSUMPTION_LENGTH=MAX_INDEL2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION1 when slowWalk3 is first entered
public static final int MAX_HITS_REDUCTION1=2

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION2 dynamically when best score is exceeded
public static int MAX_HITS_REDUCTION2=3

*approxHitsCutoff=maxHits-MAX_HITS_REDUCTION_PERFECT when perfect score is found
public static final int MAX_HITS_REDUCTION_PERFECT=2

public static int MAXIMUM_MAX_HITS_REDUCTION=6

public static int HIT_REDUCTION_DIV=4

public static final boolean USE_SLOWALK3=true && USE_EXTENDED_SCORE

public static boolean PRESCAN_QSCORE=true && USE_EXTENDED_SCORE

public static final boolean FILTER_BY_QSCORE=true

public static final float MIN_SCORE_MULT=(USE_AFFINE_SCORE ? 0.02f : USE_EXTENDED_SCORE ? .3f : 0.10f)

public static final float MIN_QSCORE_MULT=0.005f

public static final float MIN_QSCORE_MULT2=0.005f

static final float DYNAMIC_SCORE_THRESH=(USE_AFFINE_SCORE ? 0.64f : USE_EXTENDED_SCORE ? .74f : 0.6f)

static final float DYNAMIC_QSCORE_THRESH=0.6f

static final float DYNAMIC_QSCORE_THRESH_PERFECT=0.8f

static final float PRESCAN_QSCORE_THRESH=DYNAMIC_QSCORE_THRESH * .95f


#Methods
public BBIndexPacBio(int k_, int minChrom_, int maxChrom_, int kfilter_, MSA msa_)

*Returns the filename for the block holding this chrom
public static final String fname(int chrom, int k)

*Ensure key offsets are strictly ascending.
private static boolean checkOffsets(int[] offsets)

@Deprecated private static final int trimExcessHitLists(int[] keys, int[][] hits)

*Remove least useful keys to accelerate search
public final int trimExcessHitListsByGreedy(int[] offsets, int[] keyScores, int maxHitLists, int[] keys)

private final int getHits(int[] keys, int chrom, int maxLen, int[] starts, int[] stops)

private final int countHits(int[] keys, int maxLen, boolean clearBadKeys)

@Override public final ArrayList<SiteScore> findAdvanced(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsets, long id)

public final ArrayList<SiteScore> find(byte[] basesP, byte[] basesM, byte[] qual, byte[] baseScoresP, int[] keyScoresP, int[] offsetsP, boolean obeyLimits, long id)

*Search blocks rapidly to find max hits, and perfect sites. May indicate some blocks can be skipped.
private final int[][] prescanAllBlocks(int[] bestScores, int[] keysP, int[] keyScoresP, int[] offsetsP, int[] keysM, int[] keyScoresM, int[] offsetsM, boolean allBasesCovered)

*Search a single block and strand
public final ArrayList<SiteScore> find(int[] keys, byte[] bases, byte[] baseScores, int[] keyScores, int chrom, byte strand, int[] offsets, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Compress arrays by removing null/empty lists
private final int[][] shrink(int[] starts, int[] stops, int[] offsets, int[] keyScores, int len)

*Removes "-1" keys.
private final int[][] shrink2(int[] offsets, int[] keys, int[] keyScores)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk2(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, boolean fullyDefined)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

private final int[] findMaxQscore2(int[] starts, int[] stops, int[] offsets, int[] keyScores, int baseChrom_, Quad[] triples, int[] values, int prevMaxHits, boolean earlyExit, boolean perfectOnly)

private static final int absdif(int a, int b)

@Override final int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public final int maxQuickScore(int[] offsets, int[] keyScores)

private final int quickScore(int[] locs, int[] keyScores, int centerIndex, int offsets, int[] sizes, boolean penalizeIndels, int numApproxHits, int numHits)

private final int extendScore(byte[] bases, byte[] baseScores, int[] offsets, int[] values, int chrom, int centerIndex, int[] locArray, int numHits, int numApproxHits)

*NOTE! This destroys the locArray, so use a copy if needed.
private static final int[] makeGapArray(int[] locArray, int minLoc, int minGap)

*Generates a term that increases score with how many bases in the read match the ref.
private final int scoreZ2(int[] locs, int centerIndex, int offsets, int numApproxHits, int numHits)

@Deprecated private final int scoreZslow(int[] locs, int centerIndex, int offsets, boolean display)

*Generates a term that increases score with how many bases in the read match the ref.
private final int maxScoreZ(int offsets)

private final int scoreRight(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels, int numHits)

private final int scoreLeft(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels)

*Encode a (location, chrom) pair to an index
private static final int toNumber(int site, int chrom)

*Decode an (index, baseChrom) pair to a chromosome
private static final int numberToChrom(int number, int baseChrom)

*Decode an index to a location
private static final int numberToSite(int number)

public static final int minChrom(int chrom)

public static final int baseChrom(int chrom)

public static final int maxChrom(int chrom)

private final int[] getOffsetArray(int len)

private final int[] getLocArray(int len)

private final int[] getGreedyListArray(int len)

private final int[] getGenericArray(int len)

@Override final byte[] getBaseScoreArray(int len, int strand)

@Override final int[] getKeyScoreArray(int len, int strand)

private final float[] getKeyWeightArray(int len)

@Override float[] keyProbArray()

private static final Quad[] makeQuadStorage(int number)

static void setChromBits(int x)

*Return only sites that match completely or with partial no-reference
public static void setSemiperfectMode()

*Return only sites that match completely
public static void setPerfectMode()

public static final void setFractionToExclude(float f)

private static final int calcApproxHitsCutoff(int keys, int hits, int currentCutoff, boolean perfect)

</class BBIndexPacBio>
<class BBIndexPacBioSkimmer>
*Based on Index11f
*Designed to skim and retain all sites above a threshold.
*@author Brian Bushnell
*@date Jul 11, 2012
public final class BBIndexPacBioSkimmer

#Fields
private final int[][] locArrays=new int[4001][]

private final int[] valueArray=new int[1001]

private final int[] sizeArray=new int[1001]

private final int[][] offsetArrays=new int[1001][]

private final int[][] greedyListArrays=new int[1001][]

private final int[][] genericArrays=new int[1001][]

private final int[] startArray=new int[1001]

private final int[] stopArray=new int[1001]

private final Quad[] tripleStorage=makeQuadStorage(1001)

private final int[] greedyReturn=KillSwitch.allocInt1D(2)

private final int[][] shrinkReturn2=new int[3][]

private final int[][] shrinkReturn3=new int[5][]

private final int[][] prescanReturn=new int[2][]

private final int[] prescoreArray

private final int[] precountArray

private final byte[][][] baseScoreArrays=new byte[2][4001][]

private final int[][][] keyScoreArrays=new int[2][1001][]

final float[] keyProbArray=new float[4001]

private final float[][] keyWeightArrays=new float[1001][]

private final QuadHeap heap=new QuadHeap(1023)

static int SHIFT_LENGTH=(32 - 1 - NUM_CHROM_BITS)

static int MAX_ALLOWED_CHROM_INDEX=~((-1) << SHIFT_LENGTH)

*Mask the number to get the site, which is in the lower bits
static int SITE_MASK=((-1) >>> (NUM_CHROM_BITS + 1))

*Mask the chromosome's high bits to get the low bits
static int CHROM_MASK_LOW=CHROMS_PER_BLOCK - 1

*Mask the chromosome's lower bits to get the high bits
static int CHROM_MASK_HIGH=~CHROM_MASK_LOW

private final int cycles

public static final int BASE_HIT_SCORE=100

public static final int ALIGN_COLUMNS=5500

public static int MAX_INDEL=96

public static int MAX_INDEL2=8 * MAX_INDEL

private final float INV_BASE_KEY_HIT_SCORE

private final int INDEL_PENALTY

private final int INDEL_PENALTY_MULT

private final int MAX_PENALTY_FOR_MISALIGNED_HIT

private final int SCOREZ_1KEY

public static final boolean ADD_SCORE_Z=true

public static final int Z_SCORE_MULT=25

public static final int Y_SCORE_MULT=5

*Y2 score: based on distance between hits within Y2_INDEL of center
public static final int Y2_SCORE_MULT=5

public static final int Y2_INDEL=4

static float FRACTION_GENOME_TO_EXCLUDE=0.005f

*Default .75. Range: 0 to 1 (but 0 will break everything). Lower is faster and less accurate.
static final float HIT_FRACTION_TO_RETAIN=.97f

*Range: 0 to 1000. Lower should be faster and less accurate.
static int MIN_INDEX_TO_DROP_LONG_HIT_LIST=(int)(1000 * (1 - 3.5 * FRACTION_GENOME_TO_EXCLUDE))

*Range: 2 to infinity. Lower should be faster and less accurate.
static final int MIN_HIT_LISTS_TO_RETAIN=12

static int MAX_AVERAGE_LIST_TO_SEARCH=(int)(1000 * (1 - 2.3 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_AVERAGE_LIST_TO_SEARCH2=(int)(1000 * (1 - 1.4 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SINGLE_LIST_TO_SEARCH=(int)(1000 * (1 - 1.0 * FRACTION_GENOME_TO_EXCLUDE))

static int MAX_SHORTEST_LIST_TO_SEARCH=(int)(1000 * (1 - 2.8 * FRACTION_GENOME_TO_EXCLUDE))

*To increase accuracy on small genomes, override greedy list dismissal when the list is at most this long.
public static final int SMALL_GENOME_LIST=80

static final int CLUMPY_MAX_DIST=5

*Minimum length of list before clumpiness is considered. This is an index in the length histogram, from 0 to 1000.
static final int CLUMPY_MIN_LENGTH_INDEX=2800

static final float CLUMPY_FRACTION=0.8f

static final int MAX_SUBSUMPTION_LENGTH=MAX_INDEL2

public static boolean PRESCAN_QSCORE=true && USE_EXTENDED_SCORE

public static final boolean FILTER_BY_QSCORE=true

public static final float MIN_SCORE_MULT=(USE_AFFINE_SCORE ? 0.03f : USE_EXTENDED_SCORE ? .3f : 0.10f)

public static final float MIN_QSCORE_MULT=0.03f

public static final float MIN_QSCORE_MULT2=0.03f

static final float DYNAMIC_SCORE_THRESH=(USE_AFFINE_SCORE ? 0.55f : USE_EXTENDED_SCORE ? .74f : 0.6f)

*Always retain sites with at least this fraction of max hits (to pass on to qscore)
public static float SKIM_LEVEL_H=0.098f

*Always retain sites with at least this fraction of best hits
public static final float DYNAMIC_SKIM_LEVEL_H=0.48f

*Always retain sites with at least this fraction of max qscore (to pass on to extend)
public static float SKIM_LEVEL_Q=0.098f

*Always retain sites with at least this fraction of best qscore
public static final float DYNAMIC_SKIM_LEVEL_Q=0.78f

*Always retain sites with at least this fraction of max score (to output)
public static float SKIM_LEVEL=0.105f

*Always retain sites with at least this fraction of best score
public static final float DYNAMIC_SKIM_LEVEL=0.78f


#Methods
public BBIndexPacBioSkimmer(int k_, int minChrom_, int maxChrom_, int kfilter_, MSA msa_)

*Remove least useful keys to accelerate search
public final int trimExcessHitListsByGreedy(int[] offsets, int[] keyScores, int maxHitLists, int[] keys)

*Search blocks rapidly to find max hits, and perfect sites. May indicate some blocks can be skipped.
private final int[][] prescanAllBlocks(int[] bestScores, int[] keysP, int[] keyScoresP, int[] offsetsP, int[] keysM, int[] keyScoresM, int[] offsetsM, boolean allBasesCovered)

*Search a single block and strand
public final ArrayList<SiteScore> find(int[] keys, byte[] bases, byte[] baseScores, int[] keyScores, int chrom, byte strand, int[] offsets, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

*Compress arrays by removing null/empty lists
private final int[][] shrink(int[] starts, int[] stops, int[] offsets, int[] keyScores, int len)

*Removes "-1" keys.
private final int[][] shrink2(int[] offsets, int[] keys, int[] keyScores)

*This uses a heap to track next column to increment
private final ArrayList<SiteScore> slowWalk3(int[] starts, int[] stops, byte[] bases, byte[] baseScores, int[] keyScores, int[] offsets, int baseChrom_, byte strand, boolean obeyLimits, ArrayList<SiteScore> ssl, int[] bestScores, boolean allBasesCovered, int maxScore, boolean fullyDefined)

private final int[] findMaxQscore2(int[] starts, int[] stops, int[] offsets, int[] keyScores, int baseChrom_, Quad[] triples, int[] values, int prevMaxHits, boolean earlyExit, boolean perfectOnly)

private static final int absdif(int a, int b)

@Override final int maxScore(int[] offsets, byte[] baseScores, int[] keyScores, int readlen, boolean useQuality)

public final int maxQuickScore(int[] offsets, int[] keyScores)

private final int quickScore(int[] locs, int[] keyScores, int centerIndex, int offsets, int[] sizes, boolean penalizeIndels, int numApproxHits, int numHits)

*Generates a term that increases score with how far apart the two farthest perfect (+- Y2_INDEL) matches are.
*Assumes that the centerIndex corresponds to the leftmost perfect match.
public static final int scoreY2(int[] locs, int centerIndex, int offsets)

private final int extendScore(byte[] bases, byte[] baseScores, int[] offsets, int[] values, int chrom, int centerIndex, int[] locArray, int numHits, int numApproxHits)

*NOTE! This destroys the locArray, so use a copy if needed.
private static final int[] makeGapArray(int[] locArray, int minLoc, int minGap)

*Generates a term that increases score with how many bases in the read match the ref.
private final int scoreZ2(int[] locs, int centerIndex, int offsets, int numApproxHits, int numHits)

@Deprecated private final int scoreZslow(int[] locs, int centerIndex, int offsets, boolean display)

*Generates a term that increases score with how many bases in the read match the ref.
private final int maxScoreZ(int offsets)

private final int scoreRight(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels, int numHits)

private final int scoreLeft(int[] locs, int[] keyScores, int centerIndex, int[] sizes, boolean penalizeIndels)

*Encode a (location, chrom) pair to an index
private static final int toNumber(int site, int chrom)

*Decode an (index, baseChrom) pair to a chromosome
private static final int numberToChrom(int number, int baseChrom)

*Decode an index to a location
private static final int numberToSite(int number)

public static final int minChrom(int chrom)

public static final int baseChrom(int chrom)

public static final int maxChrom(int chrom)

private final int[] getOffsetArray(int len)

private final int[] getLocArray(int len)

private final int[] getGreedyListArray(int len)

private final int[] getGenericArray(int len)

@Override final byte[] getBaseScoreArray(int len, int strand)

@Override final int[] getKeyScoreArray(int len, int strand)

private final float[] getKeyWeightArray(int len)

@Override float[] keyProbArray()

private static final Quad[] makeQuadStorage(int number)

static void setChromBits(int x)

*Return only sites that match completely or with partial no-reference
public static void setSemiperfectMode()

*Return only sites that match completely
public static void setPerfectMode()

public static final void setFractionToExclude(float f)

private static final int calcQScoreCutoff(int max, int score, int currentCutoff)

private static final int calcScoreCutoff(int max, int score, int currentCutoff)

private static final int calcApproxHitsCutoff(int keys, int hits, int currentCutoff, boolean perfect)

</class BBIndexPacBioSkimmer>
<class BBMap>
*@author Brian Bushnell
*@date Dec 22, 2012
public final class BBMap

#Methods
public BBMap(String[] args)

@Override public void setDefaults()

@Override public String[] preparse(String[] args)

@Override void postparse(String[] args)

@Override public void setup()

@Override void processAmbig2()

@Override void loadIndex()

@Override public void testSpeed(String[] args)

@Override void setSemiperfectMode()

@Override void setPerfectMode()

@Override void printSettings(int k)

</class BBMap>
<class BBMap5>
*Based on TestIndex11f
*@author Brian Bushnell
*@date Jan 3, 2013
public final class BBMap5

#Methods
public static void main(String[] args)

public BBMap5(String[] args)

@Override public void setDefaults()

@Override public String[] preparse(String[] args)

@Override void postparse(String[] args)

@Override public void setup()

@Override void processAmbig2()

@Override void loadIndex()

@Override public void testSpeed(String[] args)

@Override void setSemiperfectMode()

@Override void setPerfectMode()

@Override void printSettings(int k)

</class BBMap5>
<class BBMapAcc>
*Based on TestIndex11Ii
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapAcc

#Methods
public BBMapAcc(String[] args)

</class BBMapAcc>
<class BBMapPacBio>
*Based on TestIndex11f
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapPacBio

#Methods
public BBMapPacBio(String[] args)

@Override public void setDefaults()

@Override public String[] preparse(String[] args)

@Override void postparse(String[] args)

@Override public void setup()

@Override void processAmbig2()

@Override void loadIndex()

@Override public void testSpeed(String[] args)

@Override void setSemiperfectMode()

@Override void setPerfectMode()

@Override void printSettings(int k)

</class BBMapPacBio>
<class BBMapPacBioSkimmer>
*Based on TestIndex11f
*Designed to skim and retain all sites above a threshold.
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapPacBioSkimmer

#Methods
public BBMapPacBioSkimmer(String[] args)

@Override public String[] preparse(String[] args)

@Override void postparse(String[] args)

@Override public void setup()

@Override void processAmbig2()

@Override void loadIndex()

@Override public void testSpeed(String[] args)

@Override void setSemiperfectMode()

@Override void setPerfectMode()

@Override void printSettings(int k)

</class BBMapPacBioSkimmer>
<class BBMapThread>
*Based on MapTestThread11f
*@author Brian Bushnell
*@date Dec 22, 2012
public final class BBMapThread

#Fields
static final int ALIGN_COLUMNS=BBIndex.ALIGN_COLUMNS

static final int ALIGN_ROWS=601

*Don't trim for local alignments unless at least this many bases will be clipped
private final int LOCAL_ALIGN_TIP_LENGTH=1

*Range is 0-1; a lower number makes trimming more aggressive
private final float LOCAL_ALIGN_MATCH_POINT_RATIO=1f

*Ratio of the points for a match of a single base needed to declare unambiguous. 1 SNP is currently about 2.57
public final float CLEARZONE_RATIOP=1.6f

public final float CLEARZONE_RATIO1=2.0f

public final float CLEARZONE_RATIO1b=2.6f

public final float CLEARZONE_RATIO1c=4.6f

public final float CLEARZONE_RATIO3=8.0f

*Max allowed number of sites within 1 edit (excluding primary site)
public final int CLEARZONE_LIMIT1e=40

public final int CLEARZONEP

public final int CLEARZONE1

public final int CLEARZONE1b

public final int CLEARZONE1c

public final int CLEARZONE3

public final float INV_CLEARZONE3

public final float CLEARZONE1b_CUTOFF_FLAT_RATIO=12

public final float CLEARZONE1b_CUTOFF_FLAT

public final float CLEARZONE1b_CUTOFF_SCALE=0.97f

public final float CLEARZONE1c_CUTOFF_FLAT_RATIO=26

public final float CLEARZONE1c_CUTOFF_FLAT

public final float CLEARZONE1c_CUTOFF_SCALE=0.92f

public final BBIndex index

private final int MIN_TRIM_SITES_TO_RETAIN_SINGLE=3

private final int MIN_TRIM_SITES_TO_RETAIN_PAIRED=2


#Methods
public static void setExpectedSites(int x)

@Override public final int ALIGN_COLUMNS()

@Override public final int ALIGN_ROWS()

@Override public final int maxReadLength()

@Override final AbstractIndex index()

@Override final int CLEARZONE1()

public BBMapThread(ConcurrentReadInputStream cris_, int keylen_, CoveragePileup pileup_, boolean SMITH_WATERMAN_, int THRESH_, int minChrom_, int maxChrom_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS_, boolean SAVE_AMBIGUOUS_XY_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, boolean TRIM_LIST_, boolean MAKE_MATCH_STRING_, boolean QUICK_MATCH_STRINGS_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, boolean DONT_OUTPUT_UNMAPPED_READS_, boolean DONT_OUTPUT_BLACKLISTED_READS_, int MAX_SITESCORES_TO_PRINT_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean KILL_BAD_PAIRS_, boolean RCOMP_MATE_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, int TIP_DELETION_SEARCH_RANGE_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, int KFILTER_, float IDFILTER_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int TRIM_MIN_LEN_, boolean LOCAL_ALIGN_, boolean RESCUE_, boolean STRICT_MAX_INDEL_, String MSA_TYPE_, BloomFilter bloomFilter_)

@Override public int trimList(ArrayList<SiteScore> list, boolean retainPaired, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain)

@Override public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

@Override public void processRead(Read r, byte[] basesM)

*Returns number of perfect pairs
@Override public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

@Override public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

</class BBMapThread>
<class BBMapThread5>
*Based on MapTestThread11f
*@author Brian Bushnell
*@date Jan 3, 2013
public final class BBMapThread5

#Fields
static final int ALIGN_COLUMNS=BBIndex5.ALIGN_COLUMNS

public final float CLEARZONE1b_CUTOFF=0.92f

public final float CLEARZONE1c_CUTOFF=0.82f

public final BBIndex5 index

private final int MIN_TRIM_SITES_TO_RETAIN_SINGLE=3

private final int MIN_TRIM_SITES_TO_RETAIN_PAIRED=2


#Methods
public static void setExpectedSites(int x)

@Override public final int ALIGN_COLUMNS()

@Override public final int ALIGN_ROWS()

@Override public final int maxReadLength()

@Override final AbstractIndex index()

@Override final int CLEARZONE1()

public BBMapThread5(ConcurrentReadInputStream cris_, int keylen_, CoveragePileup pileup_, boolean SMITH_WATERMAN_, int THRESH_, int minChrom_, int maxChrom_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS_, boolean SAVE_AMBIGUOUS_XY_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, boolean TRIM_LIST_, boolean MAKE_MATCH_STRING_, boolean QUICK_MATCH_STRINGS_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, boolean DONT_OUTPUT_UNMAPPED_READS_, boolean DONT_OUTPUT_BLACKLISTED_READS_, int MAX_SITESCORES_TO_PRINT_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean KILL_BAD_PAIRS_, boolean RCOMP_MATE_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, int TIP_DELETION_SEARCH_RANGE_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, int KFILTER_, float IDFILTER_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int TRIM_MIN_LEN_, boolean LOCAL_ALIGN_, boolean RESCUE_, boolean STRICT_MAX_INDEL_, String MSA_TYPE_, BloomFilter bloomFilter_)

@Override public int trimList(ArrayList<SiteScore> list, boolean retainPaired, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain)

@Override public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

@Override public void processRead(Read r, byte[] basesM)

*Returns number of perfect pairs
@Override public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

@Override public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

</class BBMapThread5>
<class BBMapThreadAcc>
*Based on MapTestThread11i
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapThreadAcc

#Fields
static final int ALIGN_COLUMNS=BBIndexAcc.ALIGN_COLUMNS

public final float CLEARZONE_RATIO1c=4.8f

public final float CLEARZONE_RATIO3=9.5f

*Max allowed number of sites within 1 edit (excluding primary site)
public final int CLEARZONE_LIMIT1e=50

public final BBIndexAcc index


#Methods
public BBMapThreadAcc(ConcurrentReadInputStream cris_, int keylen_, CoveragePileup pileup_, boolean SMITH_WATERMAN_, int THRESH_, int minChrom_, int maxChrom_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS_, boolean SAVE_AMBIGUOUS_XY_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, boolean TRIM_LIST_, boolean MAKE_MATCH_STRING_, boolean QUICK_MATCH_STRINGS_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, boolean DONT_OUTPUT_UNMAPPED_READS_, boolean DONT_OUTPUT_BLACKLISTED_READS_, int MAX_SITESCORES_TO_PRINT_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean KILL_BAD_PAIRS_, boolean RCOMP_MATE_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, int TIP_DELETION_SEARCH_RANGE_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, int KFILTER_, float IDFILTER_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int TRIM_MIN_LEN_, boolean LOCAL_ALIGN_, boolean RESCUE_, boolean STRICT_MAX_INDEL_, String MSA_TYPE_, BloomFilter bloomFilter_)

@Override public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

@Override public void processRead(Read r, byte[] basesM)

*Returns number of perfect pairs
@Override public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

@Override public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

</class BBMapThreadAcc>
<class BBMapThreadPacBio>
*Based on MapTestThread11f
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapThreadPacBio

#Fields
static final int ALIGN_COLUMNS=BBIndexPacBio.ALIGN_COLUMNS

static final int ALIGN_ROWS=6020

*Range is 0-1; a lower number makes trimming more aggressive
private final float LOCAL_ALIGN_MATCH_POINT_RATIO=0.75f

*Ratio of the points for a match of a single base needed to declare unambiguous
public final float CLEARZONE_RATIOP=1.5f

public final float CLEARZONE_RATIO1=2.2f

public final float CLEARZONE_RATIO1b=2.8f

public final float CLEARZONE_RATIO3=8f

*Max allowed number of sites within 1 edit (excluding primary site)
public final int CLEARZONE_LIMIT1e=4

public final int CLEARZONEP

public final int CLEARZONE1

public final int CLEARZONE1b

public final int CLEARZONE1c

public final int CLEARZONE3

public final float INV_CLEARZONE3

public final float CLEARZONE1b_CUTOFF=0.92f

public final float CLEARZONE1c_CUTOFF=0.82f

public final BBIndexPacBio index

private final int MIN_TRIM_SITES_TO_RETAIN_SINGLE=3

private final int MIN_TRIM_SITES_TO_RETAIN_PAIRED=2


#Methods
public static void setExpectedSites(int x)

@Override public final int ALIGN_COLUMNS()

@Override public final int ALIGN_ROWS()

@Override public final int maxReadLength()

@Override final AbstractIndex index()

@Override final int CLEARZONE1()

public BBMapThreadPacBio(ConcurrentReadInputStream cris_, int keylen_, CoveragePileup pileup_, boolean SMITH_WATERMAN_, int THRESH_, int minChrom_, int maxChrom_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS_, boolean SAVE_AMBIGUOUS_XY_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, boolean TRIM_LIST_, boolean MAKE_MATCH_STRING_, boolean QUICK_MATCH_STRINGS_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, boolean DONT_OUTPUT_UNMAPPED_READS_, boolean DONT_OUTPUT_BLACKLISTED_READS_, int MAX_SITESCORES_TO_PRINT_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean KILL_BAD_PAIRS_, boolean RCOMP_MATE_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, int TIP_DELETION_SEARCH_RANGE_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, int KFILTER_, float IDFILTER_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int TRIM_MIN_LEN_, boolean LOCAL_ALIGN_, boolean RESCUE_, boolean STRICT_MAX_INDEL_, String MSA_TYPE_, BloomFilter bloomFilter_)

@Override public int trimList(ArrayList<SiteScore> list, boolean retainPaired, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain)

@Override public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

@Override public void processRead(Read r, byte[] basesM)

*Returns number of perfect pairs
@Override public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

@Override public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

</class BBMapThreadPacBio>
<class BBMapThreadPacBioSkimmer>
*Based on MapTestThread11f
*Designed to skim and retain all sites above a threshold.
*@author Brian Bushnell
*@date Jul 10, 2012
public final class BBMapThreadPacBioSkimmer

#Fields
static final int ALIGN_COLUMNS=BBIndexPacBioSkimmer.ALIGN_COLUMNS

static final int ALIGN_ROWS=4020

*Don't trim for local alignments unless at least this many bases will be clipped
private final int LOCAL_ALIGN_TIP_LENGTH=1

*Range is 0-1; a lower number makes trimming more aggressive
private final float LOCAL_ALIGN_MATCH_POINT_RATIO=0.75f

*Ratio of the points for a match of a single base needed to declare unambiguous
public final float CLEARZONE_RATIOP=1.5f

public final float CLEARZONE_RATIO1=2.2f

public final float CLEARZONE_RATIO1b=2.8f

public final float CLEARZONE_RATIO1c=4.8f

public final float CLEARZONE_RATIO3=8f

*Max allowed number of sites within 1 edit (excluding primary site)
public final int CLEARZONE_LIMIT1e=4

public final int CLEARZONEP

public final int CLEARZONE1

public final int CLEARZONE1b

public final int CLEARZONE1c

public final int CLEARZONE3

public final float INV_CLEARZONE3

public final float CLEARZONE1b_CUTOFF=0.92f

public final float CLEARZONE1c_CUTOFF=0.82f

public final BBIndexPacBioSkimmer index

private static int MIN_TRIM_SITES_TO_RETAIN_SINGLE=2

private static int MIN_TRIM_SITES_TO_RETAIN_PAIRED=1

*TODO - perhaps I can rewrite cz3 to penalize reads that map similarly to more than the expected number of places
public static final boolean USE_CLEARZONE3=false

private static int EXPECTED_SITES=1


#Methods
public static void setExpectedSites(int x)

@Override public final int ALIGN_COLUMNS()

@Override public final int ALIGN_ROWS()

@Override public final int maxReadLength()

@Override final AbstractIndex index()

@Override final int CLEARZONE1()

public BBMapThreadPacBioSkimmer(ConcurrentReadInputStream cris_, int keylen_, CoveragePileup pileup_, boolean SMITH_WATERMAN_, int THRESH_, int minChrom_, int maxChrom_, float keyDensity_, float maxKeyDensity_, float minKeyDensity_, int maxDesiredKeys_, boolean REMOVE_DUPLICATE_BEST_ALIGNMENTS_, boolean SAVE_AMBIGUOUS_XY_, float MINIMUM_ALIGNMENT_SCORE_RATIO_, boolean TRIM_LIST_, boolean MAKE_MATCH_STRING_, boolean QUICK_MATCH_STRINGS_, ConcurrentReadOutputStream outStream_, ConcurrentReadOutputStream outStreamMapped_, ConcurrentReadOutputStream outStreamUnmapped_, ConcurrentReadOutputStream outStreamBlack_, int SLOW_ALIGN_PADDING_, int SLOW_RESCUE_PADDING_, boolean DONT_OUTPUT_UNMAPPED_READS_, boolean DONT_OUTPUT_BLACKLISTED_READS_, int MAX_SITESCORES_TO_PRINT_, boolean PRINT_SECONDARY_ALIGNMENTS_, boolean REQUIRE_CORRECT_STRANDS_PAIRS_, boolean SAME_STRAND_PAIRS_, boolean KILL_BAD_PAIRS_, boolean RCOMP_MATE_, boolean PERFECTMODE_, boolean SEMIPERFECTMODE_, boolean FORBID_SELF_MAPPING_, int TIP_DELETION_SEARCH_RANGE_, boolean AMBIGUOUS_RANDOM_, boolean AMBIGUOUS_ALL_, int KFILTER_, float IDFILTER_, boolean TRIM_LEFT_, boolean TRIM_RIGHT_, boolean UNTRIM_, float TRIM_QUAL_, int TRIM_MIN_LEN_, boolean LOCAL_ALIGN_, boolean RESCUE_, boolean STRICT_MAX_INDEL_, String MSA_TYPE_, BloomFilter bloomFilter_)

@Override public int trimList(ArrayList<SiteScore> list, boolean retainPaired, int maxScore, boolean specialCasePerfect, int minSitesToRetain, int maxSitesToRetain)

@Override public void scoreSlow(ArrayList<SiteScore> list, byte[] basesP, byte[] basesM, int maxSwScore, int maxImperfectSwScore)

*{group of correct hit (or -1), size of correct group, number of groups,
*number of elements, correctScore, maxScore, size of top group, num correct, firstElementCorrect,
*firstElementCorrectLoose, firstGroupCorrectLoose}
@Override public void calcStatistics1(Read r, int maxSwScore, int maxPossibleQuickScore)

@Override public void calcStatistics2(Read r, int maxSwScore, int maxPossibleQuickScore)

@Override public void processRead(Read r, byte[] basesM)

*Returns number of perfect pairs
@Override public int pairSiteScoresInitial(Read r, Read r2, boolean trim)

@Override public void processReadPair(Read r, byte[] basesM1, byte[] basesM2)

*{number of correct (loose) sites, number of incorrect (loose) sites, number incorrect sites before last correct site,
*number of sites, correctScore, maxScore, firstElementCorrect, firstElementCorrectLoose, position of first correct element (or -1),
*sizeOfTopGroup, numTopCorrect}
protected static int[] calcCorrectnessSkimmer(Read r, int thresh)

</class BBMapThreadPacBioSkimmer>
<class BBSplitter>
*@author Brian Bushnell
*@date Mar 19, 2013
public class BBSplitter

#Fields
public static LinkedHashMap<String,SetCount> setCountTable=null

public static LinkedHashMap<String,SetCount> scafCountTable=null

*Holds named output streams.
public static HashMap<String,ConcurrentReadOutputStream> streamTable=null

*Holds named output streams for ambiguous (across different references) reads.
public static HashMap<String,ConcurrentReadOutputStream> streamTableAmbiguous=null

public static final int AMBIGUOUS2_UNSET=0

public static final int AMBIGUOUS2_FIRST=1

public static final int AMBIGUOUS2_SPLIT=2

public static final int AMBIGUOUS2_TOSS=3

public static final int AMBIGUOUS2_RANDOM=4

public static final int AMBIGUOUS2_ALL=5

public static int AMBIGUOUS2_MODE=AMBIGUOUS2_UNSET

public static boolean TRACK_SET_STATS=false

public static boolean TRACK_SCAF_STATS=false

public static String SCAF_STATS_FILE=null

public static String SET_STATS_FILE=null

public static boolean overwrite=true

public static boolean append=false

public static boolean verbose=false

public static boolean forceRebuild=false

private static final ArrayList<Read> blank=new ArrayList<Read>(0)

public static final int MAP_NORMAL=1

public static final int MAP_ACC=2

public static final int MAP_PACBIO=3

public static final int MAP_PACBIOSKIMMER=4

public static int MAP_MODE=MAP_NORMAL


#Methods
public static void main(String[] args)

public static String[] processArgs(String[] args)

public static String[] remakeArgs(String[] args)

private static void processRef(String b, LinkedHashSet<String> set, HashMap<String,LinkedHashSet<String>> map)

public static ArrayList<String> gatherLists(LinkedHashSet<String> nameSet, String basename)

public static String mergeReferences(LinkedHashSet<String> nameSet, HashMap<String,LinkedHashSet<String>> nameToFileTable, int build)

*Returns the set of scaffold name prefixes or suffixes.
*@param getPrefixes True to return prefixes (set names), false to return suffixes (scaffold names)
*@return A set of affixes
public static HashSet<String> getScaffoldAffixes(boolean getPrefixes)

public static HashMap<String,ConcurrentReadOutputStream> makeOutputStreams(String[] args, boolean OUTPUT_READS, boolean OUTPUT_ORDERED_READS, int buff, boolean paired, boolean overwrite_, boolean append_, boolean ambiguous)

public static LinkedHashMap<String,SetCount> makeSetCountTable()

public static LinkedHashMap<String,SetCount> makeScafCountTable()

*@param readlist List of reads to print
*@param listID ID of read list, from ReadInputStream
*@param splitTable A temporary structure to hold sets of reads that go to the different output streams
*@param clearzone Min distance between best and next-best site to be considered unambiguous
public static void printReads(ArrayList<Read> readlist, long listID, HashMap<String,ArrayList<Read>> splitTable, int clearzone)

*@param readlist List of reads to print
*@param listID ID of read list, from ReadInputStream
*@param splitTable A temporary structure to hold sets of reads that go to the different output streams
*@param clearzone Min distance between best and next-best site to be considered unambiguous
public static void printReadsAndProcessAmbiguous(ArrayList<Read> readlist, long listID, HashMap<String,ArrayList<Read>> splitTable, HashMap<String,ArrayList<Read>> splitTableA, int clearzone)

private static void addToScafCounts(Read r, int clearzone, HashSet<String> hss0)

public static HashSet<String>[] getSets(Read r1, int clearzone, HashSet<String>[] sets)

public static HashSet<String> getScaffolds(Read r1, int clearzone, HashSet<String> set, boolean includeMate)

*@param r
*@return A set of names of reference lists containing this read or its mate.
public static HashSet<String> toListNames(Read r, HashSet<String> set)

*@param r
*@return A mapping of reference names to read clones.
public static HashMap<String,Read> toNameMap(Read r, HashMap<String,Read> map)

private static Read cloneRead(Read r, String ref)

*@param r
*@return A set of names of reference lists containing this site.
public static HashSet<String> toListNames(SiteScore r, HashSet<String> set)

private static void addNames(LinkedHashSet<String> fnames, HashMap<String,LinkedHashSet<String>> table, String setName)

public static void makeBamScript(String outname, ArrayList<String> list, String sams)

public static void printCounts(String fname, LinkedHashMap<String,SetCount> map, boolean header, long totalReads, boolean nzo, boolean sort)

static final void clearStatics()

</class BBSplitter>
<class BBSplitter.SetCount>
public static class BBSplitter.SetCount

#Fields
public final String name

public long mappedReads

public long ambiguousReads

public long assignedReads

public long mappedBases

public long ambiguousBases

public long assignedBases


#Methods
public SetCount(String s)

@Override public boolean equals(Object other)

public boolean equals(SetCount other)

@Override public int hashCode()

@Override public int compareTo(SetCount o)

@Override public String toString()

</class BBSplitter.SetCount>
<class BBWrap>
*@author Brian Bushnell
*@date Mar 27, 2014
public class BBWrap

#Fields
private String ref

private String mapper="bbmap"

private ArrayList<String> bsList=new ArrayList<String>()

private ArrayList<String> qhistList=new ArrayList<String>()

private ArrayList<String> mhistList=new ArrayList<String>()

private ArrayList<String> ihistList=new ArrayList<String>()

private ArrayList<String> in1List=new ArrayList<String>()

private ArrayList<String> out1List=new ArrayList<String>()

private ArrayList<String> outu1List=new ArrayList<String>()

private ArrayList<String> outm1List=new ArrayList<String>()

private ArrayList<String> outb1List=new ArrayList<String>()

private ArrayList<String> in2List=new ArrayList<String>()

private ArrayList<String> out2List=new ArrayList<String>()

private ArrayList<String> outu2List=new ArrayList<String>()

private ArrayList<String> outm2List=new ArrayList<String>()

private ArrayList<String> outb2List=new ArrayList<String>()

private boolean append=false

static PrintStream outstream=System.err


#Methods
public static void main(String[] args)

private final ArrayList<String> parse(String[] args)

private static void add(String s, ArrayList<String> list)

private static void addFileContents(String s, ArrayList<String> list)

private void execute(ArrayList<String> base)

private void addToList(ArrayList<String> list, ArrayList<String> source, String key, int i)

</class BBWrap>
<class Blacklist>
*@author Brian Bushnell
*@date Mar 14, 2013
public class Blacklist

#Fields
private static HashSet<String> blacklist=null

private static HashSet<String> whitelist=null


#Methods
public static boolean inWhitelist(Read r)

private static boolean inWhitelist2(Read r)

public static boolean inBlacklist(Read r)

private static boolean inBlacklist2(Read r)

public static void addToBlacklist(String fname)

public static void addToWhitelist(String fname)

public static int addToSet(String fname, boolean black)

public static boolean hasBlacklist()

public static boolean hasWhitelist()

public static void clearBlacklist()

public static void clearWhitelist()

</class Blacklist>
<class Block>
*@author Brian Bushnell
*@date Dec 23, 2012
public class Block

#Fields
private static final long serialVersionUID=-1638122096023589384L

public final int numSites

public final int numStarts

public final int[] sites

public final int[] starts

private static boolean allowSubprocess=false

private static final boolean compress=true

private static final boolean copyOnWrite=false


#Methods
public Block(int numSites_, int numStarts_)

public Block(int[] sites_, int[] starts_)

*For legacy support
public int[] getHitList(int key)

*For legacy support
public int[] getHitList(int start, int stop)

*For legacy support
public int[][] getHitLists(int[] start, int[] stop)

public int length(int key)

public int length(int start, int stop)

public boolean write(String fname, boolean overwrite)

private static void compress(int[] x)

private static void decompress(int[] x)

public static Block read(String fname)

</class Block>
<class ChromLoadThread>
*@author Brian Bushnell
*@date Dec 31, 2012
public class ChromLoadThread

#Fields
private final int id

private final String fname

private final ChromosomeArray[] array

public static final int[] lock=new int[1]

public static int MAX_CONCURRENT=Shared.threads()


#Methods
public static void main(String[] args)

public ChromLoadThread(String fname_, int id_, ChromosomeArray[] r_)

public static ChromLoadThread load(String fname, int id, ChromosomeArray[] r)

public static ChromosomeArray[] loadAll(String pattern, int min, int max, ChromosomeArray[] r)

@Override public void run()

private static final int increment(int i)

</class ChromLoadThread>
<class CompareSamFiles>
*Generate a file containing reads mapped correctly in one file and incorrectly in another file.
public class CompareSamFiles

#Fields
public static int truePositiveStrict=0

public static int falsePositiveStrict=0

public static int truePositiveLoose=0

public static int falsePositiveLoose=0

public static int mapped=0

public static int mappedRetained=0

public static int unmapped=0

public static int discarded=0

public static int ambiguous=0

public static long lines=0

public static long primary=0

public static long secondary=0

public static int minQuality=3

public static boolean parsecustom=true

public static boolean printerr=false

public static int THRESH2=20

public static boolean BLASR=false


#Methods
public static void main(String[] args)

public static void calcStatistics1(Read r, SamLine sl)

public static int type(Read r, SamLine sl)

public static boolean isCorrectHit(SiteScore ss, int trueChrom, byte trueStrand, int trueStart, int trueStop, int thresh, byte[] originalContig, byte[] contig, int cstart)

public static boolean isCorrectHitLoose(SiteScore ss, int trueChrom, byte trueStrand, int trueStart, int trueStop, int thresh, byte[] originalContig, byte[] contig, int cstart)

private static final int absdif(int a, int b)

</class CompareSamFiles>
<class CompressString>
public class CompressString

#Methods
public static void main(String[] args)

public static String compress(String s)

public static String compressRepeats(byte[] array, int period)

public static String compressRepeatsMultiperiod(byte[] array, int minPeriod, int maxPeriod, IntList list)

public static String compressRepeatsUltra(byte[] array, int minPeriod, int maxPeriod, IntList list)

public static int countRepeats(byte[] array, int base, int period)

</class CompressString>
<class GapTools>
public class GapTools

#Fields
public static boolean verbose=false


#Methods
public static int[] fixGaps(SiteScore ss)

public static String toString(int[] gaps)

public static int[] fixGaps(int a, int b, int[] gaps, int minGap)

*This may have some off-by-one errors...
public static final int calcGrefLen(SiteScore ss)

*This may have some off-by-one errors...
public static final int calcGrefLen(int a, int b, int[] gaps)

*TODO: Verify.
public static final int calcBufferNeeded(int a, int b, int[] gaps)

*TODO: Verify.
public static int calcGapLen(int a, int b)

public static int calcNumGapSymbols(int a, int b)

public static final int[] fixGaps2(int a, int b, int[] gaps, int minGap)

public static final ArrayList<Range> toList(int[] gaps)

</class GapTools>
<class GapTools.Range>
public static class GapTools.Range

#Fields
public int a

public int b


#Methods
public Range(int a_, int b_)

@Override public int compareTo(Range r)

@Override public String toString()

@Override public boolean equals(Object other)

public boolean equals(Range other)

@Override public int hashCode()

</class GapTools.Range>
<class GradeSamFile>
public class GradeSamFile

#Fields
public static FileFormat ffLoose=null

public static FileFormat ffStrict=null

public static TextStreamWriter tswLoose=null

public static TextStreamWriter tswStrict=null

public static int truePositiveStrict=0

public static int falsePositiveStrict=0

public static int truePositiveLoose=0

public static int falsePositiveLoose=0

public static int mapped=0

public static int mappedRetained=0

public static int unmapped=0

public static int discarded=0

public static int ambiguous=0

public static long lines=0

public static long primary=0

public static long secondary=0

public static int minQuality=3

public static boolean parsecustom=true

public static boolean printerr=false

public static int THRESH2=20

public static boolean BLASR=false

public static boolean USE_BITSET=true

public static BitSet seen=null


#Methods
public static void main(String[] args)

public static void calcStatistics1(Read r, SamLine sl)

public static boolean isCorrectHit(SamLine sl, CustomHeader h)

public static boolean isCorrectHitLoose(SamLine sl, CustomHeader h)

private static final int absdif(int a, int b)

</class GradeSamFile>
<class Index>
*@author Brian Bushnell
*@date Dec 19, 2012
public abstract class Index
</class Index>
<class IndexMaker4>
*@author Brian Bushnell
*@date Dec 23, 2012
public class IndexMaker4

#Fields
public static boolean verbose=false

public static boolean USE_ALLOC_SYNC=false

static final String ALLOC_SYNC=new String("ALLOC_SYNC")

private static final String THREAD_SYNC=new String("THREAD_SYNC")

public static int MAX_CONCURRENT_BLOCKS=(Shared.LOW_MEMORY ? 1 : (Shared.WINDOWS ? 1 : Tools.max(1,Shared.threads() / 4)))

private static int ACTIVE_BLOCKS=0

public static boolean ALLOW_POLYMERS=false

public static boolean USE_MODULO=false

static final int MODULO=9


#Methods
public static Block[] makeIndex(int genome, int minChrom, int maxChrom, int k, int CHROMBITS, int MAX_ALLOWED_CHROM_INDEX, int CHROM_MASK_LOW, int CHROM_MASK_HIGH, int SITE_MASK, int SHIFT_LENGTH, boolean WRITE, boolean DISK_INVALID, Block[] index)

public static Block makeBlock(int minChrom, int maxChrom, int k, int CHROMBITS, int MAX_ALLOWED_CHROM_INDEX, int CHROM_MASK_LOW, int CHROM_MASK_HIGH, int SITE_MASK, int SHIFT_LENGTH, boolean WRITE, boolean DISK_INVALID, Block[] matrix)

public static final int minChrom(int chrom, int MINCHROM, int CHROM_MASK_HIGH)

public static final int maxChrom(int chrom, int MINCHROM, int MAXCHROM, int CHROM_MASK_LOW)

public static final String fname(int minChrom, int maxChrom, int k, int chrombits)

public static final String fname(int minChrom, int maxChrom, int k, int chrombits, int build)

static void incrementActiveBlocks(int i)

</class IndexMaker4>
<class IndexMaker5>
*@author Brian Bushnell
*@date Jan 3, 2013
public class IndexMaker5

#Fields
public static boolean verbose=false

public static boolean USE_ALLOC_SYNC=false

static final String ALLOC_SYNC=new String("ALLOC_SYNC")

private static final String THREAD_SYNC=new String("THREAD_SYNC")

public static int MAX_CONCURRENT_BLOCKS=(Shared.WINDOWS ? 1 : 2)

private static int ACTIVE_BLOCKS=0

public static boolean ALLOW_POLYMERS=false

public static boolean USE_MODULO=false

private static final int MODULO=IndexMaker4.MODULO


#Methods
public static Block[] makeIndex(int genome, int minChrom, int maxChrom, int k, int CHROMBITS, int MAX_ALLOWED_CHROM_INDEX, int CHROM_MASK_LOW, int CHROM_MASK_HIGH, int SITE_MASK, int SHIFT_LENGTH, boolean WRITE, boolean DISK_INVALID, Block[] index)

public static final int minChrom(int chrom, int MINCHROM, int CHROM_MASK_HIGH)

public static final int maxChrom(int chrom, int MINCHROM, int MAXCHROM, int CHROM_MASK_LOW)

public static final String fname(int minChrom, int maxChrom, int k, int chrombits)

static void incrementActiveBlocks(int i)

</class IndexMaker5>
<class KeyRing>
public final class KeyRing

#Fields
public static boolean KEEP_BAD_KEYS=false


#Methods
public static final void main(String[] args)

public static int[] makeKeys(byte[] s, int[] offsets, int chunksize)

public static int[] reverseComplementKeys(int[] keys, int k)

public static int reverseComplementKey(int key, int k)

public static final String decode(int key, int chunksize)

*This is only useful for low-quality reads, with no-calls. Otherwise it just wastes time...
public static final int[] reverseOffsets(int[] offsetsP, int k, int readlen)

public static final int[] makeOffsetsWithDensity(int readlen, int blocksize, float density, int minKeysDesired)

public static final int[] makeOffsetsWithNumberOfKeys(int readlen, int blocksize, int maxKeys)

public static final int desiredKeysFromDensity(int readlen, int blocksize, float density, int minKeysDesired)

public static final int[] makeOffsets(int readlen, int blocksize, float density, int minKeysDesired)

public static final int[] makeOffsets(byte[] qual, int blocksize, float density, int minKeysDesired)

public static final int[] makeOffsets2(float[] keyErrorProb, int readlenOriginal, int blocksize, float density, float maxDensity, int minKeysDesired)

public static final int[] makeOffsets3(float[] keyErrorProb, int readlenOriginal, int blocksize, float density, float maxDensity, int minKeysDesired, boolean semiperfectmode)

</class KeyRing>
<class MakeQualityHistogram>
public class MakeQualityHistogram

#Methods
public static void main(String[] args)

public static void printMappedHistogram(int[][] mapped)

public static void printPairedHistogram(int[][] paired)

public static int[][][] process(ConcurrentLegacyReadInputStream cris)

private static void processList(ArrayList<Read> list, int[][] mapped, int[][] paired)

private static void processRead(Read r, int[][] mapped, int[][] paired)

</class MakeQualityHistogram>
<class MakeRocCurve>
public class MakeRocCurve

#Fields
public static int truePositiveStrictA=new int[1000]

public static int falsePositiveStrictA=new int[1000]

public static int truePositiveLooseA=new int[1000]

public static int falsePositiveLooseA=new int[1000]

public static int mappedA=new int[1000]

public static int mappedRetainedA=new int[1000]

public static int unmappedA=new int[1000]

public static int discardedA=new int[1000]

public static int ambiguousA=new int[1000]

public static int primaryA=new int[1000]

public static boolean parsecustom=true

public static int THRESH2=20

public static boolean BLASR=false

public static boolean USE_BITSET=true

public static BitSet seen=null

public static boolean allowSpaceslash=true


#Methods
public static void main(String[] args)

public static void process(String samfile)

public static String header()

public static void gradeList(long reads)

public static void calcStatistics1(Read r, SamLine sl)

public static boolean isCorrectHit(SamLine sl, CustomHeader h)

public static boolean isCorrectHitLoose(SamLine sl, CustomHeader h)

private static final int absdif(int a, int b)

</class MakeRocCurve>
<class MSA>
*@author Brian Bushnell
*@date Jun 20, 2013
public abstract class MSA

#Fields
static final int GAPBUFFER=Shared.GAPBUFFER

static final int GAPBUFFER2=Shared.GAPBUFFER2

static final int GAPLEN=Shared.GAPLEN

static final int MINGAP=Shared.MINGAP

static final int GAPCOST=Shared.GAPCOST

static final byte GAPC=Shared.GAPC

*Seemingly to clear out prior data from the gref. Not sure what else it's used for.
static final int GREFLIMIT2_CUSHION=128

static final byte MODE_MS=0

static final byte MODE_DEL=1

static final byte MODE_INS=2

static final byte MODE_SUB=3

public final int maxRows

public final int maxColumns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false

public static int bandwidth=0

public static float bandwidthRatio=0

public static boolean flatMode=false

public static final int MIN_SCORE_ADJUST=120


#Methods
public static final MSA makeMSA(int maxRows_, int maxColumns_, String classname)

public MSA(int maxRows_, int maxColumns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

@Deprecated public int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

*Generates the match string
public byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

*Generates the match string
public byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
public int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

*@return {score, bestRefStart, bestRefStop}, or {score, bestRefStart, bestRefStop, padLeft, padRight} if more padding is needed
public int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

public final int[] fillAndScoreLimited(byte[] read, SiteScore ss, int thresh, int minScore)

public final int[] fillAndScoreLimited(byte[] read, int chrom, int start, int stop, int thresh, int minScore, int[] gaps)

@Deprecated public final int[] fillAndScoreQ(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, byte[] baseScores)

@Deprecated public final int[] fillAndScoreQ(byte[] read, SiteScore ss, int thresh, byte[] baseScores)

@Deprecated public final int[] fillAndScoreQ(byte[] read, int chrom, int start, int stop, int thresh, byte[] baseScores)

public final int scoreNoIndels(byte[] read, SiteScore ss)

public final int scoreNoIndels(byte[] read, int chrom, int refStart)

public final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

*Calculates score based on an array from Index.
public int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases)

*Calculates score based on an array from Index using a kfilter. Slightly slower.
public int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

public int scoreNoIndels(byte[] read, byte[] ref, int refStart)

public int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

public int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

public int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

*Assumes match string is in long format
public final boolean toLocalAlignment(Read r, SiteScore ss, byte[] basesM, int minToClip, float matchPointsMult)

*Works in short or long format.
public final int score(byte[] match)

public int maxQuality(int numBases)

public int maxQuality(byte[] baseScores)

public int maxImperfectScore(int numBases)

public int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

static void printMatrix(int[][][] packed, int readlen, int reflen, int TIMEMASK, int SCOREOFFSET)

static void printMatrix(int[][][] packed, int readlen, int reflen, int TIMEMASK, int SCOREOFFSET, int mode)

public static final String toTimePacked(int[] a, int TIMEMASK, int lim)

public static final String toScorePacked(int[] a, int SCOREOFFSET, int lim)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

public final int calcMatchScore(int len)

public final int calcSubScore(int len)

public final int calcNorefScore(int len)

public final int calcNocallScore(int len)

public int calcDelScore(int len, boolean approximateGaps)

public int calcInsScore(int len)

public static final float minIdToMinRatio(double minid, String classname)

*DO NOT MODIFY
public byte[] getGrefbuffer()

public CharSequence showVertLimit()

public CharSequence showHorizLimit()

public int SCOREOFFSET()

public int POINTS_NOREF()

public int POINTS_NOCALL()

public int POINTS_MATCH()

public int POINTS_MATCH2()

public int POINTS_COMPATIBLE()

public int POINTS_SUB()

public int POINTS_SUBR()

public int POINTS_SUB2()

public int POINTS_SUB3()

public int POINTS_MATCHSUB()

public int POINTS_INS()

public int POINTS_INS2()

public int POINTS_INS3()

public int POINTS_INS4()

public int POINTS_DEL()

public int POINTS_DEL2()

public int POINTS_DEL3()

public int POINTS_DEL4()

public int POINTS_DEL5()

public int POINTS_DEL_REF_N()

public int POINTS_GAP()

public int TIMESLIP()

public int MASK5()

int BARRIER_I1()

int BARRIER_D1()

public int LIMIT_FOR_COST_3()

public int LIMIT_FOR_COST_4()

public int LIMIT_FOR_COST_5()

public int BAD()

</class MSA>
<class MultiStateAligner10ts>
*"P" for "Packed".
*Same as MSA2P, but the "prevState" field was removed.
*Yields identical results to MSA2, but is faster.
*For very long reads (over 2000bp) the score may overflow, so MSA2 should be used instead,
*or the time field should be shrunk.
public final class MultiStateAligner10ts

#Fields
private final int[][][] packed

*Banded packed matrix
private final int[][][] bpacked

*Start locations of banded matrix
private final int[][][] startmatrix

*Score for column zero
private final int[] col0score

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=11

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=70

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-127

public static final int POINTS_SUBR=-147

public static final int POINTS_SUB2=-51

public static final int POINTS_SUB3=-25

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-395

public static final int POINTS_INS2=-39

public static final int POINTS_INS3=-23

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-472

public static final int POINTS_DEL2=-33

public static final int POINTS_DEL3=-9

public static final int POINTS_DEL4=-1

public static final int POINTS_DEL5=-1

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=2

private static final int BARRIER_D1=3

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=20

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns


#Methods
public MultiStateAligner10ts(int maxRows_, int maxColumns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Like fillLimitedX but additionally restricted to a band.
*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillBanded1(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max, maxStart};
*Will not fill areas that cannot match minScore
private final int[] fillBanded(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

*Generates the match string
@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

*Generates the match string
@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

*@return {score, bestRefStart, bestRefStop}, or {score, bestRefStart, bestRefStop, padLeft, padRight} if more padding is needed
@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

*DO NOT MODIFY
@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner10ts>
<class MultiStateAligner11ts>
*Modification of MultiStateAligner9ts to replace fixed affine steps with an array
public final class MultiStateAligner11ts

#Fields
private final int[][][] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=11

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=70

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-127

public static final int POINTS_SUBR=-147

public static final int POINTS_SUB2=-51

public static final int POINTS_SUB3=-25

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-395

public static final int POINTS_INS2=-39

public static final int POINTS_INS3=-23

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-472

public static final int POINTS_DEL2=-33

public static final int POINTS_DEL3=-9

public static final int POINTS_DEL4=-1

public static final int POINTS_DEL5=-1

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=2

private static final int BARRIER_D1=3

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=20

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

*TODO: possibly enclose all uses of affine arrays in a branch controlled by this
public static final boolean AFFINE_ARRAYS=true

public static final int[] POINTS_INS_ARRAY

public static final int[] POINTSoff_INS_ARRAY

public static final int[] POINTS_INS_ARRAY_C

public static final int[] POINTSoff_INS_ARRAY_C

public static final int[] POINTS_SUB_ARRAY

public static final int[] POINTSoff_SUB_ARRAY

public static final int[] POINTS_SUB_ARRAY_C

public static final int[] POINTSoff_SUB_ARRAY_C

private int rows

private int columns


#Methods
public MultiStateAligner11ts(int maxRows_, int maxColumns_)

@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*This function fills the entire packed scoring matrices.
*It does not require a min score and does not support banded.
*Uses 3 matrices to optimize score with multiple affine transforms.
*These correspond to 3 states:
*MODE_MS (match/substitution, aka diagonal)
*MODE_DEL (deletion, aka vertical)
*MODE_INS (insertion, aka vertical)
*Each cell is a 32-bit signed int, with score in the upper bits and
*a counter for time spent in the current state in the lower bits.
*@param read Query bases
*@param ref Reference bases, or gapped reference subsequence with gap symbols.
*@param refStartLoc Column 1 starts at this position of the reference (0 for gapped reference).
*@param refEndLoc Align up to this position in the reference.
*@return int[] {rows, maxCol, maxState, maxScore}
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref, byte[] read)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner11ts>
<class MultiStateAligner11tsJNI>
*Modification of MultiStateAligner9ts to replace fixed affine steps with an array
public final class MultiStateAligner11tsJNI

#Fields
private final int[] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=11

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=70

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-127

public static final int POINTS_SUBR=-147

public static final int POINTS_SUB2=-51

public static final int POINTS_SUB3=-25

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-395

public static final int POINTS_INS2=-39

public static final int POINTS_INS3=-23

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-472

public static final int POINTS_DEL2=-33

public static final int POINTS_DEL3=-9

public static final int POINTS_DEL4=-1

public static final int POINTS_DEL5=-1

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=2

private static final int BARRIER_D1=3

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=20

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

public static final boolean AFFINE_ARRAYS=true

public static final int[] POINTS_INS_ARRAY

public static final int[] POINTSoff_INS_ARRAY

public static final int[] POINTS_INS_ARRAY_C

public static final int[] POINTSoff_INS_ARRAY_C

public static final int[] POINTS_SUB_ARRAY

public static final int[] POINTSoff_SUB_ARRAY

public static final int[] POINTS_SUB_ARRAY_C

public static final int[] POINTSoff_SUB_ARRAY_C

private int rows

private int columns


#Methods
private void fillUnlimitedJNI(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] result, long[] iterationsUnlimited, int[] packed, int[] POINTSoff_SUB_ARRAY, int[] POINTSoff_INS_ARRAY, int maxRows, int maxColumns)

private void fillLimitedXJNI(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] result, long[] iterationsLimited, int[] packed, int[] POINTSoff_SUB_ARRAY, int[] POINTSoff_INS_ARRAY, int maxRows, int maxColumns, int bandwidth, float bandwidthRatio, int[] vertLimit, int[] horizLimit, byte[] baseToNumber, int[] POINTSoff_INS_ARRAY_C)

public static void main(String[] args)

public MultiStateAligner11tsJNI(int maxRows_, int maxColumns_)

@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner11tsJNI>
<class MultiStateAligner9Flat>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9Flat

#Fields
private final int[][][] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=9

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=92

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-87

public static final int POINTS_SUBR=-89

public static final int POINTS_SUB2=-75

public static final int POINTS_SUB3=-50

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-100

public static final int POINTS_INS2=-81

public static final int POINTS_INS3=-59

public static final int POINTS_INS4=-45

public static final int POINTS_DEL=-140

public static final int POINTS_DEL2=-73

public static final int POINTS_DEL3=-58

public static final int POINTS_DEL4=-44

public static final int POINTS_DEL5=-30

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=1

private static final int BARRIER_D1=1

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=20

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

*TODO: possibly enclose all uses of affine arrays in a branch controlled by this
public static final boolean AFFINE_ARRAYS=false

public static final int[] POINTS_INS_ARRAY

public static final int[] POINTSoff_INS_ARRAY

public static final int[] POINTS_INS_ARRAY_C

public static final int[] POINTSoff_INS_ARRAY_C

public static final int[] POINTS_SUB_ARRAY

public static final int[] POINTSoff_SUB_ARRAY

public static final int[] POINTS_SUB_ARRAY_C

public static final int[] POINTSoff_SUB_ARRAY_C

private int rows

private int columns


#Methods
public MultiStateAligner9Flat(int maxRows_, int maxColumns_)

@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc, byte[] read)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner9Flat>
<class MultiStateAligner9PacBio>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9PacBio

#Fields
public static final int POINTS_MATCH=90

public static final int POINTS_SUB=-137

public static final int POINTS_SUBR=-157

public static final int POINTS_SUB2=-49

public static final int POINTS_SUB3=-25

public static final int POINTS_INS=-205

public static final int POINTS_INS2=-42

public static final int POINTS_INS3=-23

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-292

public static final int POINTS_DEL2=-37

public static final int POINTS_DEL3=-17

public static final int POINTS_DEL4=-2

public static final int POINTS_DEL5=-1


#Methods
public MultiStateAligner9PacBio(int maxRows_, int maxColumns_)

</class MultiStateAligner9PacBio>
<class MultiStateAligner9ts>
*"P" for "Packed".
*Same as MSA2P, but the "prevState" field was removed.
*Yields identical results to MSA2, but is faster.
*For very long reads (over 2000bp) the score may overflow, so MSA2 should be used instead,
*or the time field should be shrunk.
public final class MultiStateAligner9ts

#Fields
private final int[][][] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=11

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=70

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-127

public static final int POINTS_SUBR=-147

public static final int POINTS_SUB2=-51

public static final int POINTS_SUB3=-25

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-395

public static final int POINTS_INS2=-39

public static final int POINTS_INS3=-23

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-472

public static final int POINTS_DEL2=-33

public static final int POINTS_DEL3=-9

public static final int POINTS_DEL4=-1

public static final int POINTS_DEL5=-1

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=2

private static final int BARRIER_D1=3

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=20

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns


#Methods
public MultiStateAligner9ts(int maxRows_, int maxColumns_)

@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner9ts>
<class MultiStateAligner9XFlat>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9XFlat

#Fields
private final int[][][] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=9

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int POINTS_NOREF=0

public static final int POINTS_NOCALL=0

public static final int POINTS_MATCH=92

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-87

public static final int POINTS_SUBR=-89

public static final int POINTS_INS=-100

public static final int POINTS_INS2=-81

public static final int POINTS_INS3=-59

public static final int POINTS_DEL=-140

public static final int POINTS_DEL2=-73

public static final int POINTS_DEL3=-58

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=1

private static final int BARRIER_D1=1

public static final int LIMIT_FOR_COST_3=5

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

*TODO: possibly enclose all uses of affine arrays in a branch controlled by this
public static final boolean AFFINE_ARRAYS=false

public static final int[] POINTS_INS_ARRAY

public static final int[] POINTSoff_INS_ARRAY

public static final int[] POINTS_INS_ARRAY_C

public static final int[] POINTSoff_INS_ARRAY_C

public static final int[] POINTS_SUB_ARRAY

public static final int[] POINTSoff_SUB_ARRAY

public static final int[] POINTS_SUB_ARRAY_C

public static final int[] POINTSoff_SUB_ARRAY_C

private int rows

private int columns


#Methods
public MultiStateAligner9XFlat(int maxRows_, int maxColumns_)

@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override @Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

@Override public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

@Override public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Fills grefbuffer
*@param ref
*@param a
*@param b
*@param gaps
*@return gref
private final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc, byte[] read)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

*Calculates score based on an array from Index
private final int calcAffineScore(int[] locArray)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte bases)

@Override public final int calcAffineScore(int[] locArray, byte[] baseScores, byte[] bases, int minContig)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

@Override public final byte[] genMatchNoIndels(byte[] read, byte[] ref, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart)

@Override public final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

@Override public final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

@Override public final int maxQuality(int numBases)

@Override public final int maxQuality(byte[] baseScores)

@Override public final int maxImperfectScore(int numBases)

@Override public final int maxImperfectScore(byte[] baseScores)

@Override public int calcDelScore(int len, boolean approximateGaps)

private static int calcDelScoreOffset(int len)

@Override public int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public final byte[] getGrefbuffer()

@Override public CharSequence showVertLimit()

@Override public CharSequence showHorizLimit()

public static float minIdToMinRatio(double minid)

@Override public final int POINTS_NOREF()

@Override public final int POINTS_NOCALL()

@Override public final int POINTS_MATCH()

@Override public final int POINTS_MATCH2()

@Override public final int POINTS_COMPATIBLE()

@Override public final int POINTS_SUB()

@Override public final int POINTS_SUBR()

@Override public final int POINTS_SUB2()

@Override public final int POINTS_SUB3()

@Override public final int POINTS_MATCHSUB()

@Override public final int POINTS_INS()

@Override public final int POINTS_INS2()

@Override public final int POINTS_INS3()

@Override public final int POINTS_INS4()

@Override public final int POINTS_DEL()

@Override public final int POINTS_DEL2()

@Override public final int POINTS_DEL3()

@Override public final int POINTS_DEL4()

@Override public final int POINTS_DEL5()

@Override public final int POINTS_DEL_REF_N()

@Override public final int POINTS_GAP()

@Override public final int TIMESLIP()

@Override public final int MASK5()

@Override public final int SCOREOFFSET()

@Override final int BARRIER_I1()

@Override final int BARRIER_D1()

@Override public final int LIMIT_FOR_COST_3()

@Override public final int LIMIT_FOR_COST_4()

@Override public final int LIMIT_FOR_COST_5()

@Override public final int BAD()

</class MultiStateAligner9XFlat>
<class NeedlemanWunsch>
public class NeedlemanWunsch

#Fields
public final int maxRows

public final int maxColumns

private final int[][] scores

private final byte[][] pointers

public static final byte LEFT=0

public static final byte DIAG=1

public static final byte UP=2

private int rows

private int columns


#Methods
public NeedlemanWunsch(int maxRows_, int maxColumns_)

public void fill(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

public byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

</class NeedlemanWunsch>
<class PackedHeap>
public final class PackedHeap

#Fields
final long[] array

private final int CAPACITY

private int size=0


#Methods
public PackedHeap(int maxSize)

public boolean add(long t)

public long peek()

public long poll()

private void percDown(int loc)

private void percUp(int loc)

private void percUpIter(int loc)

public boolean isEmpty()

public void clear()

public int size()

public static int tier(int x)

public boolean testForDuplicates()

</class PackedHeap>
<class Pointer>
public class Pointer

#Fields
public int key

public int value


#Methods
public static Pointer[] loadMatrix(int[][] matrix)

public static Pointer[] loadMatrix(int[][] matrix, Pointer[] out)

public Pointer(int key_, int value_)

@Override public int compareTo(Pointer o)

</class Pointer>
<class PrintTime>
public class PrintTime

#Methods
public static void main(String[] args)

</class PrintTime>
<class Quad>
public class Quad

#Fields
public final int column

public int row

public int site

public int list


#Methods
public Quad(int col_, int row_, int val_)

@Override public boolean equals(Object other)

@Override public int hashCode()

@Override public int compareTo(Quad other)

@Override public String toString()

</class Quad>
<class Quad64>
public class Quad64

#Fields
public final int column

public int row

public long site

public int list


#Methods
public Quad64(int col_, int row_, int val_)

@Override public int hashCode()

@Override public int compareTo(Quad64 other)

@Override public String toString()

</class Quad64>
<class Quad64Heap>
public final class Quad64Heap

#Fields
private final Quad64[] array

private final int CAPACITY

private int size=0


#Methods
public Quad64Heap(int maxSize)

public boolean add(Quad64 t)

public Quad64 peek()

public Quad64 poll()

private void percDown(int loc)

private void percUp(int loc)

private void percUpIter(int loc)

public boolean isEmpty()

public void clear()

public int size()

public static int tier(int x)

public boolean testForDuplicates()

</class Quad64Heap>
<class QuadHeap>
public final class QuadHeap

#Fields
private final Quad[] array

private final int CAPACITY

private int size=0


#Methods
public QuadHeap(int maxSize)

public boolean add(Quad t)

public Quad peek()

public Quad poll()

@Override public String toString()

</class QuadHeap>
<class QualityTools>
*@author Brian Bushnell
*@date Jul 17, 2011 12:04:06 PM
public class QualityTools

#Fields
public static final byte MATRIX_SIZE=50

*Probability that this base is an error
public static final float[] PROB_ERROR=makeQualityToFloat(128)

*1/PROB
public static final float[] PROB_ERROR_INVERSE=makeInverse(PROB_ERROR)

public static final float[] PROB_CORRECT=oneMinus(PROB_ERROR)

public static final float[] PROB_CORRECT_INVERSE=makeInverse(PROB_CORRECT)

*Probability that at least one base will be incorrect, given two quality scores
public static final float[][] ERROR_MATRIX=makeErrorMatrix(PROB_ERROR,MATRIX_SIZE)

*Combined phred score given two quality scores
public static final byte[][] PHRED_MATRIX=makePhredMatrix(ERROR_MATRIX)


#Methods
public QualityTools()

public static void bench(int length, int rounds)

public static void bench2(int length, int rounds)

public static int[] makeKeyScores(byte[] qual, byte[] bases, int keylen, int range, int baseScore, int[] out, boolean useModulo)

public static int[] makeKeyScores(float[] probs, int numProbs, int range, int baseScore, int[] out)

public static int[] makeIntScoreArray(byte[] qual, int maxScore, int[] out)

public static byte[] makeByteScoreArray(byte[] qual, int maxScore, byte[] out, boolean negative)

public static byte[] makeByteScoreArray(int maxScore, byte[] out, boolean negative)

*Returns prob of error for each key
public static float[] makeKeyProbs(byte[] quality, byte[] bases, int keylen, boolean useModulo)

*Returns prob of error for each key
public static float[] makeKeyProbs(byte[] quality, byte[] bases, int keylen, float[] out, boolean useModulo)

*Returns prob of error for each key
public static float[] makeKeyProbs(byte[] bases, int keylen, float[] out, boolean useModulo)

public static float[] makeKeyProbs2(byte[] quality, int keylen)

public static byte[] makeQualityArray(int length, Random randyQual, int minQual, int maxQual, byte baseQuality, byte slant, int variance)

public static int[] modifyOffsets(int[] offsets, float[] keyProbs)

*Requires qualities under MATRIX_SIZE
public static byte qualsToPhred(byte qa, byte qb)

*Safe version for qualities >=MATRIX_SIZE
public static byte qualsToPhredSafe(byte qa, byte qb)

public static float qualsToProbError(byte qa, byte qb)

public static float qualsToProbCorrect(byte qa, byte qb)

public static float qualsToProbErrorSafe(byte qa, byte qb)

public static float qualsToProbCorrectSafe(byte qa, byte qb)

public static byte[] fakeQuality(int q, int len)

public static float[] phredToProbError(float[] trimq)

public static byte probCorrectToPhred(double prob)

public static byte probErrorToPhred(double prob)

public static double phredToProbError(double q)

public static byte probErrorToPhred(double prob, boolean round)

public static double probErrorToPhredDouble(double prob)

private static final float[] makeQualityToFloat(int n)

private static final float[] makeInverse(float[] prob)

private static final float[] oneMinus(float[] prob)

private static final float[][] makeErrorMatrix(float[] prob, byte maxq)

private static final byte[][] makePhredMatrix(float[][] error)

</class QualityTools>
<class ReformatBatchOutput>
public class ReformatBatchOutput

#Methods
public static void main(String[] args)

public static String header()

public static int getReads(String name)

public static char getVarType(String name)

public static int getCount(String name)

public static String getProgram(String name)

public static void process(ArrayList<String> list)

</class ReformatBatchOutput>
<class ReformatBatchOutput2>
public class ReformatBatchOutput2

#Methods
public static String header()

</class ReformatBatchOutput2>
<class RefToIndex>
*@author Brian Bushnell
*@date Sep 25, 2013
public class RefToIndex

#Fields
public static boolean AUTO_CHROMBITS=true

public static boolean LOG=false

public static boolean NODISK=false

public static boolean FORCE_READ_ONLY=false

public static boolean overwrite=true

public static boolean append=false

public static boolean genScaffoldInfo=true

public static long maxChromLen=-1

public static int minScaf=-1

public static int midPad=-1

public static int stopPad=-1

public static int startPad=-1

public static int chrombits=-1

public static ArrayList<ChromosomeArray> chromlist=null


#Methods
public static final void clear()

public static String summaryLoc(int build)

public static String bloomLoc(int build)

public static void makeIndex(String reference, int build, PrintStream sysout, int keylen)

</class RefToIndex>
<class Solver>
public class Solver

#Fields
public static final int BASE_POINTS_PER_SITE=-50

public static long POINTS_PER_SITE=-50

public static final long MULT_FOR_SPACING_PENALTY=-30

public static long EARLY_TERMINATION_SCORE=(POINTS_PER_SITE * 2000)

public static final long POINTS_PER_LIST=30000

public static final long POINTS_PER_BASE1=6000

public static final long POINTS_PER_BASE2=1000

public static final long BONUS_POINTS_FOR_END_LIST=40000

public static final long POINTS_FOR_TOTAL_LIST_WIDTH=5500

public static final long[] masks=new long[64]

public static final int[] masks32=new int[32]


#Methods
public static final long bruteForce(int[] offsets, int[] lengths, int chunk, int minLists, int maxTotalLength)

public static final void findWorstGreedy(int[] offsets, int[] lengths, int chunk, int[] lists, int[] r)

public static final void findWorstGreedy(int[] offsets, int[] lengths, float[] weights, int chunk, int[] lists, int[] r)

public static long valueOfElement(int[] offsets, int[] lengths, float keyWeight, int chunk, int[] lists, int index)

public static int[] toBitList(int key)

public static int[] toBitList(long key)

public static long evaluate(int[] offsets, int[] lengths, int chunk, long key)

</class Solver>
<class SplitMappedReads>
public class SplitMappedReads

#Fields
public final String outname

private final RTextInputStream stream

private final ConcurrentLegacyReadInputStream cris

private final OutputStream[] outArraySingle1

private final PrintWriter[] printArraySingle1

private final ArrayList<Read>[] bufferArraySingle1

private final OutputStream[] outArraySingle2

private final PrintWriter[] printArraySingle2

private final ArrayList<Read>[] bufferArraySingle2

private final OutputStream[] outArrayPaired1

private final PrintWriter[] printArrayPaired1

private final ArrayList<Read>[] bufferArrayPaired1

private final OutputStream[] outArrayPaired2

private final PrintWriter[] printArrayPaired2

private final ArrayList<Read>[] bufferArrayPaired2

private final int MIN_CHROM

private final int MAX_CHROM

public final boolean paired

public static boolean USE_CRIS=true

public static final int WRITE_BUFFER=400


#Methods
public SplitMappedReads(String fname1, String fname2, String outname_, int minChrom, int maxChrom)

public SplitMappedReads(RTextInputStream stream_, String outname_, int minChrom, int maxChrom)

public void process()

private void processReads(ArrayList<Read> reads)

private void addRead(Read r, int side)

private static void writeList(ArrayList<Read> list, PrintWriter writer)

public void finish()

</class SplitMappedReads>
<class TranslateColorspaceRead>
public final class TranslateColorspaceRead

#Fields
public MSA msaBS

public static boolean verbose=false

public static boolean DISCARD_NOCALLED_INSERTIONS=false

public static boolean THROW_EXCEPTION_ON_VERIFY_FAILURE=true


#Methods
public TranslateColorspaceRead(MSA msa)

private static CharSequence toString(byte[][] crbmq)

private static String toStringCS(byte[] colors)

public void realignByReversingRef(Read r, int padding, boolean recur)

*This aligns a read with the reference, and generates the match string.
public static void realignByReversingRef(Read r, MSA msa, int padding, boolean recur)

public void realign_new(Read r, int padding, boolean recur, int minScore, boolean forbidIndels)

*For some reason realign was making the match string backwards...
public static void realign_new(SiteScore ss, byte[] bases, MSA msa, int padding, int recur, int minValidScore, boolean forbidIndels, boolean fixXY, long id)

private static final boolean checkArray(byte[] bases)

public static byte[] translateQuality(byte[] qcs)

private static int fixIndels(byte[][] crbmq, Read r)

private static boolean fixDeletion(byte[][] crbmq, int loc, Read r)

private static boolean fixInsertion(byte[][] crbmq, int loc)

private static int fixNocallsInline(byte[][] crbmq, Read read)

private static int fixNocalls(byte[][] crbmq)

private static int fixNocallsBackward(byte[][] crbmq)

public static boolean perfectMatch(byte[] match)

private static boolean containsIndels(byte[] match)

private static boolean containsNocalls(byte[] match)

private static boolean containsXY(byte[] match)

*thresh: Must see this many consecutive 'm' to stop.
private static int trimEnd(byte[][] crbmq, int thresh, Read r)

*thresh: Must see this many consecutive 'm' to stop.
private static int trimStart(byte[][] crbmq, int thresh, Read r)

private static int fixSubs(byte[][] crbmq)

private static int distToMismatch(byte[] colors, byte[] colorRef, int loc, int limit)

public static boolean verifyMatchString2(Read r, boolean loud)

public static boolean verifyMatchString(byte[] call, byte[] ref, byte[] match, int rstart, boolean loud)

*When this is called, the match string should be plus-oriented
public ArrayList<Varlet> toVars(Read read, boolean CONDENSE, boolean CONDENSE_SNPS, boolean SPLIT_SUBS)

</class TranslateColorspaceRead>
