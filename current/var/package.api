#version 1
#package var
#generated 2025-09-06T20:39:42

<class ApplyVarsToReference>
*@author Brian Bushnell
*@date Jul 23, 2012
public class ApplyVarsToReference

#Fields
public static int THREADS=1

private static boolean foundNocall=false

private static boolean STAY_NEAR_REF=false

private static final int REF_LIMIT=20

public static boolean REGEN_N_BLOCKS=true

public static int N_BLOCK_END_SIZE=2000

public static int N_BLOCK_SIZE=300

public static int N_BLOCK_TRIGGER=80

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false


#Methods
public static void main(String[] args)

public static void process(String inVarsName, String outChromName, int chrom)

public static ChromosomeArray regenNBlocks(ChromosomeArray cha, int blocksize, int trigger, int endsize)

</class ApplyVarsToReference>
<class GenerateConsensusVariations>
*@author Brian Bushnell
*@date Jul 23, 2012
public class GenerateConsensusVariations

#Fields
*TODO
public static int THREADS=1

public static int NOREF_CAP=-1

public static float consensusRatio=1f

public static float consensusRatioNR=1f

public static long VARS_IN=0

public static long VARLEN_IN=0

public static long NOREFS_IN=0

public static long VARS_OUT=0

public static long VARLEN_OUT=0

public static long NOREFS_OUT=0

public static boolean verbose=false


#Methods
public static void main(String[] args)

*Now removes overlapping vars by retaining better quality one.
public static void process(String invars, String incov, String outfile, int chrom, int mincov)

*@param v
*@param ca
*@return
private static boolean passesFilter(Varlet v, CoverageArray ca, ChromosomeArray cha, int minCoverageToPass)

</class GenerateConsensusVariations>
<class GenerateVarlets>
public class GenerateVarlets

#Fields
public final String outname

public final String sitesfile

private HashMap<Long,SiteR> sitemap=null

private final RTextInputStream stream

private final ConcurrentLegacyReadInputStream cris

private final OutputStream[] outArray

private final PrintWriter[] printArray

public static boolean USE_CRIS=true

public static int THREADS=5

public static int WRITE_BUFFER=20000

public static boolean CONDENSE=true

public static boolean CONDENSE_SNPS=true

public static boolean SPLIT_SUBS=false

public static boolean TOSS_SOLO1=false

public static boolean TOSS_SOLO2=false

public static boolean MERGE_EQUAL_VARLETS=false

public static boolean PAC_BIO_MODE=true

public static int ALIGN_ROWS=2020

public static int ALIGN_COLUMNS=3000

public static long MAX_READS=-1

public static final int MIN_END_DIST=4


#Methods
public static void main(String[] args)

public GenerateVarlets(String fname1, String fname2, String outname_, int minChrom, int maxChrom, long maxReads, String sitesfile_)

public GenerateVarlets(RTextInputStream stream_, String outname_, int minChrom, int maxChrom, long maxReads, String sitesfile_)

public void finish()

public void process()

*@param sitesfile2
*@return
private static final HashMap<Long,ArrayList<SiteScoreR>> loadSites_old(String fname)

*@param sitesfile2
*@return
private static final HashMap<Long,SiteR> loadSites(String fname)

private void writeList(ArrayList<Varlet> list)

</class GenerateVarlets>
<class GenerateVarlets2>
*Splits output files across blocks for low memory usage
public class GenerateVarlets2

#Fields
private HashMap<Long,ArrayList<Varlet>> keymap

public final String outname

public final String sitesfile

private HashMap<Long,SiteR> sitemap=null

private final RTextInputStream stream

private final ConcurrentLegacyReadInputStream cris

public static boolean USE_CRIS=true

public static int THREADS=7

public static int WRITE_BUFFER=200000

public static boolean CONDENSE=true

public static boolean CONDENSE_SNPS=true

public static boolean SPLIT_SUBS=false

public static boolean TOSS_SOLO1=false

public static boolean TOSS_SOLO2=false

public static boolean MERGE_EQUAL_VARLETS=false

public static boolean PAC_BIO_MODE=true

public static int ALIGN_ROWS=2020

public static int ALIGN_COLUMNS=3000

public static long MAX_READS=-1

public static final int MIN_END_DIST=4

public static int BLOCKSIZE=1000000


#Methods
public static void main(String[] args)

public GenerateVarlets2(String fname1, String fname2, String outname_, byte minChrom, byte maxChrom, long maxReads, String sitesfile_)

public GenerateVarlets2(RTextInputStream stream_, String outname_, byte minChrom, byte maxChrom, long maxReads, String sitesfile_)

public void finish()

public void process()

*@param sitesfile2
*@return
private static final HashMap<Long,SiteR> loadSites(String fname)

private void writeList(ArrayList<Varlet> list)

protected static final long key(int chrom, int start)

protected static final long[] keys(int chrom)

protected static final String fname(long key, String outname)

private final void makeKeyMap()

</class GenerateVarlets2>
<class GenerateVarlets3>
*Splits output files across blocks for low memory usage.
*Uses id-sorted site list for even lower memory usage.
public class GenerateVarlets3

#Fields
private HashMap<Long,ArrayList<Varlet>> keymap

private final char[][] nearestDefinedBase

private final int maxDistFromDefined

private final CoverageArray[] pcov

public final String outname

public final String sitesfile

private TextFile sitesTextFile

private static long maxSiteRead=-1

private static long maxSiteTableSize=-1

private static long sitesLoaded=0

private static long sitesRetained=0

private static long linesLoaded=0

private static long linesRetained=0

private HashMap<Long,SiteR> sitemap=new HashMap<Long,SiteR>(4096)

private final RTextInputStream stream

private final ConcurrentLegacyReadInputStream cris

public static boolean USE_CRIS=true

public static int THREADS=Shared.LOGICAL_PROCESSORS

public static int WRITE_BUFFER=16000

public static boolean CONDENSE=true

public static boolean CONDENSE_SNPS=true

public static boolean SPLIT_SUBS=false

public static boolean TOSS_SOLO1=false

public static boolean TOSS_SOLO2=false

public static boolean MERGE_EQUAL_VARLETS=false

public static boolean PAC_BIO_MODE=true

public static int ALIGN_ROWS=2020

public static int ALIGN_COLUMNS=3000

public static long MAX_READS=-1

public static int MIN_END_DIST=4

public static int BLOCKSIZE=1000000

*Imperfect reads fully covered by perfect reads to this depth or more will be tossed.
public static int MIN_PCOV_DEPTH_TO_TOSS=2

*Extend perfect coverage depth requirement by this much of the tips of variations and reads before tossing them.
*A higher number means more varlets will be retained.
public static int PCOV_TIP_DIST=8


#Methods
public static void main(String[] args)

public GenerateVarlets3(String fname1, String fname2, String outname_, long maxReads, String sitesfile_, String pcovFile, int distFromDefined_)

public GenerateVarlets3(RTextInputStream stream_, String outname_, long maxReads, String sitesfile_, String pcovFile, int distFromDefined_)

public void finish()

public void process()

*@param sitesfile2
*@return
private final long readSites(TextFile tf, long maxID)

public SiteR toImperfectSites(String s, boolean retainSemiperfect)

public static SiteR toImperfectSites2(String s)

private void writeList(ArrayList<Varlet> list)

protected static final long key(int chrom, int start)

protected static final long[] keys(int chrom)

protected static final String fname(long key, String outname)

private final void makeKeyMap()

</class GenerateVarlets3>
<class StackVariations>
public class StackVariations

#Fields
public static long deltaLenKept_global=0

public static long deltaLenIn_global=0

public static long snpKept_global=0

public static long delKept_global=0

public static long insKept_global=0

public static long subKept_global=0

public static long delLenKept_global=0

public static long insLenKept_global=0

public static long subLenKept_global=0

public static long totalIn_global=0

public static long totalInNR_global=0

public static long totalKept_global=0

public static long totalDropped_global=0

public static long totalKeptNR_global=0

public static long totalDroppedNR_global=0

public static long scoreKept_global=0

public static long scoreDropped_global=0

private static int activeThreads=0

private static final String THREADLOCK=new String("THREADLOCK")

private static int THREADS=3

public static final int MIN_READS_TO_KEEP=1

public static final int MIN_QUALITY_AT_MIN_READS=14

public static final int MAX_ERRORS_AT_MIN_READS=2

public static final int MAX_EXPECTED_ERRORS_AT_MIN_READS=4

public static final boolean REQUIRE_PAIRED_AT_MIN_READS=true

public static boolean STRICT=false

public static boolean VSTRICT=false

public static boolean USTRICT=false

public static final boolean verbose=false


#Methods
public static void main(String[] args)

public static final void runThreaded(String inPattern, String outPattern, int minChrom, int maxChrom, boolean filter)

public static boolean passesFilterSNP(Varlet v)

public static boolean passesFilterOther(Varlet v)

public static ArrayList<Varlet> mergeAll(ArrayList<Varlet> vars)

public static Varlet mergeEqualVarlets(ArrayList<Varlet> vars)

private static int addThread(int x)

</class StackVariations>
<class StackVariations2>
public class StackVariations2

#Fields
public static long deltaLenKept_global=0

public static long deltaLenIn_global=0

public static long snpKept_global=0

public static long delKept_global=0

public static long insKept_global=0

public static long subKept_global=0

public static long delLenKept_global=0

public static long insLenKept_global=0

public static long subLenKept_global=0

public static long totalIn_global=0

public static long totalInNR_global=0

public static long totalKept_global=0

public static long totalDropped_global=0

public static long totalKeptNR_global=0

public static long totalDroppedNR_global=0

public static long scoreKept_global=0

public static long scoreDropped_global=0

private static int activeThreads=0

private static final String THREADLOCK=new String("THREADLOCK")

private static int THREADS=7

private static boolean DELETE_INPUT=false

public static int MIN_READS_TO_KEEP=1

public static final int MIN_QUALITY_AT_MIN_READS=14

public static final int MAX_ERRORS_AT_MIN_READS=2

public static final int MAX_EXPECTED_ERRORS_AT_MIN_READS=4

public static final boolean REQUIRE_PAIRED_AT_MIN_READS=false

public static boolean STRICT=false

public static boolean VSTRICT=false

public static boolean USTRICT=false

public static final boolean verbose=false


#Methods
public static void main(String[] args)

public static final void runThreaded(String inPattern, String outPattern, int minChrom, int maxChrom, boolean filter)

public static boolean passesFilterSNP(Varlet v)

public static boolean passesFilterOther(Varlet v)

public static ArrayList<Varlet> mergeAll(ArrayList<Varlet> vars)

public static Varlet mergeEqualVarlets(ArrayList<Varlet> vars)

private static int addThread(int x)

</class StackVariations2>
<class Variation>
public class Variation

#Fields
private static final long serialVersionUID=-3847258470952802740l

public int beginLoc=-2

public int endLoc=-2

public int chromosome=-1

public byte varType=-1

public String ref=null

public String call=null

public static final HashMap<Object,Object> ploidyMap=makePloidyMap()

public static final String[] haploMap={"0","1","2","all"}

public static final String[] varTypeMap={"ref","snp","ins","del","sub","no-call-rc","no-call-ri","no-call","no-ref","PAR-called-in-X","null","refpoint"}

public static final HashMap<String,Byte> varTypeMap2=makeVarTypeMap()

public static final byte REF=0

public static final byte SNP=1

public static final byte INS=2

public static final byte DEL=3

public static final byte DELINS=4

public static final byte REFCON=5

public static final byte REFINCON=6

public static final byte NOCALL=7

public static final byte NOREF=8

public static final byte PAR=9

public static final byte NULL=10

public static final byte REFPOINT=11


#Methods
public Variation(VarLine line)

public Variation(Variation line)

public Variation(int chr, int bLoc, int eLoc, byte vType, String rf, String ca)

public Variation()

@Override public Variation clone()

public static final HashSet<Variation> toVariations(VarLine[] array, boolean retainEqual)

public static final Variation[] toVariationArray(VarLine[][] array, boolean retainEqual)

public static final Variation[] toVariationArray(VarLine[] array, boolean retainEqual)

@SuppressWarnings public static final X[] toArray(Class<X> c, Set<X> set)

public static VarLine[] filterCodingVariances(VarLine[] variances, int chrom, boolean nearby)

*Generates an array of non-overlapping Ranges, sorted by index, ascending.
*To each is attached a list of all overlapping Variations from the input array.
*@param va
*@return The array of ranges
public static Range[] makeVarRanges(Variation[] va)

public static final int toRsid(String s)

public static final int xRefToId(String s)

public static final int[] toRsidArray(String s)

public static final int[] xRefToIdArray(String s)

public boolean matches(Variation line)

*Overlap and don't contradict each other
public boolean matchesLoose(VarLine line)

private boolean matches(int type, String ref2, String call2)

private void setDetails(byte vt, String rf, String ca)

public String locationString()

public String locationString(int base)

public String toSuperString()

@Override public String toString()

public String toString(int base)

public String toSourceString()

public static String header()

public String toShortString()

public static final int find(String a, String[] array)

public final int lengthRef()

public final int lengthMax()

public final int lengthMin()

public final int lengthDif()

public final int lengthVar()

public final boolean isPoint()

public final boolean isRef()

public final boolean isTrueVariation()

public final boolean isNoCall()

public final boolean isNR_or_NC()

public final boolean isUnsureVariation()

*Does this variation intersect within (range) of a coding region or splice site?
public boolean isNearCodingOrSplice(int range, boolean includeExonsForUntranslatedGenes, boolean includeSplice)

*Does this variation intersect within (range) of a coding region or splice site?
public boolean isNearCodingOrSplice(int range, boolean includeExonsForUntranslatedGenes)

*Does this variation lie at least partially within an intron?
public boolean intersectsIntron()

*Does this variation intersect within (range) of a coding region or splice site?
public boolean isNearCodingOrSplice(int range, boolean includeExonsForUntranslatedGenes, GeneSet[] sets, boolean includeSplice)

*Does this variation lie at least partially within an intron?
public boolean intersectsIntron(GeneSet[] sets)

private static final HashMap<String,Byte> makeVarTypeMap()

public void intern()

private static HashMap<Object,Object> makePloidyMap()

private static final int min(int x, int y)

private static final int max(int x, int y)

@Override public final int hashCode()

@Override public int compareTo(Variation other)

@Override public boolean equals(Object other)

public boolean equals(Variation other)

public boolean intersects(int point)

public boolean touches(int point)

*This is quite clever.
public static boolean overlap(int a1, int b1, int a2, int b2)

public static boolean touch(int a1, int b1, int a2, int b2)

*Is (a1, b1) within (a2, b2) ?
public static boolean isWithin(int a1, int b1, int a2, int b2)

public static boolean isWithinNotTouching(int a1, int b1, int a2, int b2)

public boolean intersects(int a2, int b2)

public boolean isWithin(int a2, int b2)

public boolean isWithinNotTouching(int a2, int b2)

public boolean intersects(Variation v)

</class Variation>
<class Varlet>
public class Varlet

#Fields
private static final long serialVersionUID=-606340580378991068L

private int qvector

public int mapScore

public int errors

public float expectedErrors

public int matchStart

public int matchStop

public int readStart

public int readStop

public int headDist

public int tailDist

public int endDist

public byte strand

public int paired

public long readID

*Length of read when used for calling vars; ie, after being trimmed.
public int readLen

public int numReads

public int numSemiUniqueReads=1

public int numUniqueReads=1

*Varlets from read 1 mapped to plus strand
public int numPlusReads1=0

*Varlets from read 1 mapped to minus strand
public int numMinusReads1=0

*Varlets from read 2 mapped to plus strand
public int numPlusReads2=0

*Varlets from read 2 mapped to minus strand
public int numMinusReads2=0


#Methods
public Varlet(int chrom_, byte strand_, int start_, int stop_, int matchStart_, int matchStop_, byte vType, String rf, String ca, int varQuality_, int readQuality_, int mapScore_, int errors_, float expectedErrors_, int paired_, long readID_, int readLen_, int readStart_, int readStop_, int readCopies_, int headDist_, int tailDist_, int endDist_, int pairnum)

@Override public String toString()

public static String header()

public static CharSequence textHeader()

public final StringBuilder toText()

public static final ArrayList<Varlet> fromTextFile(String fname)

public static final Varlet fromText(String line)

@Override public boolean equals(Variation other)

@Override public int compareTo(Variation other)

public int compareTo(Varlet other)

*TODO: Add expected errors, tailDist, endDist
public int score()

public int avgVarQuality()

public int avgReadQuality()

public int maxVarQuality()

public int maxReadQuality()

public void setAvgVarQuality(int value)

public void setAvgReadQuality(int value)

public void setMaxVarQuality(int value)

public void setMaxReadQuality(int value)

public void setQvector(int avq, int arq, int mvq, int mrq)

*Number of reads1 and reads2 mapped to the plus strand
public int numPlusMappedReads()

*Number of reads1 and reads2 from which the original molecule (i.e., read 1) mapped to the plus strand
public int numPlusOriginReads()

*Number of reads1 and reads2 mapped to the minus strand
public int numMinusMappedReads()

*Number of reads1 and reads2 from which the original molecule (i.e., read 1) mapped to the minus strand
public int numMinusOriginReads()

public int minStrandReads()

public int minStrandReads4()

public int minStrandReads3()

public int strandReadCount()

public int pairNum()

</class Varlet>
<class VarLine>
public class VarLine

#Fields
public static final long serialVersionUID=-4089933371294357462L

public byte ploidy

*Which copy this is on
public byte haplotype

public int totalScore

public int hapLink

public static final String[] VQARRAY=new String[]{"?","VQLOW","VQHIGH"}


#Methods
public VarLine()

public VarLine(String s, float version)

@Override public VarLine clone()

public VarLine[] splitLine()

public VarLine spawnEqualPoint()

public static VarLine makeEqualPoint(byte chrom, int loc, byte hap)

@Override public String toSuperString()

@Override public String toString()

public static String sourceHeader()

@Override public String toSourceString()

@Override public String toShortString()

@SuppressWarnings private static final int min(int x, int y)

private static final int max(int x, int y)

@Override public int compareTo(Variation other)

public int compareTo(VarLine other)

@Override public boolean equals(Object other)

public boolean equals(VarLine other)

@Override public boolean equals(Variation other)

</class VarLine>
