#version 1
#package repeat
#generated 2025-09-06T20:38:07

<class Palindrome>
public class Palindrome

#Fields
*Start location
public int a=0

*Stop location
public int b=0

*Length of the palindromic sequence, excluding the loop
public int matches=0

*Number of mismatches in the palindrome
public int mismatches=0


#Methods
public Palindrome()

public Palindrome(int a_, int b_, int matches_, int mismatches_)

public void set(int a_, int b_, int matches_, int mismatches_)

public void setFrom(Palindrome p)

public String toString()

public String toString(int a0, int b0)

public ByteBuilder appendTo(ByteBuilder bb, int a0, int b0)

public int plen()

public int length()

public int loop()

public Palindrome clear()

public Palindrome clone()

*The greater of the two will have more matches, or fewer mismatches,
*or be longer, or more to the left.
public int compareTo(Palindrome p)

</class Palindrome>
<class PalindromeFinder>
*Finds the longest palindrome in a specified region.
*Designed for hairpins, so it allows both a bounded loop size,
*number of mismatches, and tail length.
*@author Brian Bushnell
*@date August 30, 2023
public class PalindromeFinder

#Fields
private final Palindrome tempB=new Palindrome()

private final Palindrome tempC=new Palindrome()

private final Palindrome tempD=new Palindrome()

private final IntList mismatchList=new IntList()

public PalindromeTracker tracker=new PalindromeTracker()

public PalindromeTracker trackerFull=new PalindromeTracker()

public final int maxMismatches

public final int minMatches

public final int minLoop

public final int maxLoop

public final int minPLen

public final int minTail

public final int maxTail

public final int maxTailDif

public final int halfMinLoopOdd

public final int halfMinLoopEven

public final int halfMinLength

static final boolean rcomp=true

static final byte[] baseToComp=makeBaseToComp()


#Methods
public static void main(String[] args)

public PalindromeFinder(int minPLen_, int minLoop_, int maxLoop_, int minMatches_, int maxMismatches_, int minTail_, int maxTail_, int maxTailDif_)

public Palindrome longestPalindrome(byte[] s)

public Palindrome longestPalindrome(byte[] s, int minPos, int maxPos)

private Palindrome longestPalindromeOddIgnoringLoop(byte[] s, int middle, int minPos, int maxPos)

private Palindrome longestPalindromeEvenIgnoringLoop(byte[] s, int middle, int minPos, int maxPos)

private Palindrome longestPalindromeOdd(byte[] s, int middle, int minPos, int maxPos)

private Palindrome longestPalindromeEven(byte[] s, int middle, int minPos, int maxPos)

private Palindrome longestPerfectPalindrome(byte[] s, int a0, int b0, int minPos, int maxPos)

*TODO: Make a new dynamic programming version with +10 for match and -9 for mismatch
private Palindrome longestImperfectPalindrome(byte[] s, int a0, int b0, int minPos, int maxPos)

@Override public String toString()

static boolean matches(byte a, byte b)

static byte[] makeBaseToComp()

</class PalindromeFinder>
<class Repeat>
public class Repeat

#Fields
public final int k

public final int maxGap

public final int minRepeat

public final char type

public long contigNum=-1

public int start=-1

public int stop=-1

public int gapCount=0

public int gapLen=0

public int gapBP=0

public long depthSum=0

public int minDepth=Integer.MAX_VALUE

public int maxDepth=-1

public Read contig

public String contigName

public byte[] seq

public float gc

public float entropy

int tipdist

public final int depth

public static int SEQ_AFFIX_LEN=12


#Methods
public Repeat(Read contig_, int start_, int depth_, int k_, int maxGap_, int minRepeat_, char type_)

public Repeat clone()

public void clear()

public Repeat increment(Read currentContig, int pos, int currentDepth)

public int length()

public final boolean overlaps(Repeat r)

public final boolean spans(Repeat r)

public final boolean subsumes(Repeat r, boolean weak)

void calcStats(EntropyTracker et)

void setSeq(ByteBuilder bb)

public CRange toRange()

@Override public int compareTo(Repeat r)

@Override public String toString()

public ByteBuilder toBytes()

public ByteBuilder appendTo(ByteBuilder bb)

ByteBuilder appendPreview(ByteBuilder bb)

public Read toRead()

public byte[] fullSequence()

public String readHeader()

public static String tsvHeader()

</class Repeat>
<class Repeat.PosComparator>
*For depth subsumption
public static class Repeat.PosComparator

#Fields
public static final PosComparator comparator=new PosComparator()


#Methods
@Override public int compare(Repeat a, Repeat b)

</class Repeat.PosComparator>
<class Repeat.PosComparator2>
*For positional subsumption
public static class Repeat.PosComparator2

#Fields
public static final PosComparator2 comparator=new PosComparator2()


#Methods
@Override public int compare(Repeat a, Repeat b)

</class Repeat.PosComparator2>
<class RepeatFinder>
*This class finds probable repeats using kmer-matching,
*and prints them out ordered by depth, then length.
*The repeats are only "probable" because no alignment is done;
*a sequence is considered a probable repeat of depth D if
*if all kmers within it have a depth of at least D.
*@author Brian Bushnell
*@date June 15, 2023
public class RepeatFinder

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String outr="stdout.txt"

*Sequence output
private String outs=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

protected long repeatBases=0

protected long basesMasked=0

*Number of high-depth bases found
protected long highDepthBases=0

*Number of low-entropy bases found
protected long lowEntropyBases=0

*Number of short tandem repeat bases
protected long shortTandemBases=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

boolean forbidNs=true

boolean printRepeats

boolean maskRepeats=true

boolean softMask=true

byte maskSymbol='N'

boolean weakSubsumes=false

int minRepeat=0

int maxGap=0

boolean processDepth=true

int maxDepth=Shared.MAX_ARRAY_LEN

int minDepth=2

boolean processEntropy=false

int entropyWindow=80

int entropyK=5

float entropyMaskRatio=0.70f

boolean processShortTandem=false

int shortTandemMinK=2

int shortTandemMaxK=15

int shortTandemMincount=4

int shortTandemMinlen=32

*Primary input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffoutr

*Sequence output file
private final FileFormat ffouts

private final int k

private final KmerTableSet tables

private final ArrayList<Repeat> masterListOfRepeats=new ArrayList<Repeat>()

private final byte[] baseMaskArray

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*True for amino acid data, false for nucleotide data
final boolean amino

boolean maskMiddle=false

int qHammingDist=0

final int bitsPerBase

final int maxSymbol

final int symbols

final int symbolArrayLen

final int symbolSpace

final long symbolMask

final int shift

final int shift2

final long mask

final long middleMask

*x&clearMasks[i] will clear base i
final long[] clearMasks

*x|setMasks[i][j] will set base i to j
final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
final long[] rightMasks

*Symbol code; -1 for undefined
final byte[] symbolToNumber

*Symbol code; 0 for undefined
final byte[] symbolToNumber0

*Complementary symbol code; 0 for undefined
final byte[] symbolToComplementNumber0

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=true


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public RepeatFinder(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

void printRepeats(FileFormat ff, ArrayList<Repeat> list)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

final long rcomp(long kmer, int len)

final int maskRange(CRange r)

final int maskRepeat(byte[] bases, int start, int stop)

*Transforms a kmer into all canonical values for a given Hamming distance.
*Returns the maximal count stored in the tables.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param qHDist Hamming distance
*@return Value stored in table, or -1
private final int getValue(long kmer, long rkmer, int qHDist)

@Override public final ReadWriteLock rwlock()

*For verbose / debugging output
final String kmerToString(long kmer, int k)

*Returns true if the symbol is not degenerate (e.g., 'N') for the alphabet in use.
final boolean isFullyDefined(byte symbol)

</class RepeatFinder>
<class RepeatFinder.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class RepeatFinder.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*Number of repeat bases found by this thread
protected long repeatBasesT=0

*Number of bases masked by this thread
protected long basesMaskedT=0

*Number of high depth bases found by this thread
protected long highDepthBasesT=0

*Number of low-entropy bases found by this thread
protected long lowEntropyBasesT=0

*Number of short tandem repeat bases found by this thread
protected long shortTandemBasesT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Thread ID
final int tid

final RepeatSet repeatSet

final EntropyTracker et


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

long maskRepeats(ArrayList<CRange> ranges)

long countRepeatBases(ArrayList<CRange> ranges)

void makePreview(ArrayList<Repeat> list)

*Process a read.
*@param r1 Read 1
*@return max depth observed.
private int processReadDepth(Read r)

private int processReadEntropy(Read rd)

private int processReadShortTandem(Read rd, int mink, int maxk, int mincount, int minlen)

private void findShortTandem(byte[] bases, ArrayList<CRange> ranges, int k, int minlen, long rid)

private int shortTandemLength(byte[] bases, int k, int mask, int loc)

private int getInitialKey(byte[] bases, int loc, int k)

</class RepeatFinder.ProcessThread>
<class RepeatSet>
public class RepeatSet

#Fields
final int k

final int minDepth

final int maxDepth

final int minRepeat

final int maxGap

final boolean weakSubsumes

boolean amino

final int ek

final int ew

final ArrayList<Repeat> openRepeats=new ArrayList<Repeat>()

final ArrayList<Repeat> closedRepeats=new ArrayList<Repeat>()

final ArrayList<Repeat> recent=new ArrayList<Repeat>()

final ArrayList<Repeat> oldRepeats=new ArrayList<Repeat>()

private final ArrayList<CRange> rangeBuffer=new ArrayList<CRange>()

Repeat lastRepeat=null

final EntropyTracker[] eta


#Methods
RepeatSet(int k_, int minDepth_, int maxDepth_, int minRepeat_, int maxGap_, boolean weakSubsumes_, boolean amino_, int ek_, int ew_)

EntropyTracker getET(int len)

void retireClosed()

void addRepeat(Repeat r)

void collectResidual(int maxDepthSeen)

*TODO: This can go from O(N^2) to O(N) if it follows contours instead of incrementing all.
*Also, make sure min depth is implemented.
void increment(Read contig, int pos, int depth)

int subsumeClosed(boolean weak)

ArrayList<CRange> closedToRanges(boolean merge)

ArrayList<CRange> recentToRanges(boolean merge)

ArrayList<Read> fetchRepeatSequence()

static ArrayList<Read> fetchRepeatSequence(ArrayList<Repeat> repeats0, int maxGap, int k)

public static int subsume(ArrayList<Repeat> list, boolean weak)

public static int removeFullyContained(ArrayList<Repeat> repeats, int maxGap, int k)

public static ArrayList<CRange> toRanges(ArrayList<Repeat> repeats, boolean merge, ArrayList<CRange> ranges)

</class RepeatSet>
