#version 1
#package bloom
#generated 2025-09-06T20:35:30

<class BloomFilter>
*Wraps a KCountArray and provides multithreaded reference loading.
*@author Brian Bushnell
*@date April 23, 2018
public class BloomFilter

#Fields
private static final long serialVersionUID=-3987955563503838492L

long maxReads=-1

boolean ecco=false

boolean merge=false

byte minq=0

*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private ArrayList<String> extra=new ArrayList<String>()

public final KCountArray7MTA filter

final int k

final int kbig

final int smallPerBig

final int bits

final int hashes

final int minConsecutiveMatches

final int shift

final int shift2

final long mask

final boolean rcomp

private final long filterMemory

public static long OVERRIDE_CELLS=-1

static final int bitsPerBase=2

public static boolean printMem=true

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public BloomFilter(String[] args)

public BloomFilter(int k_, int kbig_, int bits_, int hashes_, int minConsecutiveMatches_, boolean rcomp_, boolean ecco_, boolean merge_, float memFraction)

public BloomFilter(String in1_, String in2_, ArrayList<String> extra_, int k_, int kbig_, int bits_, int hashes_, int minConsecutiveMatches_, boolean rcomp_, boolean ecco_, boolean merge_, float memFraction)

public BloomFilter(boolean bbmapIndex_, int k_, int kbig_, int bits_, int hashes_, int minConsecutiveMatches_, boolean rcomp_)

private static long setMemory(double mult)

private KCountArray7MTA load()

private KCountArray7MTA loadFromIndex()

public boolean passes(Read r1, Read r2, int thresh)

public float averageCount(byte[] bases)

public int minCount(Read r)

public boolean hasHighCountFraction(Read r, int thresh, float fraction)

public float lowCountFraction(Read r, int thresh, boolean smooth)

*Return the fraction of kmers with count at least thresh.
*@param r Read to examine.
*@param thresh Minimum count to be 'high'.
*@param smooth Reduce each count to min(count, prevCount).
*@return High count fraction, or zero if no valid kmers.
public float highCountFraction(Read r, int thresh, boolean smooth)

*Return the fraction of kmers with count at least thresh.
*@param bases Bases to examine.
*@param thresh Minimum count to be 'high'.
*@param smooth Reduce each count to min(count, prevCount).
*@return High count fraction, or zero if no valid kmers.
public float highCountFraction(byte[] bases, int thresh, boolean smooth)

public boolean isJunk(Read r1, Read r2, int range)

public boolean isJunk(Read r, int range)

private int getLeftCount(byte[] bases, int range)

private int getRightCount(byte[] bases, int range)

public boolean passes(Read r, int thresh)

public boolean matches(Read r, LongList keys, int thresh)

public boolean matchesEither(Read r1, Read r2, LongList keys, int thresh)

public boolean passes(Read r1, Read r2, LongList keys, int thresh)

public boolean passes(Read r, LongList keys, int thresh)

public boolean passes(LongList keys, int thresh)

*Returns number of counts
public int fillCounts(byte[] bases, IntList counts)

public int getCount(long kmer, long rkmer)

public int getCount(long key)

public boolean contains(long kmer, long rkmer, int thresh)

*Returns number of counts
public int fillCountsBig(byte[] bases, IntList counts)

public void fillCountsBig(LongList kmers, IntList counts)

private int smallToBig(IntList counts, int start)

@SuppressWarnings public int getCountBig(long kmer, long rkmer)

public int getCountBig(long kmer)

public boolean containsBig(long kmer, long rkmer, int thresh)

public long toKey(long kmer)

public long toKey(long kmer, long rkmer)

public static final void toKmers(Read r, LongList list, int k, int minQuality, float minProb, boolean rcomp)

</class BloomFilter>
<class BloomFilterCorrector>
public class BloomFilterCorrector

#Fields
protected ThreadLocal<int[]> localLeftCounts=new ThreadLocal<int[]>()

protected ThreadLocal<int[]> localRightCounts=new ThreadLocal<int[]>()

protected ThreadLocal<LongList> localLongList=new ThreadLocal<LongList>()

protected ThreadLocal<IntList> localIntList=new ThreadLocal<IntList>()

protected ThreadLocal<IntList> localIntList2=new ThreadLocal<IntList>()

protected ThreadLocal<ByteBuilder> localByteBuilder=new ThreadLocal<ByteBuilder>()

protected ThreadLocal<ByteBuilder> localByteBuilder2=new ThreadLocal<ByteBuilder>()

protected ThreadLocal<BitSet> localBitSet=new ThreadLocal<BitSet>()

private ThreadLocal<Kmer> localKmer=new ThreadLocal<Kmer>()

private ThreadLocal<Kmer> localKmer2=new ThreadLocal<Kmer>()

protected ThreadLocal<ErrorTracker> localTracker=new ThreadLocal<ErrorTracker>()

protected boolean ECC_PINCER=false

protected boolean ECC_TAIL=false

protected boolean ECC_ALL=false

protected boolean ECC_REASSEMBLE=true

protected boolean ECC_AGGRESSIVE=false

protected boolean ECC_CONSERVATIVE=false

protected boolean ECC_ROLLBACK=true

protected boolean ECC_REQUIRE_BIDIRECTIONAL=true

*Mark bases as bad if they are completely covered by kmers with a count below this
protected int MARK_BAD_BASES=0

*Only mark bad bases that are adjacent to good bases
protected boolean MARK_DELTA_ONLY=true

*Only mark bad bases in reads that appear to have errors
protected boolean MARK_ERROR_READS_ONLY=true

*Assign this quality score to marked bases
protected byte MARK_QUALITY=0

BloomFilter filter

int k=31

int ksmall=31

final boolean rcomp=true

int minCountExtend=2

float branchMult1=20

float branchMult2=3

int branchLowerConst=3

int errorPath=1

float errorMult1=16

float errorMult2=2.6f

float errorMultQFactor=0.002f

int errorLowerConst=4

int minCountCorrect=3

int pathSimilarityConstant=3

float pathSimilarityFraction=0.45f

int errorExtensionReassemble=3

int errorExtensionPincer=3

int errorExtensionTail=8

int deadZone=0

int windowLen=12

int windowCount=6

int windowQualSum=80

byte qIncreasePincer=8

byte qMinPincer=24

byte qMaxPincer=32

byte qIncreaseTail=4

byte qMinTail=20

byte qMaxTail=28

boolean verbose=false

boolean verbose2=false

boolean smooth=true

int smoothWidth=3

PrintStream outstream=System.err


#Methods
public BloomFilterCorrector(BloomFilter filter_, int k_, int ksmall_)

public int errorCorrect(Read r)

public int errorCorrect(Read r, int[] leftCounts, int[] rightCounts, LongList kmers, IntList counts, IntList counts2, ByteBuilder bb, ByteBuilder bb2, ErrorTracker tracker, BitSet bs, Kmer kmer, Kmer kmer2)

public boolean hasErrorsFast(LongList kmers)

public int errorCorrect(Read r, int[] leftCounts, int[] rightCounts, LongList kmers, IntList counts, IntList counts2, ByteBuilder bb, ByteBuilder bb2, ErrorTracker tracker, BitSet bs)

*Changes to N any base covered strictly by kmers with count below minCount
public final int markBadBases(byte[] bases, byte[] quals, IntList counts, BitSet bs, int minCount, boolean deltaOnly, byte markQuality)

public void fillCounts(byte[] bases, LongList kmers, IntList counts)

private void fillCountsFromKmers(LongList kmers, IntList counts)

public void smooth(LongList kmerList, IntList countList, int width)

public final int reassemble(byte[] bases, byte[] quals, int[] rightCounts, IntList counts, IntList counts2, ErrorTracker tracker, int errorExtension, ByteBuilder bb, ByteBuilder bb2, Kmer kmer, Kmer regenKmer, BitSet bs)

public final int reassemble_pass(byte[] bases, byte[] quals, ByteBuilder fromLeft, ByteBuilder fromRight, int[] rightCounts, IntList counts, IntList counts2, ErrorTracker tracker, int errorExtension, Kmer kmer, Kmer kmer2, BitSet bs)

public int regenerateCounts(byte[] bases, IntList counts, Kmer dummy, BitSet changed)

private static int clearWindow2(ByteBuilder bb, byte[] quals, int window, int limit, int qsumLimit)

public int reassemble_inner(ByteBuilder bb, byte[] quals, int[] rightCounts, IntList counts, int errorExtension, Kmer kmer, Kmer regenKmer)

public int reassemble_inner(ByteBuilder bb, byte[] quals, int[] rightCounts, IntList counts, int errorExtension)

protected final boolean isSubstitution(int ca, int errorExtension, byte qb, IntList counts)

public final int countErrors(IntList counts, byte[] quals)

public int errorCorrectPincer(byte[] bases, byte[] quals, int[] leftBuffer, int[] rightBuffer, LongList kmers, IntList counts, ByteBuilder bb, ErrorTracker tracker, int errorExtension)

public int errorCorrectTail(byte[] bases, byte[] quals, int[] leftBuffer, int[] rightBuffer, LongList kmers, IntList counts, ByteBuilder bb, ErrorTracker tracker, int startPos, int errorExtension)

private int correctSingleBasePincer(int a, int d, byte[] bases, byte[] quals, int[] leftBuffer, int[] rightBuffer, LongList kmers, IntList counts, ByteBuilder bb, int errorExtension)

private int correctSingleBaseRight(int a, byte[] bases, byte[] quals, int[] leftBuffer, int[] rightBuffer, LongList kmers, IntList counts, ByteBuilder bb, int errorExtension0)

private boolean isSimilar(int a, byte newBase, LongList kmers, IntList counts)

protected final boolean isSimilar(int a, int loc1, int loc2, IntList counts)

protected final boolean isSimilar(int a, int b)

protected final boolean isError(int a, int loc1, int loc2, IntList counts)

protected final boolean isErrorBidirectional(int a, int b, byte qa, byte qb)

protected final boolean isError(int high, int low)

protected final boolean isError(int high, int low, byte q)

public int extendToRight2(ByteBuilder bb, int[] leftCounts, int[] rightCounts, int distance, boolean includeJunctionBase)

*Extend these bases to the right by at most 'distance'.
*Stops at right junctions only.
*Does not claim ownership.
public int extendToRight2(ByteBuilder bb, int[] leftCounts, int[] rightCounts, int distance, boolean includeJunctionBase, long kmer, long rkmer)

public void regenerateKmers(byte[] bases, LongList kmers, IntList counts, int a)

public int maxLeftCount(long kmer)

public int maxRightCount(long kmer)

public int fillLeftCounts(long kmer, long rkmer, int[] counts, long mask, int shift2)

public int fillRightCounts(long kmer, long rkmer, int[] counts, long mask, int shift2)

protected final boolean isJunction(int rightMax, int rightSecond, int leftMax, int leftSecond)

protected final boolean isJunction(int max, int second)

*Returns number of valid kmers
public int fillKmers(byte[] bases, LongList kmers)

*Examines kmer counts around the merge borders to ensure the merge was not chimeric
public boolean mergeOK(Read merged, int len1, int len2, LongList kmers, int width, int thresh, long highMult)

public int regenerateCounts(byte[] bases, IntList counts, int ca)

private final StringBuilder toText(long kmer)

private final long rcomp(long kmer)

public final int getCount(long kmer, long rkmer)

public final int getCount(long key)

public final int getCount2(long kmer)

public final long toValue(long kmer, long rkmer)

protected final void initializeThreadLocals()

int minCountCorrect()

</class BloomFilterCorrector>
<class BloomFilterCorrectorWrapper>
*Wraps a BloomFilter to filter or correct reads.
*@author Brian Bushnell
*@date May 14, 2018
public class BloomFilterCorrectorWrapper

#Fields
private ArrayList<String> ref=new ArrayList<String>()

private ArrayList<String> extra=new ArrayList<String>()

*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Output file path for bad reads
private String outbad1=null

*Secondary output file path for bad reads
private String outbad2=null

private String qfoutbad1=null

private String qfoutbad2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*For calculating kmer cardinality in output
final CardinalityTracker loglogOut

long readsExtended=0

long basesExtended=0

long readsCorrected=0

long basesCorrectedPincer=0

long basesCorrectedTail=0

long basesCorrectedReassemble=0

long readsFullyCorrected=0

long rollbacks=0

long readsDetected=0

long basesDetected=0

long readsMarked=0

long basesMarked=0

long readsMerged=0

long readsCorrectedEcco=0

long basesCorrectedEcco=0

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
final FileFormat ffin1

*Secondary input file
final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary output file for matching reads
private final FileFormat ffoutm1

*Secondary output file for matching reads
private final FileFormat ffoutm2

final BloomFilter filter

final BloomFilterCorrector corrector

final int k

final int ksmall

final int hashes

final int bits

final boolean rcomp

final boolean requireBothToPass

final boolean ecc

final boolean ecco

final boolean merge

final boolean testMerge

final boolean tossjunk

final int minCount

final float highCountFraction

final boolean vstrict

final boolean ustrict

final int junkWidth

float memFraction=1.0f

float maxLoad=1.0f

int testMergeWidth=4

long testMergeMult=80L

int testMergeThresh=3

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public BloomFilterCorrectorWrapper(String[] args)

private static void addFiles(String b, ArrayList<String> list)

*Create read streams and process all data
void process(Timer t)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

final int findOverlap(Read r1, Read r2, boolean ecc)

</class BloomFilterCorrectorWrapper>
<class BloomFilterWrapper>
*Wraps a BloomFilter to filter reads.
*@author Brian Bushnell
*@date April 23, 2018
public class BloomFilterWrapper

#Fields
private ArrayList<String> ref=new ArrayList<String>()

*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Output for kmer counts
private String outc=null

private String qfout1=null

private String qfout2=null

*Output file path for matching reads
private String outm1=null

*Secondary output file path for matching reads
private String outm2=null

private String qfoutm1=null

private String qfoutm2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private String serialIn=null

private String serialOut=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
final FileFormat ffin1

*Secondary input file
final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary output file for matching reads
private final FileFormat ffoutm1

*Secondary output file for matching reads
private final FileFormat ffoutm2

*Output for kmers and counts
private final FileFormat ffoutc

final BloomFilter filter

final int k

final int hashes

final int bits

final int minConsecutiveMatches

final boolean rcomp

final boolean requireBothToMatch

final boolean ecco

final boolean merge

final int minCount

float memFraction=1.0f

final int bitsPerBase=BloomFilter.bitsPerBase

final int shift

final int shift2

final long mask

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public BloomFilterWrapper(String[] args)

*Create read streams and process all data
void process(Timer t)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream rosu, ConcurrentReadOutputStream rosm, ConcurrentReadOutputStream rosc)

</class BloomFilterWrapper>
<class ErrorCorrect>
*@author Brian Bushnell
*@date Aug 20, 2012
public class ErrorCorrect

#Fields
public static boolean verbose=false

*Bails out if a read still has errors after correcting this many.
public static int ERROR_CORRECTION_LIMIT=6

*Max allowed number of nearby corrections.
*A long error burst indicates the read simply has low coverage, and is not being corrected correctly.
public static int MAX_ERROR_BURST=3

*Bursts have at most this distance between errors. E.G. '1' means errors are adjacent.
public static int BURST_THRESH=2

*Withhold uncorrectable reads from output.
public static boolean DONT_OUTPUT_BAD_READS=false

*Do not correct an error if it is at most this far from the next error. Instead, bail out.
public static int MIN_ADVANCE=1

*Number of threads used for error correction. Does not control number of threads for creating the hash table.
*Additionally, up to 2 threads are used for reading and up to 2 for writing. For this (singlethreaded) class, the number does nothing.
public static final int THREADS=1

*Output correction data instead of the corrected read
public static boolean OUTPUT_INFO=false


#Methods
public static void main(String[] args)

public static KCountArray makeTable(String reads1, String reads2, int k, int cbits, int hashes, int buildpasses, int matrixbits, long maxreads, int stepsize, int thresh1, int thresh2)

public static void detect(String reads1, String reads2, KCountArray kca, int k, int thresh, long maxReads, String output, boolean ordered, boolean append, boolean overwrite)

public static void detect(ConcurrentReadInputStream cris, KCountArray kca, int k, int thresh, long maxReads, ConcurrentReadOutputStream ros)

*Sets a 1 bit at start of each kmer with count at least thresh
public static BitSet detectErrors(Read r, KCountArray kca, int k, int thresh)

*Sets a 1 bit for every base covered by a kmer with count at least thresh
public static BitSet detectErrorsBulk(Read r, KCountArray kca, int k, int thresh, int stepsize)

*Sets 1 for all bases.
*Then clears all bits covered by incorrect kmers.
public static BitSet detectTrusted(Read r, KCountArray kca, int k, int thresh, int detectStepsize)

public static BitSet detectErrorsTips(Read r, KCountArray kca, int k, int thresh)

*Assumes bulk mode was used; e.g., any '0' bit is covered by no correct kmers
public static BitSet correctErrors(Read r, KCountArray kca, int k, int thresh, BitSet bs, int maxCorrections, int maxBurst)

*@param r
*@param kca
*@param k
*@param thresh
*@param bs
*@param errorLoc
*@return
private static boolean correctFromLeft(Read r, KCountArray kca, int k, int thresh, BitSet bs, int error)

*@param r
*@param kca
*@param k
*@param thresh
*@param bs
*@param errorLoc
*@return
private static boolean correctFromRight(Read r, KCountArray kca, int k, int thresh, BitSet bs, int error)

*returns index of highest value, if unique; else a negative number
private static int maxUniqueIndex(int[] array)

public static final String toString(BitSet bs, int len)

private static void removeBad(ArrayList<Read> list)

</class ErrorCorrect>
<class IndexCounter>
public class IndexCounter

#Fields
private final int k

private final int shift

private final int shift2

private final long mask

private final boolean rcomp

private static final int THREADS_PER_CHROM=4


#Methods
public IndexCounter(int k_, boolean rcomp_)

public KCountArray makeKcaFromIndex(long cells, int cbits, int hashes)

public KCountArray countFromIndex(KCountArray counts)

</class IndexCounter>
<class KCountArray>
*@author Brian Bushnell
*@date Jul 5, 2012
public abstract class KCountArray

#Fields
private static final long serialVersionUID=1590374813059942002L

public final long cells

public final int cellBits

*Originally this was different than valueMask in the case that valueMask was negative, but now they are the same.
public final int maxValue

protected final int cellsPerWord

protected final int indexShift

protected final int cellMask

protected final int valueMask

protected static int minArrays=calcMinArrays()

protected final int arrayBits

protected final int numArrays

protected final int arrayMask

public static boolean verbose=false

*Increases accuracy of overloaded multi-bit tables
public static boolean LOCKED_INCREMENT=false

public static boolean SET_LOCKED_INCREMENT=false


#Methods
public static KCountArray makeNew(long cells_, int cbits_)

public static KCountArray makeNew(long cells_, int cbits_, int hashes_)

public static KCountArray makeNew(long cells_, int cbits_, int hashes_, KCountArray prefilter, int prefilterLimit_)

protected KCountArray(long cells_, int cbits_)

protected KCountArray(long cells_, int cbits_, int arrays_)

public int read(long key)

public int read(long keys)

public final int read(long key, int k, boolean makeCanonical)

public void write(long key, int value)

public final void increment(long key)

public final void decrement(long key)

*Returns nothing for simplicity.
public void increment(long key, int incr)

*Returns unincremented value
public int incrementAndReturnUnincremented(long key, int incr)

public int incrementAndReturnUnincremented(long[] keys, int incr)

*Optional method.
public void decrement(long key, int incr)

public final int readPrecise(long key, int k, boolean makeCanonical)

public final int readPreciseMin(long key, int k, boolean makeCanonical)

*@param key Kmer to evaluate
*@return Sum of counts of all 4 possible left-adjacent kmers
public int readLeft(long key, int k, boolean makeCanonical)

*@param key Kmer to evaluate
*@return Sum of counts of all 4 possible right-adjacent kmers
public int readRight(long key, int k, boolean makeCanonical)

*@param key Kmer to evaluate
*@return Array of counts of all 4 possible left-adjacent kmers
public int[] readAllLeft(long key, int k, boolean makeCanonical, int[] rvec)

*@param key Kmer to evaluate
*@return Array of counts of all 4 possible right-adjacent kmers
public int[] readAllRight(long key, int k, boolean makeCanonical, int[] rvec)

@Deprecated public void increment(long[] keys)

public void increment(LongList keys)

public long[] transformToFrequency()

public final long[] transformToFrequency(int[][] matrix)

public final long[] transformToFrequency(AtomicIntegerArray[] matrix)

public final ByteBuilder description()

public final String toShortString()

public final String toShortString(int hashes)

@Override public final String toString()

public CharSequence toContentsString()

public double usedFraction()

public double usedFraction(int mindepth)

public long cellsUsed(int mindepth)

public final double estimateUniqueKmers(int hashes)

public final double estimateUniqueKmers(int hashes, int mindepth)

public final double estimateUniqueKmersFromUsedFraction(int hashes, double usedFraction)

public final String mem()

public static String toKMG(long x)

static final AtomicIntegerArray[] allocMatrix(int numArrays, int wordsPerArray)

long hash(long x, int y)

public static final int min(int x, int y)

public static final int max(int x, int y)

public static final long min(long x, long y)

public static final long max(long x, long y)

*Any necessary initialization.
public void initialize()

*Any necessary shutdown steps.
public void shutdown()

private static final int calcMinArrays()

public static final boolean isCanonical(long key, int k)

*Assumes that the key is not canonical
public static final long makeCanonical(long key, int k)

public static final long makeCanonical2(long key, int k)

public KCountArray prefilter()

public void purgeFilter()

</class KCountArray>
<class KCountArray2>
*@author Brian Bushnell
*@date Jul 5, 2012
public class KCountArray2

#Fields
private long cellsUsed

public final long cells

public final int cellBits

public final int maxValue

public final int gap

private final int cellsPerWord

private final int indexShift

private final int valueMask

private final int[][] matrix

private static final int arrayBits=2

private static final int numArrays=1 << arrayBits

private static final int arrayMask=numArrays - 1

public static boolean verbose=false


#Methods
public static void main(String[] args)

public KCountArray2(long cells_, int bits_)

public KCountArray2(long cells_, int bits_, int gap_)

public int read(long key)

public void write(long key, int value)

public int increment(long key, int incr)

*Returns unincremented value
public int increment2(long key, int incr)

public long[] transformToFrequency()

@Override public String toString()

public double usedFraction()

public double usedFraction(int mindepth)

public long cellsUsed(int mindepth)

public String mem()

public static final int min(int x, int y)

public static final int max(int x, int y)

public static final long min(long x, long y)

public static final long max(long x, long y)

</class KCountArray2>
<class KCountArray3>
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray3

#Fields
private static final long serialVersionUID=-5466091642729698944L

private long cellsUsed

private final int[][] matrix


#Methods
public KCountArray3(long cells_, int bits_)

@Override public int read(long key)

@Override public void write(long key, int value)

@Override public void increment(long key, int incr)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public String toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override long hash(long x, int y)

</class KCountArray3>
<class KCountArray4>
*Uses hashing rather than direct-mapping to support longer kmers.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray4

#Fields
private static final long serialVersionUID=-1418539960644885681L

private long cellsUsed

private final int[][] matrix

private final int hashes

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private static long counter=0


#Methods
public static void main(String[] args)

public KCountArray4(long cells_, int bits_, int gap_, int hashes_)

@Override public int read(long rawKey)

private int readHashed(long key)

@Override public void write(long key, int value)

@Override public void increment(long rawKey, int incr)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long rawKey, int incr)

private int incrementHashedIfAtMost(long key, int incr, int lim)

private int incrementHashed(long key, int incr)

@Override public long[] transformToFrequency()

@Override public String toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

public long cellsUsed()

</class KCountArray4>
<class KCountArray4MT>
*Uses hashing rather than direct-mapping to support longer kmers.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray4MT

#Fields
private static final long serialVersionUID=-575682515926973788L

private boolean finished=false

private long cellsUsed

final int[][] matrix

private final WriteThread[] writers=new WriteThread[numArrays]

private final int hashes

final int wordsPerArray

private final long cellsPerArray

final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private final long[][] buffers=new long[numArrays][1000]

private final int[] bufferlen=new int[numArrays]

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

static final long[] poison=new long[0]

private static long counter=0


#Methods
public static void main(String[] args)

public KCountArray4MT(long cells_, int bits_, int gap_, int hashes_)

@Override public int read(long rawKey)

private int readHashed(long key)

@Override public void write(long key, int value)

@Override public void increment(long rawKey, int amt)

public void increment0(long rawKey, int amt)

private void incrementPartiallyHashed(long pKey)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public String toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

public long cellsUsed()

</class KCountArray4MT>
<class KCountArray5MT>
*Uses hashing rather than direct-mapping to support longer kmers.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray5MT

#Fields
private static final long serialVersionUID=-5456926900022701212L

private boolean finished=false

private long cellsUsed

final int[][] matrix

private final WriteThread[] writers=new WriteThread[numArrays]

final int hashes

final int wordsPerArray

private final long cellsPerArray

final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private long[] buffer=new long[2000]

private int bufferlen=0

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

static final long[] poison=new long[0]

private static long counter=0


#Methods
public KCountArray5MT(long cells_, int bits_, int gap_, int hashes_)

@Override public int read(long rawKey)

int readHashed(long key)

@Override public void write(long key, int value)

@Override public void increment(long rawKey, int amt)

public void increment0(long rawKey)

@Override public void increment(long[] keys)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public String toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

public long cellsUsed()

</class KCountArray5MT>
<class KCountArray6MT>
*Uses hashing rather than direct-mapping to support longer kmers.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray6MT

#Fields
private static final long serialVersionUID=-1524266549200637631L

private boolean finished=false

private long cellsUsed

final int[][] matrix

private final WriteThread[] writers=new WriteThread[numArrays]

final int hashes

final int wordsPerArray

private final long cellsPerArray

final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private final long[][] buffers=new long[numArrays][1000]

private final int[] bufferlen=new int[numArrays]

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

static final long[] poison=new long[0]

private static long counter=0


#Methods
public static void main(String[] args)

public KCountArray6MT(long cells_, int bits_, int gap_, int hashes_)

@Override public int read(long rawKey)

int readHashed(long key, int arrayNum)

@Override public void write(long key, int value)

@Override public void increment(long rawKey, int amt)

public void increment0(long rawKey)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public ByteBuilder toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

public long cellsUsed()

</class KCountArray6MT>
<class KCountArray7MT>
*Uses prime numbers for array lengths.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray7MT

#Fields
private static final long serialVersionUID=-8767643111803866913L

private boolean finished=false

private long cellsUsed

final int[][] matrix

private final WriteThread[] writers=new WriteThread[numArrays]

private final int hashes

final int wordsPerArray

private final long cellsPerArray

final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private final long[][] buffers=new long[numArrays][500]

private final int[] bufferlen=new int[numArrays]

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

static final long[] poison=new long[0]

private static long counter=0


#Methods
public static void main(String[] args)

public KCountArray7MT(long cells_, int bits_, int hashes_)

private static int getDesiredArrays(long desiredCells, int bits)

private static long getPrimeCells(long desiredCells, int bits)

@Override public int read(long rawKey)

private int readHashed(long key)

@Override public void write(long key, int value)

@Override public void increment(long[] keys)

@Override public void increment(long rawKey, int amt)

public void increment0(long rawKey)

private void incrementPartiallyHashed(long pKey)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public ByteBuilder toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

public long cellsUsed()

</class KCountArray7MT>
<class KCountArray7MTA>
*Uses prime numbers for array lengths.
*Uses atomic integers for concurrency control.
*Allows an optional prefilter.
*@author Brian Bushnell
*@date Aug 17, 2012
public final class KCountArray7MTA

#Fields
private static final long serialVersionUID=568264681638739631L

private boolean finished=false

private long cellsUsed=-1

private final AtomicIntegerArray[] matrix

private final int hashes

private final int wordsPerArray

private final long cellsPerArray

private final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private final int prefilterLimit

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

private KCountArray prefilter

private final boolean useLocks

private final Lock[] locks

private static final int NUM_LOCKS=1999

private static long counter=0

private static long SEEDMASK=0


#Methods
public static void main(String[] args)

public KCountArray7MTA(long cells_, int bits_, int hashes_, KCountArray prefilter_, int prefilterLimit_)

private static int getDesiredArrays(long desiredCells, int bits)

private static long getPrimeCells(long desiredCells, int bits)

@Override public final int read(long rawKey)

@Override public final int read(long[] rawKeys)

@Override public final int readLeft(long key, int k, boolean makeCanonical)

@Override public final int readRight(long key, int k, boolean makeCanonical)

@Override public final int[] readAllLeft(long key, int k, boolean makeCanonical, int[] rvec)

@Override public final int[] readAllRight(long key, int k, boolean makeCanonical, int[] rvec)

private final int readHashed(long key)

@Override public final void write(long key, int value)

@Override public final void increment(long[] keys)

@Override public final void increment(long rawKey, int amt)

@Override public final void decrement(long rawKey, int amt)

@Override public int incrementAndReturnUnincremented(long rawKey, int incr)

private int incrementAndReturnUnincrementedLocked(long rawKey, int incr)

private int incrementAndReturnUnincrementedUnlocked(long rawKey, int incr)

@Override public int incrementAndReturnUnincremented(long[] rawKeys, int incr)

@Override public long[] transformToFrequency()

@Override public ByteBuilder toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

public long cellsUsedMT(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

private final Lock getLock(long rawKey)

private int incrementHashedLocal(long key, int amt)

private int incrementHashedLocal_toAtLeast(long key, int newMin)

private int incrementHashedLocalAndReturnUnincremented(long key, int incr)

private int incrementHashedLocalAndReturnUnincremented_toAtLeast(long key, int newMin)

private int decrementHashedLocal(long key, int amt)

public long cellsUsed()

@Override public KCountArray prefilter()

@Override public void purgeFilter()

public static void setSeed(long seed)

</class KCountArray7MTA>
<class KCountArray8MT>
*Uses prime numbers for array lengths.
*Supports a prefilter that is checked before looking at the main filter.
*@author Brian Bushnell
*@date Aug 17, 2012
public class KCountArray8MT

#Fields
private static final long serialVersionUID=-3146298383509476887L

private boolean finished=false

private long cellsUsed

final int[][] matrix

private final WriteThread[] writers=new WriteThread[numArrays]

private final int hashes

final int wordsPerArray

private final long cellsPerArray

final long cellMod

private final long[][] hashMasks=makeMasks(8,hashArrayLength)

private final long[][] buffers=new long[numArrays][500]

private final int[] bufferlen=new int[numArrays]

public final KCountArray prefilter

private static final int hashBits=6

private static final int hashArrayLength=1 << hashBits

private static final int hashCellMask=hashArrayLength - 1

static final long[] poison=new long[0]

private static long counter=0


#Methods
public KCountArray8MT(long cells_, int bits_, int hashes_, KCountArray prefilter_)

private static int getDesiredArrays(long desiredCells, int bits)

private static long getPrimeCells(long desiredCells, int bits)

@Override public int read(long rawKey)

private int readHashed(long key)

@Override public void write(long key, int value)

@Override public void increment(long[] keys)

@Override public void increment(long rawKey, int amt)

public void increment0(long rawKey)

private void incrementPartiallyHashed(long pKey)

*Returns unincremented value
@Override public int incrementAndReturnUnincremented(long key, int incr)

@Override public long[] transformToFrequency()

@Override public ByteBuilder toContentsString()

@Override public double usedFraction()

@Override public double usedFraction(int mindepth)

@Override public long cellsUsed(int mindepth)

@Override final long hash(long key, int row)

*@param i
*@param j
*@return
private static long[][] makeMasks(int rows, int cols)

private static void fillMasks(long[] r, Random randy)

@Override public void initialize()

@Override public void shutdown()

public long cellsUsed()

</class KCountArray8MT>
<class KmerCount3>
*@author Brian Bushnell
*@date Jul 5, 2012
public class KmerCount3

#Methods
public static void main(String[] args)

public static KCountArray2 countFastq(String reads1, String reads2, int k, int cbits)

</class KmerCount3>
<class KmerCount4>
*@author Brian Bushnell
*@date Jul 5, 2012
public class KmerCount4

#Methods
public static void main(String[] args)

public static void printStatistics(KCountArray2 count)

public static KCountArray2 count(String reads1, String reads2, int k, int cbits, boolean rcomp)

public static KCountArray2 count(String reads1, String reads2, int k, int cbits, boolean rcomp, KCountArray2 count)

public static KCountArray2 countFastqSplit(String reads1, String reads2, int k1, int k2, int gap, int cbits, boolean rcomp, KCountArray2 count)

public static void addRead(Read r, KCountArray2 count, int k, long mask, boolean rcomp)

public static void addReadSplit(Read r, KCountArray2 count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

public static void addReadSplit(byte[] bases, KCountArray2 count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

</class KmerCount4>
<class KmerCount5>
*@author Brian Bushnell
*@date Jul 5, 2012
public class KmerCount5

#Methods
public static void printStatistics(KCountArray count)

public static KCountArray count(String reads1, String reads2, int k, int cbits, boolean rcomp)

public static KCountArray count(String reads1, String reads2, int k, int cbits, boolean rcomp, KCountArray count)

public static KCountArray count(String reads1, String reads2, int k, int cbits, boolean rcomp, KCountArray counts, KCountArray trusted, long maxReads, int thresh, int detectStepsize, boolean conservative)

public static KCountArray countFastqSplit(String reads1, String reads2, int k1, int k2, int gap, int cbits, boolean rcomp, KCountArray counts)

public static void addRead(Read r, KCountArray count, int k, long mask, boolean rcomp)

public static void addReadSplit(Read r, KCountArray count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

public static void addReadSplit(byte[] bases, KCountArray count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

</class KmerCount5>
<class KmerCount6>
*@author Brian Bushnell
*@date Jul 5, 2012
public class KmerCount6

#Methods
public static void printStatistics(KCountArray count)

public static KCountArray count(String reads1, String reads2, int k, int cbits, boolean rcomp, KCountArray count)

public static void count(ConcurrentReadInputStream cris, int k, boolean rcomp, KCountArray count)

public static KCountArray count(String reads1, String reads2, int k, int cbits, boolean rcomp, KCountArray count, KCountArray trusted, long maxReads, int thresh, int detectStepsize, boolean conservative)

public static void count(ConcurrentReadInputStream cris, int k, boolean rcomp, KCountArray count, KCountArray trusted, int thresh, int detectStepsize, boolean conservative)

public static void addRead(Read r, KCountArray count, int k, long mask, boolean rcomp)

public static void addReadSplit(Read r, KCountArray count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

public static void addReadSplit(byte[] bases, KCountArray count, int k1, int k2, long mask1, long mask2, int gap, boolean rcomp)

</class KmerCount6>
<class KmerCountAbstract>
*@author Brian Bushnell
*@date Dec 2, 2014
public abstract class KmerCountAbstract

#Fields
public static byte minQuality=6

public static long readsProcessed=0

public static long maxReads=-1

public static float minProb=0.5f

public static long keysCounted=0

public static long increments=0

public static final boolean verbose=false

public static boolean PREJOIN=false

public static boolean CANONICAL=false

public static boolean KEEP_DUPLICATE_KMERS=true

public static int KMERS_PER_READ=0

public static int IDMASK=0

public static int MAX_COUNT_THREADS=1024

public static boolean SKETCH_MODE=false

public static boolean STORE_HASHED=false

public static boolean BUFFERED=false

public static int BUFFERLEN=3000

public static int maxShortKmerLength=31


#Methods
protected static final long[] transformToFrequency(int[] count)

protected static final long sum(int[] array)

protected static final long sum(long[] array)

protected static final int min(int x, int y)

protected static final int max(int x, int y)

</class KmerCountAbstract>
<class LargeKmerCount>
*@author Brian Bushnell
*@date Jul 6, 2012
public class LargeKmerCount

#Fields
public static boolean verbose=true

public static byte minQuality=-5

public static long readsProcessed=0

public static long maxReads=1000000L

public static final int ROTATE_DIST=2

public static long collisionsA=0

public static long collisionsB=0


#Methods
public static KCountArray2 countFastq(String reads1, String reads2, int indexbits, int cbits, int k)

public static final long[] makeRotMasks(int rotDist)

public static long[] transformToFrequency(int[] count)

public static long sum(int[] array)

public static long sum(long[] array)

public static final int min(int x, int y)

public static final int max(int x, int y)

</class LargeKmerCount>
<class LargeKmerCount2>
*@author Brian Bushnell
*@date Jul 6, 2012
public class LargeKmerCount2

#Fields
public static boolean verbose=true

public static byte minQuality=-5

public static long readsProcessed=0

public static long maxReads=10000000L

public static final int ROTATE_DIST=2

*Non-empty cells in hash table
public static long load

*Number of expected collisions
public static double expectedCollisions

*Number of actual collisions (possibly by same value)
public static long actualCollisions

*Number of probable collisions caused by new keys
public static double probNewKeyCollisions

*Inverse of hash table size
public static double invCells

*Inverse of number of potential kmers
public static double invKmerSpace

*Inverse of number of potential kmers
public static long keysCounted

public static final Random randy=new Random(1)


#Methods
public static void main(String[] args)

public static KCountArray2 countFastq(String reads1, String reads2, int indexbits, int cbits, int k)

public static final long[] makeRotMasks(int rotDist)

public static long[] transformToFrequency(int[] count)

public static long sum(int[] array)

public static long sum(long[] array)

public static final int min(int x, int y)

public static final int max(int x, int y)

public static final long min(long x, long y)

public static final long max(long x, long y)

public static final double min(double x, double y)

public static final double max(double x, double y)

</class LargeKmerCount2>
<class ParseBloomFilter>
*Reads a text file.
*Prints it to another text file.
*Filters out invalid lines and prints them to an optional third file.
*@author Brian Bushnell
*@date May 9, 2016
public class ParseBloomFilter

#Fields
private String in1=null

private String out1=null

private String outInvalid=null

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

private final FileFormat ffin1

private final FileFormat ffout1

private final FileFormat ffoutInvalid

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public ParseBloomFilter(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private void processInner(ByteFile bf, ByteStreamWriter bsw, ByteStreamWriter bswInvalid)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class ParseBloomFilter>
<class PolyFilter>
*Filters reads with artificial homopolymers.
*@author Brian Bushnell
*@date August 21, 2024
public class PolyFilter

#Fields
private ArrayList<String> ref=new ArrayList<String>()

private ArrayList<String> extra=new ArrayList<String>()

*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Output file path for bad reads
private String outbad1=null

*Secondary output file path for bad reads
private String outbad2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*For calculating kmer cardinality in output
final CardinalityTracker loglogOut

*Number of reads processed
public long readsProcessed=0

*Number of bases processed
public long basesProcessed=0

*Number of reads trimmed
public long readsTrimmed=0

*Number of bases trimmed
public long basesTrimmed=0

protected long readsMerged=0

*Number of reads retained
public long readsOut=0

*Number of bases retained
public long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

public static long lastReadsOut=-1

public static long lastReadsRemoved=-1

public static long lastBasesOut=-1

public static long lastBasesRemoved=-1

*Primary input file
final FileFormat ffin1

*Secondary input file
final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary output file for matching reads
private final FileFormat ffoutm1

*Secondary output file for matching reads
private final FileFormat ffoutm2

final BloomFilter filter

final int kbloom

final int ksmall

final int hashes

final int bits

final boolean rcomp

final boolean tossjunk

final boolean merge

int junkWidth=1

float memFraction=1.0f

float maxLoad=1.0f

int trimLeft=6

int trimRight=6

int minLength=50

int maxNonPoly=2

int kpoly=29

int hdist=2

long midMask=-1

long kmerMask=-1

boolean maskMiddle=true

LongHashSet set=null

int minCount=2

float lowCountFraction=0.24f

float lowCountFraction2=1.1f

int minPolymer=20

int minPolymer2=29

float entropyCutoff=0.67f

float entropyCutoff2=0.20f

float qualityCutoff=12.5f

float qualityCutoff2=7.5f

float nonPolyFraction=1 - 0.85f

byte[] polymers="GC".getBytes()

byte[] trimPolymers=null

long[] polymerFlagged

long entropyFlagged

long qualityFlagged

long depthFlagged

boolean entropyHighpass=true

*Quantize quality scores to reduce file size
boolean quantizeQuality=false

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public PolyFilter(String[] args)

private static void addFiles(String b, ArrayList<String> list)

private static final int parseIntOrBool(String b, int defaultTrue, int defaultFalse)

public static long makeMidMask(boolean maskMiddle, int k)

public static LongHashSet makeSet(byte[] polymers, int k, int hdist, long midMask)

public static void addToSet(long kmer, long k, long midMask, int hdist, LongHashSet set)

public static boolean kmerScan(Read r, int k, long kmerMask, long midMask, LongHashSet set)

*Create read streams and process all data
public void process(Timer t)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public ReadWriteLock rwlock()

*Calculate the length of the longest homopolymer region in this sequence,
*allowing a specified error rate, using the Phred algorithm.
*There may be longer regions, but they will have flanking subregions with
*greater than the specified error rate.
*@param bases Sequence to examine.
*@param mer Subunit of the homopolymer to count (e.g. 'G').
*@param nonFraction Maximal allowed fraction of nonmatching bases in the region.
*@return Length of the longest homopolymer.
public static int polymerLen_old(byte[] bases, byte mer, float nonFraction)

public static int polymerLen(byte[] bases, byte mer, float nonFraction)

*Calculate the length of the longest homopolymer in this sequence.
*@param bases Sequence to examine.
*@param mer Subunit of the homopolymer to count (e.g. 'G').
*@return Length of the longest homopolymer.
public static int polymerLen(byte[] bases, byte mer)

public int trimRead(Read r)

</class PolyFilter>
<class PolyFilter.ProcessThread>
class PolyFilter.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

protected long readsTrimmedT=0

protected long basesTrimmedT=0

protected long readsMergedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Matched output stream
private final ConcurrentReadOutputStream rosb

*Thread ID
final int tid

final EntropyTracker eTracker

final long[] polymerFlaggedT=new long[polymers.length]

long entropyFlaggedT=0

long qualityFlaggedT=0

long depthFlaggedT=0


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, ConcurrentReadOutputStream rosb_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

private boolean isJunk(Read r, int insert)

</class PolyFilter.ProcessThread>
<class ReadCounter>
*@author Brian Bushnell
*@date Jul 5, 2012
public class ReadCounter

#Fields
public int detectStepsize=1

private final int k

private final int k2

private final int aminoShift

private final int shift

private final int shift2

private final long mask

private final boolean rcomp

private final boolean ecco

private final boolean merge

private final boolean amino

public static boolean vstrict=false


#Methods
public static void main(String[] args)

*Defaults for nucleotides.
public ReadCounter(int k_)

public ReadCounter(int k_, boolean rcomp_, boolean ecco_, boolean merge_, boolean amino_)

public void printStatistics(KCountArray counts)

public KCountArray makeKca_als(ArrayList<String> fname1, ArrayList<String> fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, int minqual, long maxreads, int passes, int thresh1, int thresh2, KCountArray prefilter, int prefilterLimit_)

public KCountArray makeKca(String fname1, String fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, KCountArray prefilter, int prefilterLimit)

public KCountArray makeKca(String fname1, String fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, int minqual, long maxreads, int passes, int thresh1, int thresh2, KCountArray prefilter, int prefilterLimit_)

public KCountArray count(String reads1, String reads2, KCountArray counts)

public KCountArray count(String reads1, String reads2, int cbits, KCountArray counts, KCountArray trusted, long maxReads, int thresh, boolean conservative)

private final int findOverlap(Read r1, Read r2, boolean ecc)

*Generate a kmer from specified start location
*@param bases
*@param start
*@param klen kmer length
*@return kmer
public static final long toKmer(byte[] bases, int start, int klen)

</class ReadCounter>
<class ReadCounter_old>
*@author Brian Bushnell
*@date Jul 5, 2012
public class ReadCounter_old

#Fields
public static boolean vstrict=false

private final int k

private final int aminoShift

private final int shift

private final int shift2

private final long mask

private final boolean rcomp

private final boolean ecco

private final boolean merge

private final boolean amino


#Methods
*Defaults for nucleotides.
public ReadCounter_old(int k_)

public ReadCounter_old(int k_, boolean rcomp_, boolean ecco_, boolean merge_, boolean amino_)

public void printStatistics(KCountArray counts)

public KCountArray makeKca_als(ArrayList<String> fname1, ArrayList<String> fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, int minqual, long maxreads, int passes, int stepsize, int thresh1, int thresh2, KCountArray prefilter, int prefilterLimit_)

public KCountArray makeKca(String fname1, String fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, KCountArray prefilter, int prefilterLimit)

public KCountArray makeKca(String fname1, String fname2, Iterable<String> extraFiles, int cbits, long cells, int hashes, int minqual, long maxreads, int passes, int stepsize, int thresh1, int thresh2, KCountArray prefilter, int prefilterLimit_)

public KCountArray count(String reads1, String reads2, KCountArray counts)

public KCountArray count(String reads1, String reads2, int cbits, KCountArray counts, KCountArray trusted, long maxReads, int thresh, int detectStepsize, boolean conservative)

private final int findOverlap(Read r1, Read r2, boolean ecc)

</class ReadCounter_old>
<class TestLargeKmer>
*@author Brian Bushnell
*@date Jul 5, 2012
public class TestLargeKmer

#Fields
public static final int BOUND_LEN=256


#Methods
public static void main(String args)

public static long[] countK2(String fname1, String fname2, int k, int cbits, int k2)

public static long[] countK2(String fname1, String fname2, int k, KCountArray2 counts1, int k2)

public static final int min(int x, int y)

public static final int max(int x, int y)

</class TestLargeKmer>
