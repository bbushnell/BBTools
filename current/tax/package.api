#version 1
#package tax
#generated 2025-09-06T20:39:10

<class AccessionToTaxid>
*New version loads with multiple threads per input file.
*@author Brian Bushnell
*@date December 16, 2016
public class AccessionToTaxid

#Fields
private ArrayList<String> in=new ArrayList<String>()

static int maxPigzProcesses=12

private long linesProcessed=0

private long linesValid=0

private long bytesProcessed=0

private AtomicLongArray lengthCounts=null

private AtomicLongArray symbolCounts=null

private AtomicLongArray counts_underscore=null

private AtomicLongArray counts_underscore2=null

private final FileFormat ffin

private static boolean LOADED=false

private static HashMap<String,Integer>[] maps=null

private static KmerTableSet tables

private static LongLongHashMap imgCache

private static final long cacheClearInterval=7L * 24L * 3600L* 1000L

private static long lastCacheClear=0

public static TaxTree tree=null

public static final boolean USE_TABLES=true

public static boolean skipParse=false

public static boolean skipHash=false

public static float prealloc=0

private static final long offset=-'A' + 11

private static final long offsetLower=-'a' + 11

public static int serverNum=0

public static int serverCount=1

public static boolean distributed=false

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true


#Methods
public static void load(String files)

public static void main(String[] args)

public AccessionToTaxid(String[] args)

@SuppressWarnings void process(Timer t)

*Spawn process threads
private void spawnThreads(FileFormat[] ffa, int threadLimit)

private static void accumulate(AtomicLongArray a, long[] b)

public static int get(String accession)

public static boolean isValidAccession(String s)

static long hash(String accession)

static long hash(byte[] line, int limit)

public static int parseLineToTaxid(byte[] line, byte delimiter)

public static int parseLineToTaxid_2col(byte[] line, byte delimiter)

public static int getImg(long imgID)

public static int getImgFromServer(long imgID)

public static boolean LOADED()

</class AccessionToTaxid>
<class AccessionToTaxid.HashThread>
public static class AccessionToTaxid.HashThread

#Fields
private long linesProcessedT=0

private long linesValidT=0

private long bytesProcessedT=0

final ByteFile bf

HashMap<String,Integer>[] mapsT

HashBuffer table

boolean success=false

private long[] lengthCountsT=null

private long[] symbolCountsT=null

private long[] counts_underscoreT=null

private long[] counts_underscore2T=null


#Methods
@SuppressWarnings public HashThread(ByteFile bf_)

ArrayList<byte[]> fetch(int limit)

@Override public void run()

@Deprecated public boolean parseLine(byte[] line, byte delimiter)

public boolean parseLine2(byte[] line, byte delimiter)

</class AccessionToTaxid.HashThread>
<class AccessionToTaxid_old>
*@author Brian Bushnell
*@date December 16, 2016
public class AccessionToTaxid_old

#Fields
private ArrayList<String> in=new ArrayList<String>()

static int maxPigzProcesses=12

private long linesProcessed=0

private long linesValid=0

private long bytesProcessed=0

private AtomicLongArray lengthCounts=null

private AtomicLongArray symbolCounts=null

private AtomicLongArray counts_underscore=null

private AtomicLongArray counts_underscore2=null

private final FileFormat ffin

private static boolean LOADED=false

private static HashMap<String,Integer>[] maps=null

private static KmerTableSet tables

public static TaxTree tree=null

public static final boolean USE_TABLES=true

public static boolean skipParse=false

public static boolean skipHash=false

public static float prealloc=0

private static final long offset=-'A' + 11

private static final long offsetLower=-'a' + 11

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true


#Methods
public static void load(String files)

public static void main(String[] args)

public AccessionToTaxid_old(String[] args)

@SuppressWarnings void process(Timer t)

*Spawn process threads
private void spawnThreads(FileFormat[] ffa)

private static void accumulate(AtomicLongArray a, long[] b)

public static int get(String accession)

public static boolean isValidAccession(String s)

static long hash(String accession)

static long hash(byte[] line, int limit)

public static int parseLineToTaxid(byte[] line, byte delimiter)

public static boolean LOADED()

</class AccessionToTaxid_old>
<class AccessionToTaxid_old.HashThread>
public static class AccessionToTaxid_old.HashThread

#Fields
private long linesProcessedT=0

private long linesValidT=0

private long bytesProcessedT=0

final FileFormat ff

HashMap<String,Integer>[] mapsT

HashBuffer table

boolean success=false

private long[] lengthCountsT=null

private long[] symbolCountsT=null

private long[] counts_underscoreT=null

private long[] counts_underscore2T=null


#Methods
@SuppressWarnings public HashThread(FileFormat ff_)

@Override public void run()

public boolean parseLine(byte[] line, byte delimiter)

public boolean parseLine2(byte[] line, byte delimiter)

</class AccessionToTaxid_old.HashThread>
<class AnalyzeAccession>
*Counts patterns in Accessions.
*Handles hashing for Accession to TaxID lookups.
*@author Brian Bushnell
*@date May 9, 2018
public class AnalyzeAccession

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out=null

private boolean perFile=true

private HashMap<String,StringNum> countMap=new HashMap<String,StringNum>()

public static HashMap<String,Integer> codeMap

private static int codeBits=-1

private static int longestPattern=-1

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private final FileFormat[] ffina

private final FileFormat ffout

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

private static final byte[] remap=makeRemap()

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public AnalyzeAccession(String[] args)

void process(Timer t)

void process_inner(FileFormat ffin)

void process_perFile()

@Override public void accumulate(ProcessThread t)

@Override public boolean success()

public static long combos(String s)

public static long combos(byte[] s)

public static HashMap<String,Integer> loadCodeMap(String fname)

public static long digitize(String s)

public static long digitize(byte[] s)

public static String remap(String s)

public static String remap(byte[] s)

@Override public final ReadWriteLock rwlock()

private static byte[] makeRemap()

</class AnalyzeAccession>
<class AnalyzeAccession.ProcessThread>
static class AnalyzeAccession.ProcessThread

#Fields
private HashMap<String,StringNum> countMapT=new HashMap<String,StringNum>()

private final ByteFile bf

long linesProcessedT=0

long linesOutT=0

long bytesProcessedT=0


#Methods
ProcessThread(ByteFile bf_)

@Override public void run()

void increment(byte[] line, StringBuilder buffer)

</class AnalyzeAccession.ProcessThread>
<class AnalyzeAccession_ST>
*Counts patterns in Accessions.
*Handles hashing for Accession to TaxID lookups.
*@author Brian Bushnell
*@date May 9, 2018
public class AnalyzeAccession_ST

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out=null

private HashMap<String,StringNum> countMap=new HashMap<String,StringNum>()

public static HashMap<String,Integer> codeMap

private static int codeBits=-1

private static int longestPattern=-1

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

private final FileFormat[] ffina

private final FileFormat ffout

private static final byte[] remap=makeRemap()

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public AnalyzeAccession_ST(String[] args)

void process(Timer t)

void process_inner(FileFormat ffin)

void increment(byte[] line, StringBuilder buffer)

public static long combos(String s)

public static long combos(byte[] s)

public static HashMap<String,Integer> loadCodeMap(String fname)

public static long digitize(String s)

public static long digitize(byte[] s)

public static String remap(String s)

public static String remap(byte[] s)

private static byte[] makeRemap()

</class AnalyzeAccession_ST>
<class CanonicalLineage>
public class CanonicalLineage

#Fields
public final int taxID

public final int levelsDefined

*Holds nodes for the 7 standard taxonomic levels
final TaxNode[] nodes=new TaxNode[7]

private static final String[] prefixes={"k__","p__","c__","o__","f__","g__","s__"}


#Methods
*Produces e.g. k__something;p__something, etc
*kpcofgs levels must all be present.
*Missing values should use NA, e.g. k__NA;
*@param TaxID Taxonomy ID to get lineage for
*@param tree Taxonomy tree to use
public CanonicalLineage(int tid, TaxTree tree)

*Converts the lineage to a ByteBuilder with DADA2 format.
*@return ByteBuilder containing the formatted lineage
public ByteBuilder toBytes()

public String toString()

</class CanonicalLineage>
<class ExplodeTree>
*Constructs a directory and file tree of sequences
*corresponding to a taxonomic tree.
*@author Brian Bushnell
*@date December 12, 2017
public class ExplodeTree

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String outPath=null

private String prefix

*Override input file extension
private String extin=null

*For listing what is present in the output
public String resultsFile=null

public String taxTreeFile=null

public boolean makeDirectories=true

public LinkedHashMap<TaxNode,Long> nodes=new LinkedHashMap<TaxNode,Long>()

*Number of reads processed
protected long readsProcessed=0

*Number of lines processed
protected long linesProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads out
public long readsOut=0

*Number of lines out
public long linesOut=0

*Number of bases out
public long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

private final TaxTree tree

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public ExplodeTree(String[] args)

public void makeDirectoryTree(String root, boolean writeNames)

*Create read streams and process all data
public void process(Timer t)

*Iterate through the reads
void processInner()

</class ExplodeTree>
<class FilterByTaxa>
*Filters sequences according to their taxonomy,
*as determined by the sequence name. Sequences should
*be labeled with a gi number or NCBI taxID.
*@author Brian Bushnell
*@date November 23, 2015
public class FilterByTaxa

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*The actual filter
private final TaxFilter filter

*Recur at a higher level until some sequence matches. Intended for include mode.
public boolean bestEffort=false

*For listing what is present in the output
public String resultsFile=null

public LinkedHashSet<TaxNode> nodes=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads out
public long readsOut=0

*Number of bases out
public long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public FilterByTaxa(String[] args)

*Create read streams and process all data
public void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

</class FilterByTaxa>
<class FindAncestor>
*@author Brian Bushnell
*@date May 9, 2016
public class FindAncestor

#Fields
private String in1=null

private String out1=null

private String outInvalid=null

private String giTableFile=null

private String taxTreeFile=null

private final TaxTree tree

private final TaxNode lifeNode

private long taxaCounted=0

private long taxaValid=0

private long linesProcessed=0

private long linesValid=0

private long bytesProcessed=0

private long maxLines=Long.MAX_VALUE

private boolean countTable=true

private final String prefix="gi|"

private final FileFormat ffin1

private final FileFormat ffout1

private final FileFormat ffoutInvalid

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public FindAncestor(String[] args)

void process(Timer t)

private void fillTraversal(int id, IntList traversal, boolean addLife)

private void writeTraversal(IntList traversal, ByteBuilder bb)

private int getGiNumbers(byte[] line, IntList list, char delimiter)

private static int getTaxidNumbers(IntList giList, IntList ncbiList)

private int findAncestor(IntList list)

public static int findAncestor(TaxTree tree, IntList list)

private int findMajority(IntList list)

</class FindAncestor>
<class GiToTaxid>
*@author Brian Bushnell
*@date Mar 10, 2015
public class GiToTaxid

#Fields
private static long maxGiLoaded=-1

private static int[][] array

private static final int SHIFT=30

private static final long UPPERMASK=(-1L) << SHIFT

private static final long LOWERMASK=~UPPERMASK

private static String fileString

public static boolean verbose=false

private static boolean initialized=false


#Methods
public static void main(String[] args)

public static void test(String[] args)

public static int parseGiToTaxid(String s)

public static int parseGiToTaxid(String s, char delimiter)

public static int parseGiToTaxid(byte[] s)

public static int parseGiToTaxid(byte[] s, char delimiter)

*Parse a gi number, or return -1 if formatted incorrectly.
static long parseGiNumber(String s, char delimiter)

*Parse a ncbi number, or return -1 if formatted incorrectly.
public static int parseTaxidNumber(String s, char delimiter)

public static int getID(String s)

*Get the taxID from a header starting with a taxID or gi number
public static int getID(String s, char delimiter)

*Parse a gi number, or return -1 if formatted incorrectly.
static long parseGiNumber(byte[] s, char delimiter)

*Parse a taxID number, or return -1 if formatted incorrectly.
static int parseNcbiNumber(byte[] s, char delimiter)

public static int getID(byte[] s)

*Get the taxID from a header starting with a taxID or gi number
public static int getID(byte[] s, char delimiter)

*Get the taxID from a gi number;
*-1 if not present or invalid (negative input),
*-2 if out of range (too high)
public static int getID(long gi)

*Get the taxID from a gi number;
*0 if not present,
*-1 if invalid (negative input),
*-2 if out of range (too high)
public static int getID(long gi, boolean assertInRange)

public static void initialize(String fname)

public static boolean isInitialized()

public static void unload()

private static int[][] makeArray(String fnames)

private static long addToList(String fname, IntList[] lists)

private static int getID(long gi, IntList[] lists)

private static int setID(long gi, int tid, IntList[] lists)

</class GiToTaxid>
<class GiToTaxidInt>
*@author Brian Bushnell
*@date Mar 10, 2015
public class GiToTaxidInt

#Fields
private static int[] array

private static String fileString

public static boolean verbose=false

private static boolean initialized=false


#Methods
public static int parseGiToTaxid(byte[] s)

public static int parseGiToTaxid(byte[] s, char delimiter)

*Parse a gi number, or return -1 if formatted incorrectly.
static int parseGiNumber(String s, char delimiter)

*Parse a ncbi number, or return -1 if formatted incorrectly.
public static int parseTaxidNumber(String s, char delimiter)

public static int getID(String s)

*Get the taxID from a header starting with a taxID or gi number
public static int getID(String s, char delimiter)

*Parse a gi number, or return -1 if formatted incorrectly.
static int parseGiNumber(byte[] s, char delimiter)

*Parse a gi number, or return -1 if formatted incorrectly.
static int parseNcbiNumber(byte[] s, char delimiter)

public static int getID(byte[] s)

*Get the taxID from a header starting with a taxID or gi number
public static int getID(byte[] s, char delimiter)

*Get the taxID from a gi number
public static int getID(long gi)

public static boolean isInitialized()

public static void unload()

private static int[] makeArray(String fnames)

private static long addToList(String fname, IntList list)

</class GiToTaxidInt>
<class IDNode>
*Support class for IDTree.
*@author Brian Bushnell
*@date July 1, 2016
public class IDNode

#Fields
public String name

public double[] array

public final int number

public final int maxPos

public final double max

public final BitSet bs

public IDNode parent

public final IDNode left

public final IDNode right


#Methods
public static IDNode makeTree(IDNode[] nodes)

@Override public int compareTo(IDNode idn)

public IDNode(double[] array_, int number_, String name_)

double[] shorter(double[] a, double[] b)

double[] longer(double[] a, double[] b)

public IDNode(IDNode a, IDNode b, int number_)

public StringBuilder toNewick()

private void toNewick(StringBuilder sb)

@Override public String toString()

private static String toString(double[] array)

</class IDNode>
<class IDTree>
*Creates a taxonomic tree from an identity matrix.
*@author Brian Bushnell
*@date July 1, 2016
public class IDTree

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Number of lines processed
protected long linesProcessed=0

protected long maxLines=-1

*Primary input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffout1

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public IDTree(String[] args)

*Create read streams and process all data
void process(Timer t)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

</class IDTree>
<class ImgRecord>
public class ImgRecord

#Fields
private static final long serialVersionUID=6438551103300423985L

public final long imgID

public final int taxID

public final int genomeType

public final boolean isPublic

public final boolean obsolete

public final boolean highQuality

public final String name

final int ISOLATE=0

final int SINGLE_CELL=1

final int METAGENOME=2

final String[] typeArray={"isolate","single_cell","metagenome"}

public static boolean storeName=true

public static HashMap<Long,ImgRecord> imgMap

public static final String DefaultDumpFile="/global/u1/i/img/adhocDumps/taxonDumpForBrian.txt"


#Methods
public static void main(String[] args)

private static void writeAsText(HashMap<Long,ImgRecord> map, String out)

@Override public String toString()

public static HashMap<Long,ImgRecord> toMap(String fname, boolean highQuality)

public static ImgRecord[] toArray(String fname, boolean highQuality)

public ImgRecord(String line)

public final String path()

private static int find(String s, String[] array)

</class ImgRecord>
<class ImgRecord2>
public class ImgRecord2

#Fields
private static final long serialVersionUID=8596055205924485293L

public static boolean storeName=true

public final long imgID

public final int taxID

public final String name


#Methods
public static void main(String[] args)

public static HashMap<Long,ImgRecord2> toMap(String fname)

public static ImgRecord2[] toArray(String fname)

public ImgRecord2(String line)

public static final long parseImgId(String header, boolean doAssertions)

</class ImgRecord2>
<class Lineage>
public class Lineage

#Fields
public String line

int tid=-1

int level=-1

public final TaxNode[] nodes=new TaxNode[TaxTree.LIFE + 1]


#Methods
public Lineage(String line_)

public Lineage(int tid_)

public void set(int tid_)

public int parse(String line_)

public void clear()

</class Lineage>
<class PrintTaxonomy>
*Filters sequences according to their taxonomy,
*as determined by the sequence name. Sequences should
*be labeled with a gi number or NCBI taxID.
*@author Brian Bushnell
*@date November 23, 2015
public class PrintTaxonomy

#Fields
*Optional input file path
private String in1=null

*Primary output file path
private String out1="stdout.txt"

private String countFile=null

private String giTableFile=null

private String taxTreeFile=null

private String accessionFile=null

private final TaxTree tree

private final int taxLevelExtended

private final int minLevelExtended

private final int maxLevelExtended

*Reverse order for tax lines
private boolean reverseOrder=true

private ArrayList<String> names=new ArrayList<String>()

private long maxReads=-1

boolean printName=true

boolean skipNonCanonical=false

int keyColumn=-1

*Optional input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffout1

private final FileFormat ffcount

private final TaxNode unknown=new TaxNode(-99,-99,TaxTree.LIFE,TaxTree.LIFE_E,"UNKNOWN")

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public PrintTaxonomy(String[] args)

*Create read streams and process all data
void process(Timer t)

*Iterate through the names
void processNames(TextStreamWriter tsw)

*Iterate through the names
void processFile(TextFile tf, TextStreamWriter tsw)

*Iterate through the names
void processReads(TextStreamWriter tsw)

String translateLine(String line, int col)

void printTaxonomy(String name, TextStreamWriter tsw)

void printTaxLevel(String name, TextStreamWriter tsw)

void printTaxonomy(TaxNode tn, TextStreamWriter tsw)

public static StringBuilder makeTaxLine(TaxTree tree, TaxNode tn, int minLevelE, int maxLevelE, boolean skipNonCanonical, boolean reverseOrder)

public static void printTaxonomy(TaxNode tn, ByteBuilder sb, TaxTree tree, int maxLevel, boolean skipNonCanonical)

void printTaxLevel(TaxNode tn, TextStreamWriter tsw)

public TaxNode parseNodeFromHeader(String header)

</class PrintTaxonomy>
<class Query>
public class Query

#Methods
*For testing throughput
public static void main(String[] args)

public static int[] getGi(String args)

public static int[] getAccession(String args)

public static int[] get(String type, String args)

public static String request(String x)

public static InputStream toStream(String x)

</class Query>
<class RenameGiToTaxid>
*@author Brian Bushnell
*@date Mar 10, 2015
public class RenameGiToTaxid

#Fields
private LinkedHashSet<String> in1=new LinkedHashSet<String>()

private String out1=null

private String outInvalid=null

private String badHeaders=null

private String taxTreeFile=null

private String giTableFile=null

private String accessionFile=null

private String patternFile=null

private long maxReads=-1

private long validReads=0

private long validBases=0

private long invalidReads=0

private long invalidBases=0

private long taxaCounted=0

private long linesIn=0

private long validLines=0

private long invalidLines=0

private long maxStoredBytes=10000000

private long readsProcessed=0

private long basesProcessed=0

private boolean prefix=true

private boolean countTable=true

private boolean keepAll=true

private boolean shrinkNames=false

private boolean warnBadHeaders=true

private boolean useServer=false

*Crash if the number of invalid headers exceeds this
private long maxInvalidHeaders=-1

*Delete the output file if there are any invalid headers
private boolean deleteInvalid=false

private int mode

private static final int ACCESSION_MODE=0

private static final int GI_MODE=1

private static final int HEADER_MODE=2

private static final int UNITE_MODE=3

private boolean gffIn=false

private final ArrayList<FileFormat> ffin1

private final FileFormat ffout1

private final FileFormat ffoutInvalid

private final TaxTree tree

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private static byte[] title=">tid|".getBytes()

private static byte[] invalidTitle=">tid|-1".getBytes()

private static byte[] invalidGffTitle="tid|-1".getBytes()


#Methods
public RenameGiToTaxid(String[] args)

void process(Timer t)

private void processInner(ByteFile bf, ByteStreamWriter bsw, ByteStreamWriter bswInvalid, ByteStreamWriter bswBadHeaders, HashArray1D counts, IntList ids)

private static boolean looksLikeRealAccession(byte[] line)

void appendHeaderLine(byte[] line, ByteBuilder bb)

private void updateHeadersFromServer(ArrayList<byte[]> lines, HashArray1D counts, ByteStreamWriter bswBadHeaders, int format)

private void updateHeadersFromServer_fasta(ArrayList<byte[]> lines, HashArray1D counts, ByteStreamWriter bswBadHeaders)

private int[] translateToTaxIDs(ByteBuilder bb, int terms)

private void updateHeadersFromServer_gff(ArrayList<byte[]> lines, HashArray1D counts, ByteStreamWriter bswBadHeaders)

private void processInner_server(ByteFile bf, ByteStreamWriter bsw, ByteStreamWriter bswInvalid, ByteStreamWriter bswBadHeaders, HashArray1D counts, int format)

private boolean dumpBuffer(ArrayList<byte[]> lines, boolean valid, ByteStreamWriter bsw, ByteStreamWriter bswInvalid)

</class RenameGiToTaxid>
<class RenameIMG>
*@author Brian Bushnell
*@date May 9, 2016
public class RenameIMG

#Fields
private String in1=null

private String out1=null

private String imgFile=null

private IntHashSet set=null

private int knownTaxid=0

private int unknownTaxid=0

private boolean useSet=true

private long linesProcessed=0

private long linesValid=0

private long bytesProcessed=0

private long basesProcessed=0

private long sequencesProcessed=0

private long filesProcessed=0

private long filesValid=0

private long maxLines=Long.MAX_VALUE

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public RenameIMG(String[] args)

void copyFiles(ImgRecord[] array)

void process(Timer t)

void process_inner(FileFormat ffin, ByteStreamWriter bsw, long img)

</class RenameIMG>
<class ShrinkAccession>
*@author Brian Bushnell
*@date April 4, 2017
public class ShrinkAccession

#Fields
private String in=null

private String out=null

private String giOut=null

private final FileFormat ffin

private final FileFormat ffout

private final FileFormat ffoutGi

private PrintStream outstream=System.err

public static boolean verbose=false

public static boolean KEEP_GI_NUMBERS=true

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public ShrinkAccession(String[] args)

void process(Timer t)

</class ShrinkAccession>
<class SplitByTaxa>
*Filters sequences according to their taxonomy,
*as determined by the sequence name. Sequences should
*be labeled with a gi number or NCBI taxID.
*@author Brian Bushnell
*@date November 23, 2015
public class SplitByTaxa

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*The actual filter
private int taxLevelE=TaxTree.stringToLevelExtended("phylum")

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

private final TaxTree tree

private final TaxNode unknown=new TaxNode(-99,-99,TaxTree.LIFE,TaxTree.LIFE_E,"UNKNOWN")

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public SplitByTaxa(String[] args)

*Create read streams and process all data
public void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, HashMap<String,ConcurrentReadOutputStream> map)

</class SplitByTaxa>
<class TaxApp>
public class TaxApp

#Methods
public static void main(String[] args)

@Override public void actionPerformed(java.awt.event.ActionEvent evt)

</class TaxApp>
<class TaxClient>
public class TaxClient

#Fields
public static PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public static int accessionToTaxid(String accession)

public static int accessionToTaxidSpecificServer(String path, String accession)

public static int giToTaxid(int gi)

public static int nameToTaxid(String name)

public static int headerToTaxid(String header)

public static int[] accessionToTaxidArray(String accession)

public static int[] giToTaxidArray(String gi)

public static int[] nameToTaxidArray(String name)

public static int[] headerToTaxidArray(String header)

public static int[] accessionToTaxidArray(ArrayList<String> accession)

public static int[] giToTaxidArray(ArrayList<Integer> gi)

public static int[] nameToTaxidArray(ArrayList<String> name)

public static int[] headerToTaxidArray(ArrayList<String> header)

private static final int[] splitOutput(String s)

private static final String sendAndReceive(String prefix, String message)

private static final String sendAndReceiveSpecificServer(String path, String prefix, String message)

private static String sendAndReceiveOnce(String prefix, String message)

private static String sendAndReceiveOnceSpecificServer(String path, String prefix, String message)

private static String fuse(ArrayList<?> list)

</class TaxClient>
<class TaxFilter>
*@author Brian Bushnell
*@date Nov 30, 2015
public class TaxFilter

#Fields
private TaxTree tree

*Level at which to filter
private int taxLevelE

*Branch must contain ancestors at these levels (bitflag)
private final int reqLevels

*Set of numeric NCBI TaxIDs
private HashSet<Integer> taxSet

private int maxChildLevelExtended=TaxTree.LIFE_E

private final boolean include

private boolean promote

private String regex

private final Pattern regexPattern

private String containsString

*Print status messages to this output stream
private static PrintStream outstream=System.err

*Print loading messages
static boolean PRINT_STUFF=true

public static boolean REQUIRE_PRESENT=true

public static boolean WARN_ABSENT_NODE=true

public static boolean printNodesAdded=true


#Methods
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public static TaxFilter makeFilter(String[] args)

*Constructor.
*@param tree_
public TaxFilter(TaxTree tree_, boolean include_)

*Constructor.
public TaxFilter(TaxTree tree_, int taxLevelE_, int reqLevels_, boolean include_, boolean promote_, HashSet<Integer> taxSet_, String regex_, String contains_)

*Alter taxSet and taxLevel to ensure they intersect with the file contents.
public void reviseByBestEffort(String fname)

public static boolean validArgument(String a)

private static void loadAccession(String accessionFile, TaxTree tree)

public static void loadGiTable(String fname)

public static TaxTree loadTree(String fname)

public void addNamesOrNumbers(String names, boolean promote)

public void addNameOrNumber(String s, boolean promote)

public void addNames(String names)

public boolean addName(String name)

public void addNumbers(String numbers, boolean promote)

public boolean addNumber(int taxID, boolean promote)

public boolean addNode(TaxNode tn)

public boolean passesFilter(Read r)

public boolean passesFilterByNameOnly(String name)

public boolean passesFilter(String name)

public boolean passesFilter(int id)

boolean passesFilter(TaxNode tn0)

public boolean passesFilterFast(int id)

boolean passesFilterFast(TaxNode tn0)

boolean matchesRegex(String s)

boolean containsString(String s)

public TaxFilter deepCopy()

public void clearSet()

public void makeSet()

public void setLevel(int newLevel, boolean promote)

public void promote()

public int size()

public int taxLevel()

public Integer[] taxSet()

public boolean include()

public void setTree(TaxTree tree_)

public TaxTree tree()

public void setContainsString(String s)

public String containsString()

@Override public String toString()

public boolean isEmpty()

</class TaxFilter>
<class TaxNode>
*Represents a taxonomic identifier, such as a specific genus.
*Includes the name, NCBI numeric id, parent id, and taxonomic level.
*@author Brian Bushnell
*@date Mar 6, 2015
public class TaxNode

#Fields
private static final long serialVersionUID=-4618526038942239246L

public final int id

public final String name

public int pid

public int level

public int levelExtended

public int numChildren=0

public int minParentLevelExtended=TaxTree.LIFE_E

public int maxChildLevelExtended=TaxTree.NO_RANK_E

private long flag=0

public long countRaw=0

public long countSum=0

private static final long ORIGINAL_LEVEL_MASK=63

private static final long CANON_MASK=64

public static final boolean verbose=false

public static final CountComparator countComparator=new CountComparator()


#Methods
public TaxNode(int id_, String name_)

public TaxNode(int id_, int parent_, int level_, int levelExtended_, String name_)

*@param split
*@param idx
*@return True if the node's name matches the
public boolean matchesName(String[] split, int idx, TaxTree tree)

@Override public String toString()

public boolean equals(TaxNode b)

public long incrementRaw(long amt)

public long incrementSum(long amt)

public boolean isSimple()

public boolean isSimple2()

public String levelStringExtended(boolean original)

public String levelToStringShort()

public boolean isUnclassified()

public boolean isEnvironmentalSample()

@Override public final int hashCode()

public boolean canonical()

public boolean levelChanged()

public int originalLevel()

public boolean cellularOrganisms()

int minAncestorLevelIncludingSelf()

int maxDescendantLevelIncludingSelf()

public String simpleName()

public boolean isRanked()

public void setCanonical(boolean b)

public void setOriginalLevel(int x)

*Return true if changed
boolean discussWithParent(TaxNode parent)

</class TaxNode>
<class TaxNode.CountComparator>
public static class TaxNode.CountComparator

#Methods
@Override public int compare(TaxNode a, TaxNode b)

</class TaxNode.CountComparator>
<class TaxServer>
*Server for taxonomy or Sketch queries.
*@author Shijie Yao, Brian Bushnell
*@date Dec 13, 2016
public class TaxServer

#Fields
public boolean sketchOnly=false

private HashMap<String,StringNum> versionMap=new HashMap<String,StringNum>()

private AtomicLongArray timesByCount=new AtomicLongArray(10000)

private AtomicLongArray queryCounts=new AtomicLongArray(10000)

private AtomicLong notFound=new AtomicLong(0)

private AtomicLong queries=new AtomicLong(0)

*Same IP address mask
private AtomicLong internalQueries=new AtomicLong(0)

*Local filesystem sketch
private AtomicLong localQueries=new AtomicLong(0)

private AtomicLong refQueries=new AtomicLong(0)

private AtomicLong depthQueries=new AtomicLong(0)

private AtomicLong iconQueries=new AtomicLong(0)

private AtomicLong querySketches=new AtomicLong(0)

private AtomicLong unknownChunkSingle=new AtomicLong(0)

private AtomicLong unknownChunkMulti=new AtomicLong(0)

private AtomicLong firstChunkSingle=new AtomicLong(0)

private AtomicLong firstChunkMulti=new AtomicLong(0)

private AtomicLong nthChunkSingle=new AtomicLong(0)

private AtomicLong nthChunkMulti=new AtomicLong(0)

private AtomicLong singleQueries=new AtomicLong(0)

private AtomicLong bulkQueries=new AtomicLong(0)

private AtomicLong bulkCount=new AtomicLong(0)

private AtomicLong giQueries=new AtomicLong(0)

private AtomicLong nameQueries=new AtomicLong(0)

private AtomicLong taxidQueries=new AtomicLong(0)

private AtomicLong headerQueries=new AtomicLong(0)

private AtomicLong accessionQueries=new AtomicLong(0)

private AtomicLong imgQueries=new AtomicLong(0)

private AtomicLong unknownQueries=new AtomicLong(0)

private AtomicLong silvaHeaderQueries=new AtomicLong(0)

private AtomicLong plaintextQueries=new AtomicLong(0)

private AtomicLong semicolonQueries=new AtomicLong(0)

private AtomicLong pathQueries=new AtomicLong(0)

private AtomicLong printPathQueries=new AtomicLong(0)

private AtomicLong printSizeQueries=new AtomicLong(0)

private AtomicLong childrenQueries=new AtomicLong(0)

private AtomicLong simpleQueries=new AtomicLong(0)

private AtomicLong ancestorQueries=new AtomicLong(0)

private AtomicLong usageQueries=new AtomicLong(0)

private AtomicLong bytesIn=new AtomicLong(0)

private AtomicLong bytesOut=new AtomicLong(0)

private AtomicLong elapsedTimeUsage=new AtomicLong(0)

private AtomicLong timeMeasurementsUsage=new AtomicLong(0)

private AtomicLong lastTimeUsage=new AtomicLong(0)

private AtomicLong elapsedTimeRemote=new AtomicLong(0)

private AtomicLong timeMeasurementsRemote=new AtomicLong(0)

private AtomicLong lastTimeRemote=new AtomicLong(0)

private AtomicLong elapsedTimeLocal=new AtomicLong(0)

private AtomicLong timeMeasurementsLocal=new AtomicLong(0)

private AtomicLong lastTimeLocal=new AtomicLong(0)

private AtomicLong elapsedTimeReference=new AtomicLong(0)

private AtomicLong timeMeasurementsReference=new AtomicLong(0)

private AtomicLong lastTimeReference=new AtomicLong(0)

private AtomicLong malformedQueries=new AtomicLong(0)

public boolean printIP=false

public boolean printHeaders=false

public boolean countQueries=true

public float prealloc=0

public boolean useHtml=false

*Location of GiTable file
private String giTableFile=null

*Location of TaxTree file
private String taxTreeFile="auto"

*Comma-delimited locations of Accession files
private String accessionFile=null

*Location of IMG dump file
private String imgFile=null

*Location of accession pattern file
private String patternFile=null

private String sizeFile=null

*Location of sequence directory tree
private String basePath="/global/cfs/cdirs/bbtools/tree/"

*Used for taxonomic tree traversal
private final TaxTree tree

*Maps URL Strings to numeric query types
private final HashMap<String,Integer> typeMap

*Maps common organism names to scientific names
private final HashMap<String,String> commonMap

*Hash taxonomic names for lookup
private boolean hashNames=true

private boolean hashDotFormat=true

*Kill code of prior server instance (optional)
private String oldKillCode=null

*Address of prior server instance (optional)
private String oldAddress=null

*Address of current server instance (optional)
public String domain=null

public int maxConcurrentSketchCompareThreads=8

public int maxConcurrentSketchLoadThreads=4

public int handlerThreads=-1

private final boolean distributed

private final int serverNum

private final int serverCount

private ArrayList<String> slaveAddress

public final String favIconPath=Data.findPath("?favicon.ico")

public final byte[] favIcon=ReadWrite.readRaw(favIconPath)

private final String startTime=new Date().toString()

*Listen on this port
public final int port

*Code to validate kill requests
public final String killCode

public final HttpServer httpServer

*Bit to set for plaintext query types
public static final int PT_BIT=16

*Bit to set for semicolon-delimited query types
public static final int SC_BIT=32

*Bit to set for path query types
public static final int PA_BIT=64

*Request query types
public static final int UNKNOWN=0

*Request query types
public static final int GI=1

*Request query types
public static final int NAME=2

*Request query types
public static final int TAXID=3

*Request query types
public static final int HEADER=4

*Request query types
public static final int ACCESSION=5

*Request query types
public static final int IMG=6

*Request query types
public static final int SILVAHEADER=7

*Plaintext-response query types
public static final int PT_GI=GI + PT_BIT

*Plaintext-response query types
public static final int PT_NAME=NAME + PT_BIT

*Plaintext-response query types
public static final int PT_TAXID=TAXID + PT_BIT

*Plaintext-response query types
public static final int PT_HEADER=HEADER + PT_BIT

*Plaintext-response query types
public static final int PT_ACCESSION=ACCESSION + PT_BIT

*Plaintext-response query types
public static final int PT_IMG=IMG + PT_BIT

*Plaintext-response query types
public static final int PT_SILVAHEADER=SILVAHEADER + PT_BIT

*Semicolon-response query types
public static final int SC_GI=GI + SC_BIT

*Semicolon-response query types
public static final int SC_NAME=NAME + SC_BIT

*Semicolon-response query types
public static final int SC_TAXID=TAXID + SC_BIT

*Semicolon-response query types
public static final int SC_HEADER=HEADER + SC_BIT

*Semicolon-response query types
public static final int SC_ACCESSION=ACCESSION + SC_BIT

*Semicolon-response query types
public static final int SC_IMG=IMG + SC_BIT

*Semicolon-response query types
public static final int SC_SILVAHEADER=SILVAHEADER + PT_BIT

public static final int SOURCE_REFSEQ=1

public static final int SOURCE_SILVA=2

public static final int SOURCE_IMG=3

*Generic response when asking for tax advice
public static final String TAX_ADVICE="This site does not give tax advice."

*Generic response for incorrect kill code
public static final String BAD_CODE="Incorrect code."

*Generic response for badly-formatted queries
public final String USAGE

*HTML version
public final String rawHtml

*Tool for comparing query sketches to reference sketches
public final SketchSearcher searcher=new SketchSearcher()

public final boolean hasSketches

final boolean allowRemoteFileAccess

final boolean allowLocalHost

final String addressPrefix

private boolean clearMem=true

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*Print verbose messages
public static boolean verbose2=false

*Print verbose messages
public static boolean logUsage=false

*True if an error was encountered
public boolean errorState=false


#Methods
*Command line entrance
public static void main(String[] args)

*Constructor
public TaxServer(String[] args)

*Kill a prior server instance
private void killOldInstance()

*Iterative wait for server initialization
private HttpServer initializeServer(int millis0, int iterations, boolean https)

public void returnUsage(long startTime, HttpExchange t)

public void returnUsageHtml(long startTime, HttpExchange t)

public void returnStats(long startTime, HttpExchange t)

private Sketch findRefSketch(String s)

static String getBody(HttpExchange t)

*Parse the query from the URL
static String getRParam(HttpExchange t, boolean allowPost)

*All tax queries enter here from the handler
String toResponse(boolean simple, String[] params, HttpExchange t)

*Look up common ancestor of terms
String toAncestor(int type, String[] names, boolean plaintext, boolean semicolon, boolean path, String query, boolean skipNonCanonical, boolean originalLevel, boolean printNumChildren, boolean printChildren, boolean printPath, boolean printSize, boolean printRange, boolean mononomial, int source)

JsonObject getChildren(int id, boolean originalLevel, boolean printRange, boolean mononomial)

JsonObject makeChildrenObject(ArrayList<TaxNode> list, boolean originalLevel, boolean printRange, boolean mononomial)

*Format a reply as plaintext, comma-delimited, TaxID only
String toText(int type, String[] names)

private TaxNode toNode(int type, String name)

*Format a reply as paths, comma-delimited
String toPath(int type, String[] names, int source)

*Format a reply as plaintext, semicolon-delimited, full lineage
String toSemicolon(int type, String[] names, boolean skipNonCanonical, boolean mononomial)

*Create a JsonObject from a String, including full lineage
JsonObject toJson(int type, String name, boolean skipNonCanonical, boolean originalLevel, boolean printNumChildren, boolean printChildren, boolean printPath, boolean printSize, boolean printRange, boolean mononomial, int source)

*Create a JsonObject from a TaxNode, at that level only
JsonObject toJson(TaxNode tn, boolean originalLevel, boolean printNumChildren, boolean printChildren, boolean printPath, boolean printSize, boolean printRange, boolean mononomial, int source, long img)

String toPath(TaxNode tn, int source)

String toPathIMG(long imgID)

*Convert a list of terms to a list of TaxIDs
IntList toIntList(int type, String[] names)

public static final String stripAccession(String s)

private final int imgToTaxid(String imgID)

private final int imgToTaxid(long imgID)

private int accessionToTaxid(String accession)

*Look up a TaxNode by parsing the organism name
TaxNode getTaxNodeByName(String name)

*Look up a TaxNode from the gi number
TaxNode getTaxNodeGi(long gi)

*Look up a TaxNode by parsing the full header
TaxNode getTaxNodeHeader(String header, boolean silvaMode)

*Look up a TaxNode from the ncbi TaxID
TaxNode getTaxNodeTaxid(int ncbi)

private static HashMap<String,Integer> makeTypeMap()

public static HashMap<String,String> makeCommonMap()

private String makeUsagePrefix()

private String makeUsageHtml()

private String loadRawHtml()

private String makeStats()

public String makeExtendedStats()

public String USAGE(String prefix)

public String basicStats()

public boolean incrementQueries(HttpExchange t, boolean local, boolean refMode, boolean simple, boolean ancestor, boolean plaintext, boolean semicolon, boolean path, boolean printChildren, boolean printPath, boolean printSize, int type)

String compare(ArrayList<Sketch> inSketches, DisplayParams params)

</class TaxServer>
<class TaxServer.IconHandler>
*Handles queries for favicon.ico
class TaxServer.IconHandler

#Methods
@Override public void handle(HttpExchange t)

</class TaxServer.IconHandler>
<class TaxServer.HelpHandler>
*Handles queries that fall through other handlers
class TaxServer.HelpHandler

#Methods
@Override public void handle(HttpExchange t)

</class TaxServer.HelpHandler>
<class TaxServer.StatsHandler>
*Handles queries that fall through other handlers
class TaxServer.StatsHandler

#Methods
@Override public void handle(HttpExchange t)

</class TaxServer.StatsHandler>
<class TaxServer.KillHandler>
*Handles requests to kill the server
class TaxServer.KillHandler

#Methods
@Override public void handle(HttpExchange t)

*Determines whether kill code was correct
private boolean testCode(HttpExchange t, String rparam)

</class TaxServer.KillHandler>
<class TaxServer.SketchHandler>
*Listens for sketch comparison requests
class TaxServer.SketchHandler

#Methods
@Override public void handle(HttpExchange t)

private ArrayList<Sketch> loadSketchesFromBody(String body)

private ArrayList<Sketch> loadSketchesFromFile(String fname, DisplayParams params)

</class TaxServer.SketchHandler>
<class TaxServer.TaxHandler>
*Handles taxonomy lookups
class TaxServer.TaxHandler

#Fields
*Only print nodes at canonical tax levels
public final boolean skipNonCanonical


#Methods
public TaxHandler(boolean skipNonCanonical_)

@Override public void handle(HttpExchange t)

</class TaxServer.TaxHandler>
<class TaxSize>
*Calculates the sizes sequences corresponding to TaxIDs.
*@author Brian Bushnell
*@date December 13, 2017
public class TaxSize

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out=null

*Override input file extension
private String extin=null

public String taxTreeFile=null

public IntLongHashMap sizeMap=new IntLongHashMap()

public IntLongHashMap cSizeMap=new IntLongHashMap()

public IntLongHashMap seqMap=new IntLongHashMap()

public IntLongHashMap cSeqMap=new IntLongHashMap()

public IntLongHashMap cNodeMap=new IntLongHashMap()

*Number of reads processed
protected long readsProcessed=0

*Number of lines processed
protected long linesProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads out
public long readsAssigned=0

*Number of lines out
public long linesAssigned=0

*Number of bases out
public long basesAssigned=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private boolean printEmptyNodes=true

*Primary input file
private final FileFormat ffin1

private final TaxTree tree

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public TaxSize(String[] args)

*Create read streams and process all data
public void process(Timer t)

void percolateUp()

*Iterate through the reads
void processInner()

</class TaxSize>
<class TaxTree>
*Represents a taxonomic tree.
*Usually just one of these needs to be created for a process.
*Designed for NCBI's taxdmp.zip file contents.
*@author Brian Bushnell
*@date Mar 6, 2015
public class TaxTree

#Fields
private static final long serialVersionUID=5894416521711540017L

*All nodes in the tree in a flat array, indexed by TaxiD
public final TaxNode[] nodes

*Number of nodes per normal level
public final int[] nodesPerLevel=new int[taxLevelNames.length]

*Number of nodes per extended level
public final int[] nodesPerLevelExtended=new int[taxLevelNamesExtended.length]

*Number of nodes in the tree
public final int nodeCount

*Maps old TaxIDs to new TaxIDs
public final IntHashMap mergedMap

*Arrays of all nodes at a given taxonomic level (extended)
public final TaxNode[][] treeLevelsExtended=new TaxNode[taxLevelNamesExtended.length][]

*Map of names to nodes
HashMap<String,ArrayList<TaxNode>> nameMap

*Map of lowercase names to nodes
HashMap<String,ArrayList<TaxNode>> nameMapLower

*Map of nodes to child nodes
HashMap<TaxNode,ArrayList<TaxNode>> childMap

public int minValidTaxa=0

*Infer ranks for no-rank nodes, when possible
public boolean simplify=true

*See simplify() for details, works in conjunction with simplify
public boolean reassign=true

*Discard no-rank nodes
public boolean skipNorank=false

public int inferRankLimit=0

*Number of bases assigned to this TaxID in RefSeq
private IntLongHashMap refseqSizeMap

*Number of bases assigned to this TaxID and descendants in RefSeq
private IntLongHashMap refseqSizeMapC

*Number of sequences assigned to this TaxID in RefSeq
private IntHashMap refseqSeqMap

*Number of sequences assigned to this TaxID and descendants in RefSeq
private IntLongHashMap refseqSeqMapC

*Number of descendant nodes, inclusive, for each TaxID
private IntHashMap nodeMapC

*Assign levels to unranked nodes below species level, when possible
public static boolean assignStrains=true

*Assume headers are in Silva format
public static boolean SILVA_MODE=false

*Assume headers are in Unite format
public static boolean UNITE_MODE=false

*Probably unnecessary at this point... present for legacy reasons
public static boolean CRASH_IF_NO_GI_TABLE=true

public static boolean verbose=false

public static boolean SHOW_WARNINGS=false

*Maps IMG IDs to records from the dump file
private static HashMap<Long,ImgRecord> imgMap

*Set to false if the tree is expected to be mutated.
*@TODO Remove mutable fields from the tree (like counters).
public static boolean ALLOW_SHARED_TREE=true

*Universal location of the shared TaxTree used by various classes
private static TaxTree sharedTree

*Normal, aka canonical, aka simple tax level names
private static final String[] taxLevelNames=new String[]{"no rank","subspecies","species","genus","family","order","class","phylum","kingdom","superkingdom","domain","life"}

public static final int numTaxLevelNames=taxLevelNames.length

*Definitive representation of all NCBI taxonomic level names.
*All levels used by NCBI must be present here, or parsing a new NCBI tax tree will crash.
*The first dimension maps normal ranks to extended ranks.
*Both dimensions are ordered ascending.
*@TODO Note! If this goes over 63 names it will cause a problem with getDefinedLevels().
private static final String[][] taxLevelNamesExtendedMatrix=new String[][]{{"no rank"},{"subgenotype","genotype","substrain","isolate","strain","pathotype","pathogroup","biotype","serotype","serogroup","morph","forma specialis","forma","subvariety","varietas","subspecies"},{"species"},{"species subgroup","species group","series","subsection","section","subgenus","genus"},{"subtribe","tribe","subfamily","family"},{"superfamily","parvorder","infraorder","suborder","order"},{"superorder","subcohort","cohort","infraclass","subclass","class"},{"superclass","subdivision","division","subphylum","phylum"},{"superphylum","subkingdom","kingdom"},{"superkingdom"},{"realm","domain"},{"acellular root","cellular root","life"}}

*Extended tax level names as a 1D array
private static final String[] taxLevelNamesExtended=makeNamesExtended()

*Number of extended tax levels
public static final int numTaxLevelNamesExtended=taxLevelNamesExtended.length

*Abbreviations of tax level names, mainly for semicolon form
private static final String[] taxLevelNamesShort=new String[]{"nr","ss","s","g","f","o","c","p","k","sk","d","l"}

*Normal tax level numbers as constants
public static final int NO_RANK=0

*Normal tax level numbers as constants
public static final int SUBSPECIES=1

*Normal tax level numbers as constants
public static final int SPECIES=2

*Normal tax level numbers as constants
public static final int GENUS=3

*Normal tax level numbers as constants
public static final int FAMILY=4

*Normal tax level numbers as constants
public static final int ORDER=5

*Normal tax level numbers as constants
public static final int CLASS=6

*Normal tax level numbers as constants
public static final int PHYLUM=7

*Normal tax level numbers as constants
public static final int KINGDOM=8

*Normal tax level numbers as constants
public static final int SUPERKINGDOM=9

*Normal tax level numbers as constants
public static final int DOMAIN=10

*Normal tax level numbers as constants
public static final int LIFE=11

*TaxID of Life node
public static final int LIFE_ID=1

*TaxID of Cellular Organisms node
public static final int CELLULAR_ORGANISMS_ID=131567

*TaxID of Bacteria node
public static final int BACTERIA_ID=2

*TaxID of Archaea node
public static final int ARCHAEA_ID=2157

*TaxID of Euk node
public static final int EUKARYOTA_ID=2759

*TaxID of Animal node
public static final int METAZOA_ID=33208

*TaxID of Animal node
public static final int ANIMALIA_ID=33208

*TaxID of Plant node
public static final int VIRIDIPLANTAE_ID=33090

*TaxID of Plant node
public static final int PLANTAE_ID=33090

*TaxID of Fungi node
public static final int FUNGI_ID=4751

*TaxID of Virus node
public static final int VIRUSES_ID=10239

*TaxID of Viroids node (now defunct)
public static final int VIROIDS_ID=12884

*Maps normal level names to normal level numbers
private static final HashMap<String,Integer> levelMap=makeLevelMap()

*Maps short level names to normal level numbers
private static final HashMap<String,Integer> shortLevelMap=makeShortLevelMap()

*Maps extended level names to extended level numbers
private static final HashMap<String,Integer> levelMapExtended=makeLevelMapExtended()

*Maps extended level names to normal level numbers
private static final HashMap<String,Integer> altLevelMap=makeAltLevelMap()

*Common extended level numbers as constants
public static final int NO_RANK_E=NO_RANK

*Common extended level numbers as constants
public static final int SUBSTRAIN_E=stringToLevelExtended("substrain")

*Common extended level numbers as constants
public static final int STRAIN_E=stringToLevelExtended("strain")

*Common extended level numbers as constants
public static final int SUBSPECIES_E=stringToLevelExtended("subspecies")

*Common extended level numbers as constants
public static final int SPECIES_E=stringToLevelExtended("species")

*Common extended level numbers as constants
public static final int GENUS_E=stringToLevelExtended("genus")

*Common extended level numbers as constants
public static final int FAMILY_E=stringToLevelExtended("family")

*Common extended level numbers as constants
public static final int ORDER_E=stringToLevelExtended("order")

*Common extended level numbers as constants
public static final int CLASS_E=stringToLevelExtended("class")

*Common extended level numbers as constants
public static final int PHYLUM_E=stringToLevelExtended("phylum")

*Common extended level numbers as constants
public static final int KINGDOM_E=stringToLevelExtended("kingdom")

*Common extended level numbers as constants
public static final int SUPERKINGDOM_E=stringToLevelExtended("superkingdom")

*Common extended level numbers as constants
public static final int DOMAIN_E=stringToLevelExtended("domain")

*Common extended level numbers as constants
public static final int LIFE_E=stringToLevelExtended("life")

*Map of normal to extended level numbers
private static final int[] levelToExtended=new int[]{NO_RANK_E,SUBSPECIES_E,SPECIES_E,GENUS_E,FAMILY_E,ORDER_E,CLASS_E,PHYLUM_E,KINGDOM_E,SUPERKINGDOM_E,DOMAIN_E,LIFE_E}

*Map of extended to normal level numbers
private static final int[] extendedToLevel=makeExtendedToLevel()

private static final Pattern delimiterTab=Pattern.compile("\t")

private static final Pattern delimiter=Pattern.compile("\t\\|\t")

private static final Pattern delimiterPipe=Pattern.compile("\\|")

private static final Pattern delimiterTilde=Pattern.compile("\\~")

private static final Pattern delimiter2=Pattern.compile("[\\s_]+")

public static boolean IMG_HQ=false

private static final String defaultTaxPathNersc="/global/cfs/cdirs/bbtools/tax/latest"

private static final String defaultTaxPathAws="/test1/tax/latest"

private static final String defaultTaxPathIGBVM="/data/tax/latest"

private static final String defaultTaxPathDori="/clusterfs/jgi/groups/gentech/homes/bbushnell/tax/latest"

private static final String default16SFileNersc="/global/cfs/cdirs/bbtools/silva/16S_consensus_with_silva_maxns10_taxsorted.fa.gz"

private static final String default16SFileAws="/test1/16S_consensus_with_silva_maxns10_taxsorted.fa.gz"

private static final String default16SFileIGBVM="/data/sketch/silva/16S_consensus_with_silva_maxns10_taxsorted.fa.gz"

private static final String default18SFileNersc="/global/cfs/cdirs/bbtools/silva/18S_consensus_silva_maxns10_taxsorted.fa.gz"

private static final String default18SFileAws="/test1/18S_consensus_silva_maxns10_taxsorted.fa.gz"

private static final String default18SFileIGBVM="/data/sketch/silva/18S_consensus_with_silva_maxns10_taxsorted.fa.gz"

private static final String defaultImgFile="TAX_PATH/imgDump.txt"

private static final String defaultTableFileInt="TAX_PATH/gitable.int1d.gz"

private static final String defaultTableFile="TAX_PATH/gitable.int2d.gz"

private static final String defaultTreeFile="TAX_PATH/tree.taxtree.gz"

private static final String defaultPatternFile="TAX_PATH/patterns.txt"

private static final String defaultSizeFile="TAX_PATH/taxsize.tsv.gz"

private static final String defaultAccessionFile="TAX_PATH/shrunk.prot.accession2taxid.gz," + "TAX_PATH/shrunk.nucl_wgs.accession2taxid.gz," + "TAX_PATH/shrunk.nucl_gb.accession2taxid.gz,"+ "TAX_PATH/shrunk.dead_prot.accession2taxid.gz,"+ "TAX_PATH/shrunk.dead_wgs.accession2taxid.gz,"+ "TAX_PATH/shrunk.dead_nucl.accession2taxid.gz,"+ "TAX_PATH/shrunk.pdb.accession2taxid.gz"

*Path to all taxonomy files, substituted in to make specific file paths
public static String TAX_PATH=defaultTaxPath()

public static boolean protFull=false

*Screen output gets printed here
private static PrintStream outstream=System.out


#Methods
*Code entrance from the command line.
*This is not called normally, only when converting NCBI text files
*into a binary representation and writing it to disk.
*@param args Command line arguments
public static void main(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Constructor using filenames from command line arguments, in the format of:
*{names, nodes, merged}
*@param args Command line arguments
private TaxTree(String[] args)

*@param namesFile NCBI names.txt
*@param nodesFile NCBI nodes.txt
*@param mergedFile NCBI merged.txt
*@param args
private TaxTree(String namesFile, String nodesFile, String mergedFile, String[] args)

*Load a tax tree from disk.
*@param taxTreeFile Serialized TaxTree.
*@param hashNames Hash nodes using names as keys
*@param hashDotFormat Hash nodes using abbreviations, e.g. H.sapiens
*@return
public static final TaxTree loadTaxTree(String taxTreeFile, PrintStream outstream, boolean hashNames, boolean hashDotFormat)

*Load a tax tree from disk, either from a binary tree file,
*or from NCBI text files.
*@param taxTreeFile Binary representation; mutually exclusive with other files.
*@param taxNameFile NCBI names.txt
*@param taxNodeFile NCBI nodes.txt
*@param taxMergedFile NCBI merged.txt
*@param hashNames Hash nodes using names as keys
*@param hashDotFormat Hash nodes using abbreviations, e.g. H.sapiens
*@return The loaded tree
public static final TaxTree loadTaxTree(String taxTreeFile, String taxNameFile, String taxNodeFile, String taxMergedFile, PrintStream outstream, boolean hashNames, boolean hashDotFormat)

*Finds unranked nodes in the archaeal and bacterial kingdoms.
*If these are below species level, have a ranked parent,
*and have no ranked children, they are assigned strain or substrain.
private void assignStrains()

@Deprecated private void assignStrainsOld()

*Create tax nodes using names in the designated file.
*@param fname NCBI names.txt
*@return Array of created nodes, where array[x] contains the node with TaxID x.
private static TaxNode[] getNames(String fname)

*Parses names file a second time to fill in additional information.
*Should really be merged into getNames.
*@TODO Merge into getNames
private static TaxNode[] getNodes(String fname, TaxNode[] nodes)

*Count child nodes of each node.
*This can be used to size arrays or determine which nodes are leaves.
private void countChildren()

*Fill derived fields minParentLevelExtended and maxChildLevelExtended
*by percolating information through the tree until a fixpoint is reached.
*@TODO This could be finished in 2 passes using the childTable.
*@return Number of rounds required to reach fixpoint.
private int percolate()

*Load nodes into the nameMap and nameMapLower, mapped to their names.
*@param genusDotSpecies Also hash abbreviations such as E.coli.
public void hashNames(boolean genusDotSpecies)

*Generate the "dot format" name of a node.
*For example, transform "Homo sapiens" to "H.sapiens"
*@param name Node name
*@param buffer A ByteBuilder that may be modified
*@return Dot format
private static String dotFormat(String name, ByteBuilder buffer)

*Fill childMap, which maps nodes to their children.
public void hashChildren()

*Fetch this node's children.
*@param parent Node in question
*@return List of child nodes
public ArrayList<TaxNode> getChildren(TaxNode parent)

*Load a map of old to new TaxIDs.
*@param mergedFile NCBI merged.txt.
*@return Map of old to new TaxIDs
private static IntHashMap getMerged(String mergedFile)

*Simplify the tree by assigning ranks to unranked nodes,
*where possible, through inference.
*Optionally removes unranked nodes based on the skipNorank field.
*@param nodes Array of all TaxNodes.
*@return Number of nodes removed.
private int simplify(TaxNode nodes)

*Ensure tree has monotonically increasing (or nondescending) ranks.
*@param nodes All TaxNodes.
*@return Number of violations.
private static int test(TaxNode[] nodes)

*Format full name in semicolon format, e.g.
*"SK:Bacteria;P:Protobacteria;..."
*@param tn0 Base node
*@param skipNonCanonical Ignore noncanonical (aka "nonsimple") levels like Tribe.
*@return Resultant String
public String toSemicolon(TaxNode tn0, boolean skipNonCanonical, boolean mononomial)

*Return a list of TaxIDs of all ancestors.
*@param tn0 Base node
*@param skipNonCanonical Ignore noncanonical (aka "nonsimple") levels like Tribe.
*@return List of TaxIDs.
public IntList toAncestorIds(TaxNode tn0, boolean skipNonCanonical)

*Return a list of all ancestors.
*@param tn0 Base node
*@param skipNonCanonical Ignore noncanonical (aka "nonsimple") levels like Tribe.
*@return List of ancestor nodes.
public ArrayList<TaxNode> toAncestors(TaxNode tn0, boolean skipNonCanonical)

*Generate a path to the genome of an organism on the filesystem;
*used by ExplodeTree. Intended for internal JGI use.
*@param root Location of the exploded tree.
*@return Path to a genome.
public String toDir(TaxNode node, String root)

*Use various techniques to get a TaxID from an unknown String, such as parsing,
*name lookups, and accession translation.
*@param s String to process.
*@return Decoded TaxID.
public static int getID(String s)

*Use various techniques to get a TaxID from an unknown byte[], such as parsing,
*name lookups, and accession translation.
*@param s String to process.
*@return Decoded TaxID.
public static int getID(byte[] s)

*Return the lowest ancestor of the named node with taxonomic level at least minLevel
public TaxNode getNode(String s, int minLevelExtended)

*Determine whether a node is a descendant of another.
*@param child Possible child TaxID.
*@param parent Possible parent TaxID.
*@return true iff child descends from parent.
public boolean descendsFrom(int child, int parent)

*Determine whether a node is a descendant of another.
*@param child Possible child node.
*@param parent Possible parent node.
*@return true iff child descends from parent.
public boolean descendsFrom(TaxNode child, TaxNode parent)

*Determine whether an organism is classified as X.
*@param taxID taxID of organism.
*@param ancestorID taxID of possible ancestor.
*@return true if the organism is an X.
public boolean descendsFrom2(int taxID, int ancestorID)

*Determine whether an organism is classified as a plant.
public boolean isPlant(int taxID)

*Determine whether an organism is classified as an animal.
public boolean isAnimal(int taxID)

*Determine whether an organism is classified as a fungus.
public boolean isFungus(int taxID)

*Determine whether an organism is classified as a eukaryote.
public boolean isEukaryote(int taxID)

*Determine whether an organism is classified as a prokaryote.
public boolean isProkaryote(int taxID)

*Calculate the taxLevel of the common ancestor of two nodes.
*@param a TaxID of a node.
*@param b TaxID of a node.
*@return Common ancestor ID of a and b.
public int commonAncestorLevel(int a, int b)

*Calculate the common ancestor of two nodes.
*@param a TaxID of a node.
*@param b TaxID of a node.
*@return Common ancestor ID of a and b.
public int commonAncestor(int a, int b)

*Calculate the common ancestor of two nodes.
*@param a A node.
*@param b A node.
*@return Common ancestor of a and b.
public TaxNode commonAncestor(TaxNode a, TaxNode b)

*Identify the highest ancestor of a node;
*this will presumably be "Life".
*@param a Node
*@return Highest ancestor
public TaxNode highestAncestor(TaxNode a)

*Determine the TaxID of a String,
*without a loaded TaxTree.
*This only works if the literal TaxID is embedded in the String.
*@param header Typically a sequence header
*@return Decoded TaxID, or -1 if unsuccessful
public static int parseHeaderStatic(String header)

*New and improved. Tree is optional.
public static int parseHeaderStatic2(String header, TaxTree tree)

*Header should contain something like "tid|1234" somewhere;
*delimiter is autodetected.
private static int parseTaxID(String header, String term)

*Determine the TaxID of a String.
*@param header Typically a sequence header or file name
*@param bestEffort In some cases, try certain substrings if the name is not found.
*@return
public TaxNode parseNodeFromHeader(String header, boolean bestEffort)

*Guess the delimiter character in a String;
*typically assumed to be '|', '~', or ' '.
public static char ncbiHeaderDelimiter(String header)

*Parse a Silva header to a Node.
*@param s Silva header.
*@param bestEffort Try certain substrings if the name is not found.
*@return Node
TaxNode getNodeSilva(String s, boolean bestEffort)

*Parse a Unite header to a Node.
*@param s Unite header.
*@param bestEffort Try certain substrings if the name is not found.
*@return Node
TaxNode getNodeUnite(String s, boolean bestEffort)

*Parses sequence headers using NCBI's old-style header system, prior to Accessions.
private TaxNode getNodeOldStyle(String s, char delimiter)

*Parse a delimited number from a header, or return -1 if formatted incorrectly.
static long parseDelimitedNumber(String s, char delimiter)

*Parses sequence headers using NCBI's current header system, with Accessions.
private TaxNode getNodeNewStyle(String s)

*For parsing old-style NCBI headers.
public int parseAccessionToTaxid(String[] split)

*For parsing old-style NCBI headers.
public int parseHeaderNameToTaxid(String[] split)

*Returns the TaxID from the organism's scientific name (e.g. "Homo sapiens").
*If multiple nodes share the same name, returns the first; to get the full list,
*use getNodesByNameExtended.
*@param name Organism name.
*@return Organism TaxID, or -1 if not found.
public int parseNameToTaxid(String name)

*Fetch nodes indicated by this name.
*@param name A taxonomic name delimited by space or underscore.
*@return Nodes corresponding to the name.
public List<TaxNode> getNodesByNameExtended(String name)

*Return the TaxID of the lowest ancestor node at least the specified level,
*including this node itself. Level is the normal (non-extended) level.
*@param taxID
*@param taxLevel
*@return
public int promote(int taxID, int taxLevel)

*Fetch the first node in this node's lineage of at least the indicated level.
*This can be the node itself or an ancestor.
*@see getNodeAtLevelExtended
*@param tn Node in question
*@param taxLevel Desired minimum level
*@return A node at the desired level
public TaxNode promote(TaxNode tn, int taxLevel)

*Determine the TaxID of the node's parent.
*@param id TaxID of child node
*@return Parent TaxID
public int getParentID(int id)

*Fetch the node with this TaxID.
*@param id TaxID
*@return Node
public TaxNode getNode(int id)

public int toLevel(int id)

public int resolveID(int id)

*Fetch the node with this TaxID, but don't throw assertions upon failure.
*@param id TaxID
*@return Node
public TaxNode getNode(int id, boolean skipAssertion)

public TaxNode getNodeAtLevel(int id, int minLevel)

public TaxNode getNodeAtLevelExtended(int id, int minLevelE)

public TaxNode getNodeAtLevel(int id, int minLevel, int maxLevel)

public TaxNode getNodeAtLevelExtended(int id, int minLevelE, int maxLevelE)

public int getIdAtLevelExtended(int taxID, int taxLevelExtended)

*Fetch the node with this name.
*Throw an assertion if there are multiple such nodes.
*@param s Organism name.
*@return Node with given name.
public TaxNode getNodeByName(String s)

*Fetch a list of all nodes with this name.
*@param s Organism name.
*@return Nodes with given name.
public List<TaxNode> getNodesByName(String s)

*Fetch a map of names to nodes. If absent, create it first.
*@param lowercase If true, return the map with lowercase keys.
*@return Map of names to nodes.
private HashMap<String,ArrayList<TaxNode>> getMap(boolean lowercase)

private List<TaxNode> getNodesByName(String s, boolean lowercase)

public ArrayList<TaxNode> getAncestors(int id)

public void increment(IntList ids, IntList counts, boolean sync)

public void incrementRaw(int id, long amt)

public void percolateUp()

public void percolateUp(int fromLevel)

*Add this amount to the node and all its ancestors.
public void percolateUp(TaxNode node, long amt)

public ArrayList<TaxNode> gatherNodesAtLeastLimit(long limit)

public ArrayList<TaxNode> gatherNodesAtLeastLimit(long limit, int minLevel, int maxLevel)

public ArrayList<TaxNode> gatherNodesAtLeastLimitExtended(int fromLevelExtended, long limit)

*Generate the name to level number map.
private static HashMap<String,Integer> makeLevelMap()

*Generate the name to level number map.
private static HashMap<String,Integer> makeShortLevelMap()

*Generate the name to extended level number map.
private static HashMap<String,Integer> makeLevelMapExtended()

*I think this maps normal and extend names to normal level numbers.
private static HashMap<String,Integer> makeAltLevelMap()

*Number of bp associated with this node in RefSeq
public long toSize(TaxNode tn)

*Number of bp associated with this node and descendants in RefSeq
public long toSizeC(TaxNode tn)

*Number of sequences associated with this node in RefSeq
public int toSeqs(TaxNode tn)

*Number of sequences associated with this node and descandants in RefSeq
public long toSeqsC(TaxNode tn)

*Number of descendants of this node
public int toNodes(TaxNode tn)

*Fills refseqSizeMap, refseqSizeMapC, etc. from a file containing the summary.
*@param fname Size file name
public void loadSizeFile(String fname)

public static int imgToTaxid(long img)

public TaxNode imgToTaxNode(long img)

public static int loadIMG(String fname, boolean storeName, PrintStream outstream)

public static int loadIMG(ImgRecord[] array)

@Deprecated public static int parseLevel(String b)

public static int parseLevelExtended(String b)

public boolean isUnclassified(int tid)

public boolean isEnvironmentalSample(int tid)

public boolean isVirus(int tid)

public long definedLevels(int tid)

public long definedLevelsExtended(int tid)

*Generates the mononomial name for this taxonomic level based on the scientific name.
*For example, "Homo sapiens" -> "Sapiens"
*@param tid TaxID
*@return Correct name for this node.
public String mononomial(int tid)

public String mononomial(TaxNode tn)

public HashMap<String,ArrayList<TaxNode>> nameMap()

*A simpler and probably less safe version of sharedTree(...)
public static TaxTree getTree()

*Fetch the shared tree, loading it from file if not present.
*@return A tree.
*@TODO: Check proper-construction of double-checked synchronize
private static TaxTree sharedTree(String fname, boolean hashNames, boolean hashDotFormat, PrintStream outstream)

*For initialization. Normally only one tree is needed by a process so it is set here.
*If the tree is already set nothing will happen, unless additional hashing is needed.
private static void setSharedTree(TaxTree tree, boolean hashNames, boolean hashDotFormat)

*Determine whether a taxonomic level is standard. e.g.:
*isSimple("phylum")=true
*isSimple("subphylum")=false
*isSimple("no-rank")=false
*@param levelExtended The extended level to test.
*@return True if this level is not no-rank, and the names of the normal and extended levels match.
public static boolean isSimple(int levelExtended)

*Determine whether a taxonomic level is standard, but allows substrain and lower. e.g.:
*isSimple("phylum")=true
*isSimple("substrain")=true
*isSimple("subphylum")=false
*isSimple("no-rank")=false
*@param levelExtended The extended level to test.
*@return True if this level is not no-rank, and the names of the normal and extended levels match.
public static boolean isSimple2(int levelExtended)

*Get the number for the normal level of this name
public static final int stringToLevel(String s)

public static final int shortStringToLevel(String s)

public static final boolean levelMapExtendedContains(String s)

*Get the number for the extended level of this name
public static final int stringToLevelExtended(String s)

*Get the normal name for this normal level
public static final String levelToString(int x)

*Get the extended name for this extended level
public static final String levelToStringExtended(int x)

*Get the abbreviated name for this normal level
public static final String levelToStringShort(int x)

*Flatten the extended tax level names matrix to a 1D array
private static final String[] makeNamesExtended()

*Creates extendedToLevel from taxaNamesExtendedMatrix during initialization.
private static int[] makeExtendedToLevel()

*Convert a standard level number (like KINGDOM) to extended (like KINGDOM_E).
public static final int levelToExtended(int level)

*Convert an extended level number (like PHYLUM_E) to extended (like PHYLUM).
*Non-standard levels will be converted to the next higher standard level;
*e.g., subphylum -> phylum
public static final int extendedToLevel(int extended)

*For setting TAX_PATH, the root to taxonomy files
public static final String defaultTaxPath()

*16S consensus sequences per TaxID
public static final String default16SFile()

*18S consensus sequences per TaxID
public static final String default18SFile()

*Location of gitable.int2d.gz for gi lookups
public static final String defaultTableFile()

*Location of tree.taxtree.gz
public static final String defaultTreeFile()

*Location of shrunk.*.accession2taxid.gz (all accession files, comma-delimited)
public static final String defaultAccessionFile()

*Location of patterns.txt, which holds information about observed accession string formats
public static final String defaultPatternFile()

*Location of imgDump.txt, which translates IMG to NCBI IDs for internal JGI use
public static final String defaultImgFile()

*Location of taxsize.tsv, which indicates the amount of sequence associated with a TaxID
public static final String defaultSizeFile()

</class TaxTree>
