#version 1
#package jgi
#generated 2025-09-06T20:37:23

<class AddAdapters>
*@author Brian Bushnell
*@date Mar 16, 2014
public class AddAdapters

#Fields
public boolean errorState=false

private String in1=null

private String in2=null

private String out1=null

private String out2=null

private String extin=null

private String extout=null

private String adapterFile=null

private String[] literals=null

private boolean overwrite=true

private boolean append=false

*Add /1 and /2 to paired reads
private boolean addslash=true

*Encode correct answer in read ID field
private boolean changename=true

*Add errors from quality value
private boolean adderrors=true

*Add adapters to the same location for read 1 and read 2
private boolean addPaired=true

*Add reverse-complemented adapters also
private boolean addRC=false

*aka 3'
private boolean right=true

private long maxReads=-1

private int minlen=1

private boolean writeMode=true

private float adapterProb=0.5f

private long readsProcessed=0

private long basesProcessed=0

private long adaptersAdded=0

private long adapterBasesAdded=0

private long randomBasesAdded=0

private long validReads=0

private long validBases=0

private long truePos=0

private long trueNeg=0

private long falsePos=0

private long falseNeg=0

private long broken=0

private long mispaired=0

private long tooShort=0

private long tooLong=0

private long correct=0

private long fullyRemoved=0

private long tooShortBases=0

private long tooLongBases=0

private long tooShortReadBases=0

private long tooLongReadBases=0

private long correctBases=0

private long validBasesCounted=0

private long validBasesExpected=0

private long adapterBasesTotal=0

private long adapterReadsTotal=0

private long adapterReadsRemaining=0

private long adapterBasesRemaining=0

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private final FileFormat ffa

private final ArrayList<byte[]> adapters

private PrintStream outstream=System.err

public static boolean verbose=false

private java.util.Random randy


#Methods
public static void main(String[] args)

public AddAdapters(String[] args)

private final ArrayList<byte[]> makeAdapterList()

private final ArrayList<byte[]> makeAdapterList2()

void write(Timer t)

private void addAdapter(Read r, int loc)

private void addAdapter(Read r, boolean addPaired)

void read(Timer t)

private void grade(Read r1, Read r2)

private void grade(Read r)

</class AddAdapters>
<class AdjustHomopolymers>
*This class does nothing.
*It is designed to be easily modified into a program
*that processes reads in a single thread.
*@author Brian Bushnell
*@date June 20, 2014
public class AdjustHomopolymers

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private ByteBuilder bbBases=new ByteBuilder()

private ByteBuilder bbQuals=new ByteBuilder()

private float rate=0.0f

private byte[] fakeQuality=new byte[0]

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public AdjustHomopolymers(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a list of Reads.
*@param ln The list.
*@param cris Read Input Stream
*@param ros Read Output Stream for reads that will be retained
void processList(ListNum<Read> ln, ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

void processRead(Read r)

private byte[] fakeQuality(int minlen)

</class AdjustHomopolymers>
<class Assembly>
public class Assembly

#Fields
final String fname

IntList contigs=new IntList()

long length=0

long headerLength=0

String firstHeader=null

long[] acgtnio

public static final byte[] baseToACGTNIO=makeBaseToACGTUNIO()

private static final byte A=0

private static final byte C=1

private static final byte G=2

private static final byte T=3

private static final byte U=4

private static final byte N=5

private static final byte IUPAC=6

private static final byte OTHER=7


#Methods
public Assembly(String fname_)

void load()

void addToACGTNIO(byte[] line)

void clear()

float gc()

long lengthAtLeast(int minimum)

private static final byte[] makeBaseToACGTUNIO()

</class Assembly>
<class AssemblyStats2>
*@author Brian Bushnell
*@date Sep 16, 2013
public final class AssemblyStats2

#Fields
private static final byte[] charToNum=makeCharToNum()

public static int GCFORMAT=1

public static boolean GC_FRACTION=true

public static int FORMAT=1

private static long cutoff=1000000

private static long LIMSUM=0

private static long HEADERLENSUM=0

private static int bbmapkmer=0

public static boolean overwrite=true

public static boolean append=false

public static boolean useheader=true

public static boolean addfilename=false

public static boolean printL90=true

public static boolean printExtended=false

public static int logSumOffset=1000

public static double powSumPower=0.25

public static double logSumBase=2

public static boolean squareLog=false

public static double logPower=1.0

public static boolean showspeed=false

public static boolean printheadersize=false

public static boolean skipDuplicateLines=true

public static boolean N_UNDERSCORE=true

public static long assemblyScoreMinLen=2000

public static long assemblyScoreMaxLen=50000

public static double alignedFraction=0

public static boolean printAssemblyScore=false

private static final byte slashr='\r'

private static final byte slashn='\n'

private static final byte carrot='>'

private static final byte at='@'

private static final byte noref='N'

private static final byte noref2='n'

private boolean benchmark=false

private String in=null

private String out=null

private String gc=null

private String gchistFile=null

private String scaffoldHistFile=null

private int maxNs=-1

*Number of decimal places for GC histogram
private final int gchistDecimals1

*Number of bins for output (subsampled) GC content histogram
private final int gcbins

*Number of bins for internal GC content histogram
private final int gcbins2

*Minimum scaffold length to count
private final int minScaffold

*Number of contigs of length x
private final LongList clist

*Number of scaffolds of length x
private final LongList slist

*Sum of contigs per scaffold of length x
private final LongList sclist1

*Sum of contig lengths per scaffold of length x
private final LongList sclist2

*List of contig lengths for contigs at least cutoff in length
private final LongList llist

*List of scaf len, contigs, contig sum for scaffolds at least cutoff in length
private final ArrayList<Triple> tlist

*Downsampled gc histogram
private final long[] gchistArray

*Downsampled gc histogram
private long[] gchistArray_downsampled

*gc standard deviation
private double gc_std

*Downsampled gc histogram, using base counts rather than scaffold counts
private final long[] gchist_by_base

*Downsampled gc histogram, using base counts rather than scaffold counts
private long[] gchist_by_base_downsampled

*gc standard deviation, using base counts rather than scaffold counts
private double gc_bb_std

public static double lastLogSum

public static long lastL90

public static long lastL50

public static long lastSize

public static long lastContigs

public static long lastMaxContig

public static PrintStream outstream=System.out


#Methods
public static void main(String[] args)

public AssemblyStats2(String[] args)

public void process()

public long[] countFasta(InputStream is, String gcout)

public long[] countFastq(InputStream is, String gcout)

private void printGCHist(String gchistFile)

public static void printBenchResults(Timer t, long[] counts, long sum, String in)

public static double calcLogSumContigs(LongList clist, LongList llist, int cutoff, double base)

public static double calcLogSumScaffolds(LongList slist, ArrayList<Triple> tlist, int cutoff, double base)

public static double calcPowerSumContigs(LongList clist, LongList llist, int cutoff, double power)

public static double calcPowerSumScaffolds(LongList slist, ArrayList<Triple> tlist, int cutoff, double power)

public static double calcAssemblyScore(LongList slist, ArrayList<Triple> tlist, long min, long max, double aligned)

public static double calcLogSumCounts(LongList counts, int cutoff, double base)

private static double logsum(long len)

public static double calcLogSumLengths(LongList lengths, int cutoff, double base)

public static double calcLogSumTriples(ArrayList<Triple> triples, int cutoff, double base)

public static double calcPowerSumCounts(LongList counts, int cutoff, double power)

private static double powersum(long len)

public static double calcPowerSumLengths(LongList lengths, int cutoff, double power)

public static double calcPowerSumTriples(ArrayList<Triple> triples, int cutoff, double power)

public static void printResults(Timer t, long[] counts, long sum, long minScaffold, double gc_std, String in, LongList clist, LongList slist, LongList sclist1, LongList sclist2, LongList llist, ArrayList<Triple> tlist, String out)

private static long bbmapMemoryBytes(long[] acgtn, long scaffolds, long headerlen, int k)

private static CharSequence estimateBBMapMemory(long[] acgtn, long scaffolds, long headerlen, int k)

public static long bench(InputStream is)

private static void writeHistFile(String fname, LongList slist, ArrayList<Triple> tlist, boolean ascending)

private static String toString2(StringBuilder sb, long[] counts)

private static String toString3(StringBuilder sb, long[] counts, double gc_std)

private static final String formatX(int next, long ssum, long csum, long slen, long clen)

private static final String formatKB(long x, int precision, int width)

private static final String formatKB_all(long x, int precision, int width)

private static final StringBuilder formatComma(long x, int width)

private static final String formatPercent(float x)

protected void reset()

*@return charToNum array
public static final byte[] makeCharToNum()

</class AssemblyStats2>
<class AssemblyStats3>
*Generates some stats from multiple files.
*Uses the new Assembly class.
*@author Brian Bushnell
*@date January 21, 2025
public class AssemblyStats3

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out1="stdout.txt"

private final FileFormat ffout1

private long maxReads=-1

private long linesProcessed=0

private long bytesProcessed=0

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public AssemblyStats3(String[] args)

void process(Timer t)

public static String makeHeader()

void processInner(String fname, ByteStreamWriter bsw)

</class AssemblyStats3>
<class AssemblyStatsWrapper>
*@author Brian Bushnell
*@date Apr 17, 2013
public class AssemblyStatsWrapper

#Methods
public static void main(String[] args)

</class AssemblyStatsWrapper>
<class BBDuk>
*Separates, trims, or masks sequences based on matching kmers in a reference.
*Supports Hamming and and edit distance.
*Supports K 1-31 and emulated K>31.
*@author Brian Bushnell
*@date Aug 30, 2013
public class BBDuk

#Fields
boolean silent=false

boolean json=false

boolean swift=false

*For calculating kmer cardinality in input
final CardinalityTracker loglogIn

*For calculating kmer cardinality in output
final CardinalityTracker loglogOut

*Requires (and sets) cardinality tracking. This is for input kmers.
String khistIn=null

*Requires (and sets) cardinality tracking. This is for output kmers.
String khistOut=null

*Has this class encountered errors while processing?
public boolean errorState=false

*Fraction of available memory preallocated to arrays
private double preallocFraction=1.0

*Initial size of data structures
private int initialSize=-1

*Hold kmers. A kmer X such that X%WAYS=Y will be stored in keySets[Y]
final AbstractKmerTable[] keySets

*A scaffold's name is stored at scaffoldNames.get(id).
*scaffoldNames[0] is reserved, so the first id is 1.
final ArrayList<String> scaffoldNames=new ArrayList<String>()

*Names of reference files (refNames[0] is valid).
private ArrayList<String> refNames=new ArrayList<String>()

private final ArrayList<String> altRefNames=new ArrayList<String>()

*Number of scaffolds per reference.
private int[] refScafCounts

*scaffoldCounts[id] stores the number of reads with kmer matches to that scaffold
AtomicLongArray scaffoldReadCounts

*scaffoldBaseCounts[id] stores the number of bases with kmer matches to that scaffold
AtomicLongArray scaffoldBaseCounts

*Set to false to force threads to share atomic counter arrays.
private boolean ALLOW_LOCAL_ARRAYS=true

*scaffoldLengths[id] stores the length of that scaffold
private IntList scaffoldLengths=new IntList()

*hitCounts[x] stores the number of reads with exactly x kmer matches
long[] hitCounts

*Array of reference files from which to load kmers
private String[] ref=null

*Alternate reference to be used if main reference has no kmers
private String[] altref=null

*Array of literal strings from which to load kmers
private String[] literal=null

*Optional reference for sam file
private String samref=null

*Input reads
private String in1=null

*Input reads
private String in2=null

*Input FileFormats
private final FileFormat ffin1

*Input FileFormats
private final FileFormat ffin2

*Input qual files
private String qfin1=null

*Input qual files
private String qfin2=null

*Output qual files
private String qfout1=null

*Output qual files
private String qfout2=null

*Output reads (unmatched and at least minlen)
private String out1=null

*Output reads (unmatched and at least minlen)
private String out2=null

*Output reads (matched or shorter than minlen)
private String outb1=null

*Output reads (matched or shorter than minlen)
private String outb2=null

*Output FileFormats
private final FileFormat ffout1

*Output FileFormats
private final FileFormat ffout2

*Output FileFormats
private final FileFormat ffoutb1

*Output FileFormats
private final FileFormat ffoutb2

*Output FileFormats
private final FileFormat ffouts

*Output reads whose mate was discarded
private String outsingle=null

*Statistics output files
private String outstats=null

*Statistics output files
private String outrqc=null

*Statistics output files
private String outrpkm=null

*Statistics output files
private String outrefstats=null

*Statistics output files
private String polymerStatsFile=null

private String outduk=null

final boolean tossJunk

*Dump kmers here.
private String dump=null

*Quit after this many bases written to outm
long maxBasesOutm=-1

*Quit after this many bases written to outu
long maxBasesOutu=-1

*Maximum input reads (or pairs) to process. Does not apply to references. -1 means unlimited.
private long maxReads=-1

*Process this fraction of input reads.
private float samplerate=1f

*Set samplerate seed to this value.
private long sampleseed=-1

*Output reads in input order. May reduce speed.
private final boolean ordered

*Attempt to match kmers shorter than normal k on read ends when doing kTrimming.
boolean useShortKmers=false

*Make the middle base in a kmer a wildcard to improve sensitivity
boolean maskMiddle=true

int midMaskLen=0

*Store reference kmers with up to this many substitutions
int hammingDistance=0

*Search for query kmers with up to this many substitutions
int qHammingDistance=0

*Store reference kmers with up to this many edits (including indels)
int editDistance=0

*Store short reference kmers with up to this many substitutions
int hammingDistance2=-1

*Search for short query kmers with up to this many substitutions
int qHammingDistance2=-1

*Store short reference kmers with up to this many edits (including indels)
int editDistance2=-1

*Never skip more than this many consecutive kmers when hashing reference.
int maxSkip=1

*Always skip at least this many consecutive kmers when hashing reference.
*1 means every kmer is used, 2 means every other, etc.
int minSkip=1

*Trim this much extra around matched kmers
int trimPad

int xMinLoc=-1

int yMinLoc=-1

int xMaxLoc=-1

int yMaxLoc=-1

final boolean locationFilter

private String varFile=null

private String vcfFile=null

private VarMap varMap=null

private ScafMap scafMap=null

private boolean fixVariants=false

private boolean unfixVariants=true

*Optional file for quality score recalibration
private String samFile=null

*Filter reads with unsupported substitutions
private boolean filterVars=false

*Maximum allowed unsupported substitutions in a read
private int maxBadSubs=2

*Maximum variant depth for a variant to be considered unsupported
private int maxBadSubAlleleDepth=1

*Minimum read depth for a variant to be considered unsupported
private int minBadSubReadDepth=2

private int minBadSubEDist=0

private float maxBadAlleleFraction=0

*Minimum entropy to be considered "complex", on a scale of 0-1
float entropyCutoff=-1

*Mask entropy with a highpass filter
boolean entropyHighpass=true

*Change the quality scores to be proportional to the entropy
boolean entropyMark=false

*Mask low-entropy areas (e.g., with N)
boolean entropyMask=false

*Trim only trailing or leading low-entropy areas, ignoring middle areas
int entropyTrim=0

*Convert low-entropy areas to lower case
boolean entropyMaskLowercase=false

*Perform entropy calculation
final boolean calcEntropy

*Stores JSON output
JsonObject jsonStats

long readsIn=0

long basesIn=0

long readsOut=0

long basesOut=0

long readsQTrimmed=0

long basesQTrimmed=0

long readsFTrimmed=0

long basesFTrimmed=0

long readsQFiltered=0

long basesQFiltered=0

long readsEFiltered=0

long basesEFiltered=0

long readsNFiltered=0

long basesNFiltered=0

long readsPolyTrimmed=0

long basesPolyTrimmed=0

long readsKTrimmed=0

long basesKTrimmed=0

long readsKFiltered=0

long basesKFiltered=0

long badGcReads

long badGcBases

long badHeaderReads=0

long badHeaderBases=0

long readsTrimmedByOverlap

long basesTrimmedByOverlap

long readsTrimmedBySwift

long basesTrimmedBySwift

long refReads=0

long refBases=0

long refKmers=0

long storedKmers=0

boolean countPolymers=false

byte polymerChar1=-1

byte polymerChar2=-1

*Minimum length to consider a homopolymer, for the purpose of statistics
int polymerLength=20

*Tracks homopolymer statistics
PolymerTracker pTracker

*Don't look for kmers in read 1
final boolean skipR1

*Don't look for kmers in read 2
final boolean skipR2

*Correct errors via read overlap
final boolean ecc

*True if a ReadStats object is being used for collecting data
final boolean makeReadStats

*Look for reverse-complements as well as forward kmers. Default: true
final boolean rcomp

*Don't allow a read 'N' to match a reference 'A'.
*Reduces sensitivity when hdist>0 or edist>0. Default: false.
final boolean forbidNs

*AND bitmask with 0's at the middle base
final long middleMask

*Use HashForest data structure
private final boolean useForest

*Use KmerTable data structure
private final boolean useTable

*Use HashArray data structure (default)
private final boolean useArray

*Normal kmer length
final int k

*k-1; used in some expressions
final int k2

*Emulated kmer greater than k
final int kbig

*Effective kmer size
final int keff

*Shortest kmer to use for trimming
final int mink

*A read may contain up to this many kmers before being considered a match. Default: 0
final int maxBadKmers0

*A read must share at least this fraction of its kmers to be considered a match. Default: 0
final float minKmerFraction

*Reference kmers must cover at least this fraction of read bases to be considered a match. Default: 0
final float minCoveredFraction

*Recalibrate quality scores using matrices
final boolean recalibrateQuality

*Quantize quality scores to reduce file size
boolean quantizeQuality=false

*Quality-trim the left side
final boolean qtrimLeft

*Quality-trim the right side
final boolean qtrimRight

*Trim soft-clipped bases
final boolean trimClip

*Trim poly-A tails of at least this length
final int trimPolyA

*Trim poly-G prefixes of at least this length
final int trimPolyGLeft

*Trim poly-G tails of at least this length
final int trimPolyGRight

*Remove reads with poly-G prefixes of at least this length
final int filterPolyG

*Allow this many consecutive mismatching symbols in the homopolymer
int maxNonPoly=1

*Trim poly-C prefixes of at least this length
final int trimPolyCLeft

*Trim poly-C tails of at least this length
final int trimPolyCRight

*Remove reads with poly-C prefixes of at least this length
final int filterPolyC

*Trim bases at this quality or below. Default: 4
final float trimq

*Error rate for trimming (derived from trimq)
private final float trimE

*Throw away reads below this average quality after trimming. Default: 0
final float minAvgQuality

*Throw away reads with any base below this quality after trimming. Default: 0
final byte minBaseQuality

*If positive, calculate average quality from the first X bases only. Default: 0
final int minAvgQualityBases

*Throw away reads failing chastity filter (:Y: in read header)
final boolean chastityFilter

*Crash if a barcode is encountered that contains Ns or is not in the table
final boolean failBadBarcodes

*Remove reads with Ns in barcodes or that are not in the table
final boolean removeBadBarcodes

*Fail reads missing a barcode
final boolean failIfNoBarcode

*A set of valid barcodes; null if unused
final HashSet<String> barcodes

*Throw away reads containing more than this many Ns. Default: -1 (disabled)
final int maxNs

*Throw away reads containing without at least this many consecutive called bases.
final int minConsecutiveBases

*Throw away reads containing fewer than this fraction of any particular base.
final float minBaseFrequency

*Throw away reads shorter than this after trimming. Default: 10
final int minReadLength

*Throw away reads longer than this after trimming. Default: Integer.MAX_VALUE
final int maxReadLength

*Toss reads shorter than this fraction of initial length, after trimming
final float minLenFraction

*Filter reads by whether or not they have matching kmers
private final boolean kfilter

*Trim matching kmers and all bases to the left
final boolean ktrimLeft

*Trim matching kmers and all bases to the right
boolean ktrimRight

*Don't trim, but replace matching kmers with a symbol (default N)
final boolean ktrimN

*Exclude kmer itself when ktrimming
final boolean ktrimExclusive

*Split into two reads around the kmer
final boolean ksplit

*Replace bases covered by matched kmers with this symbol
final byte trimSymbol

*Convert kmer-masked bases to lowercase
final boolean kmaskLowercase

*Only mask fully-covered bases *
final boolean kmaskFullyCovered

*Output over-trimmed reads to outbad (outmatch). If false, they are discarded.
final boolean addTrimmedToBad

*Find the sequence that shares the most kmer matches when filtering.
final boolean findBestMatch

*Trim pairs to the same length, when adapter-trimming
final boolean trimPairsEvenly

*Trim left bases of the read to this position (exclusive, 0-based)
final int forceTrimLeft

*Trim right bases of the read after this position (exclusive, 0-based)
final int forceTrimRight

*Trim this many rightmost bases of the read
final int forceTrimRight2

*Trim right bases of the read modulo this value.
*e.g. forceTrimModulo=50 would trim the last 3bp from a 153bp read.
final int forceTrimModulo

*Discard reads with GC below this.
final float minGC

*Discard reads with GC above this.
final float maxGC

*Discard reads outside of GC bounds.
final boolean filterGC

*Average GC for paired reads.
final boolean usePairGC

*If positive, only look for kmer matches in the leftmost X bases
final int restrictLeft

*If positive, only look for kmer matches the rightmost X bases
final int restrictRight

*Skip this many initial input reads
private final long skipreads

*Pairs go to outbad if either of them is bad, as opposed to requiring both to be bad.
*Default: true.
final boolean removePairsIfEitherBad

*Rather than discarding, trim failures to 1bp.
*Default: false.
final boolean trimFailuresTo1bp

*Print only statistics for scaffolds that matched at least one read
*Default: true.
private final boolean printNonZeroOnly

*Rename reads to indicate what they matched.
*Default: false.
final boolean rename

*Use names of reference files instead of scaffolds.
*Default: false.
private final boolean useRefNames

*Fraction of kmers to skip, 0 to 16 out of 17
final int speed

*Skip this many kmers when examining the read. Default 1.
*1 means every kmer is used, 2 means every other, etc.
final int qSkip

*noAccel is true if speed and qSkip are disabled, accel is the opposite.
final boolean noAccel

private final boolean accel

private boolean pairedToSingle=false

*True for amino acid data, false for nucleotide data
final boolean amino

final int maxSupportedK

final int bitsPerBase

final int maxSymbol

final int symbols

final int symbolArrayLen

final int symbolSpace

final long symbolMask

final int minlen

final int minminlen

*The length of half of a kmer outside the middle mask
final int minlen2

final int shift

final int shift2

final long mask

final long kmask

*x&clearMasks[i] will clear base i
final long[] clearMasks

*x|setMasks[j][i] will set position i to symbol j
final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
final long[] rightMasks

*x|kMasks[i] will set the bit to the left of the leftmost base
final long[] lengthMasks

*Symbol code; -1 for undefined
final byte[] symbolToNumber

*Symbol code; 0 for undefined
final byte[] symbolToNumber0

*Complementary symbol code; 0 for undefined
final byte[] symbolToComplementNumber0

*Trim implied adapters based on overlap, for reads with insert size shorter than read length
final boolean trimByOverlap

final boolean useQualityForOverlap

final boolean strictOverlap

int minOverlap0=7

int minOverlap=14

int minInsert0=16

int minInsert=40

final float maxRatio

final float ratioMargin

final float ratioOffset

final float efilterRatio

final float efilterOffset

final float pfilterRatio

final float meeFilter

boolean align=false

String alignOut=null

String alignRef=null

float alignMinid1=0.66f

float alignMinid2=0.56f

int alignK1=17

int alignK2=13

int alignMM1=1

int alignMM2=1

final SideChannel3 sidechannel

*Generate histograms from the reads before rather than after processing;
*default is true. Khist is handled independently.
final boolean histogramsBeforeProcessing

final boolean MAKE_QUALITY_ACCURACY

final boolean MAKE_QUALITY_HISTOGRAM

final boolean MAKE_MATCH_HISTOGRAM

final boolean MAKE_BASE_HISTOGRAM

final boolean MAKE_EHIST

final boolean MAKE_INDELHIST

final boolean MAKE_LHIST

final boolean MAKE_GCHIST

final boolean MAKE_ENTROPYHIST

final boolean MAKE_IDHIST

final boolean MAKE_IHIST

*Number of tables (and threads, during loading)
private static final int WAYS=7

*Default initial size of data structures
private static final int initialSizeDefault=128000

*Verbose messages
public static final boolean verbose=false

*Ends for some operations like entropytrim; could be migrated over to other operations
private static final int RIGHT=1

*Ends for some operations like entropytrim; could be migrated over to other operations
private static final int LEFT=2

*Ends for some operations like entropytrim; could be migrated over to other operations
private static final int RIGHTLEFT=3

*Number of reads output in the last run
public static long lastReadsOut

*Print messages to this stream
private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Print speed statistics upon completion
public static boolean showSpeed=true

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

*Number of ProcessThreads
public static int THREADS=Shared.threads()

*Indicates end of input stream
static final ArrayList<Read> POISON=new ArrayList<Read>(0)

*Number of columns for statistics output, 3 or 5
public static int STATS_COLUMNS=3

*Release memory used by kmer storage after processing reads
public static boolean RELEASE_TABLES=true

*Max value of hitCount array
public static final int HITCOUNT_LEN=1000

*Make unambiguous copies of ref sequences with ambiguous bases
public static boolean REPLICATE_AMBIGUOUS=false

*Stores some data for statistics when running RQCFilter; not used otherwise.
public static HashMap<String,Long> RQC_MAP=null


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public BBDuk(String[] args)

String[] modifyRefPath(String[] array, ArrayList<String> list)

public static String modifyRefPath(String s)

public void process()

public void process2(long startTime)

private String toJson(long startTime)

public static String toPercent(long numerator, long denominator)

private static String padRight(String s, int minLen)

*Clear stored kmers.
public void unloadKmers()

*Clear stored sequence data.
public void unloadScaffolds()

*Write statistics about how many reads matched each reference scaffold.
private void writeStats()

*Write RPKM statistics.
private void writeRPKM()

*Write statistics on a per-reference basis.
private void writeRefStats()

*Write processing statistics in DUK's format.
*@param time Elapsed time, nanoseconds
private void writeDuk(long time)

*Write RQCFilter stats.
*@param time Elapsed time, nanoseconds
private void writeRqc()

public static String rqcString()

private void addToRqcMap()

public static void putRqc(String key, Long value, boolean evict, boolean add)

*Helper method; formats statistics to be duk-compatible
*@param time Elapsed time, nanoseconds
*@return duk output string
private String dukString(long time)

*Fills the scaffold names array with reference names.
private void toRefNames()

public double getPolymerRatio()

*Fills tables with kmers from references, using multiple LoadThread.
*@return Number of kmers stored.
private long spawnLoadThreads()

*Match reads against reference kmers, using multiple ProcessThread.
*@param t
private void spawnProcessThreads(Timer t)

public static final String[] processLiteralArg(String arg)

public static final String processLiteralTerm(String b)

*Current available memory
private static final long freeMemory()

*Transforms a kmer into a canonical value stored in the table. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param lengthMask Bitmask with single '1' set to left of kmer
*@return Canonical value
final long toValue(long kmer, long rkmer, long lengthMask)

final long rcomp(long kmer, int len)

final boolean passesSpeed(long key)

final boolean failsSpeed(long key)

public static int trimPolyA(Read r, int minPoly)

public static int trimPoly(Read r, int minPolyLeft, int minPolyRight, int maxNonPoly, byte c)

public static int detectPolyLeft(Read r, int minPoly, int maxNonPoly, byte c)

public static int detectPolyRight(Read r, int minPoly, int maxNonPoly, byte c)

private static int trimSwift(Read r)

private static int parseEnd(String s)

*For verbose / debugging output
final String kmerToString(long kmer, int k)

*Returns true if the symbol is not degenerate (e.g., 'N') for the alphabet in use.
final boolean isFullyDefined(byte symbol)

</class BBDuk>
<class BBMask>
*Masks a fasta file by inserting 'N' in place of low-complexity short repeats,
*and anything covered by mapped reads in a sam file.
*@author Brian Bushnell
*@date Feb 18, 2014
public class BBMask

#Fields
private LinkedHashMap<String,Read> map=null

private ConcurrentHashMap<String,String> norefSet=new ConcurrentHashMap<String,String>(256,.75f,16)

private HashMap<String,CoverageArray> covmap=null

private long refReads=0

private long refBases=0

private long samReads=0

private long samBases=0

public boolean errorState=false

private String inRef=null

private ArrayList<String> inSam=new ArrayList<String>()

private String qfinRef=null

private String outRef=null

private String qfoutRef=null

private String extinRef=null

private String extoutRef=null

private boolean overwrite=true

private boolean append=false

private long maxReads=-1

private boolean processRepeats=false

private int mink=5

private int maxk=5

private int minlen=40

private int mincount=4

private boolean processEntropy=true

private boolean entropyMode=true

private boolean splitMode=false

private int mink2=5

private int maxk2=5

private int window=80

private float ratio=0.35f

private float entropyCutoff=0.70f

*Use 32-bit coverage arrays
private boolean bits32=true

*Include deletions when calculating coverage
private boolean includeDeletionCoverage=true

*If nonnegative, mask bases with coverage outside this range.
private int mincov=-1

*If nonnegative, mask bases with coverage outside this range.
private int maxcov=-1

private int samPad=0

private final FileFormat ffinRef

private final FileFormat[] ffinSam

private final FileFormat ffoutRef

private PrintStream outstream=System.err

public static boolean verbose=false

public static boolean CONVERT_NON_ACGTN=true

private static boolean verify=false

private static boolean MaskByLowercase=false


#Methods
public static void main(String[] args)

public BBMask(String[] args)

public void process(Timer t0)

private static int setHighCoverage(BitSet bs, CoverageArray ca, int maxAllowedCoverage, int maxLen)

private static int setLowCoverage(BitSet bs, CoverageArray ca, int minAllowedCoverage, int maxLen)

private long maskFromBitsets(boolean lowercase)

public static int maskRead(Read r, BitSet bs, boolean lowercase)

private long splitFromBitsets()

private void writeOutput()

private long maskSam()

private void maskSam_MT(FileFormat ff)

private void maskSam_ST(FileFormat ff)

private void maskSam(ConcurrentReadInputStream cris)

private void mask(BitSet bs, SamLine sl, int reflen)

public static void increment(CoverageArray ca, SamLine sl, byte[] match, int reflen, IntList ranges, boolean includeDels, int samPad)

public static void fillRanges(byte[] longmatch, int start, int stop, IntList ranges, boolean includeDels)

private void handleNoRef(String rname)

private LinkedHashMap<String,Read> hashRef()

private long maskLowComplexity(short[][] matrix)

private static int maskLowComplexity(Read r, int mink, int maxk, int window, float ratio, short[][] matrix)

private static void maskLowComplexity(byte[] bases, BitSet bs, int k, int window, int mincount, short[] counts)

private long maskLowEntropy()

private int maskLowEntropy(Read r, int mink, int maxk, EntropyTracker[] trackers)

private static void maskLowEntropy(byte[] bases, BitSet bs, EntropyTracker et)

private long maskRepeats_ST()

private long maskRepeats()

private static int maskRepeats(Read r, int mink, int maxk, int mincount, int minlen)

private static void maskRepeats(byte[] bases, BitSet bs, int k, int minlen)

private static int repeatLength(byte[] bases, int k, int mask, int loc)

private static int getInitialKey(byte[] bases, int loc, int k)

</class BBMask>
<class BBMerge>
*@author Brian Bushnell
*@date Aug 14, 2012
public class BBMerge

#Fields
private String in1

private String in2

private ArrayList<String> extra=new ArrayList<String>()

private String out1=null

private String out2=null

private String outb1=null

private String outb2=null

private String outinsert=null

private String ihist=null

private String outAdapter=null

private String outCardinality=null

*List of R1 adapters to look for to verify a short-insert overlap
private ArrayList<byte[]> adapterList1

*List of R2 adapters to look for to verify a short-insert overlap
private ArrayList<byte[]> adapterList2

*Require short inserts to have adapter sequence at the expected location
private boolean verifyAdapters=false

final CardinalityTracker loglog

private long maxReads=-1

private boolean join=true

private boolean ecco=false

private boolean trimByOverlap=false

private float pfilterRatio=0.00004f

private float efilterRatio=6f

private float efilterOffset=0.05f

private boolean useEfilter=true

private boolean useMEEfilter=false

private boolean ordered=false

private boolean overlapUsingQuality=false

private boolean overlapWithoutQuality=true

private boolean useKFilter=false

private int filterCutoff=1

private int kmerLength=31

private boolean prealloc=false

private int prefilter=0

private long filterMemoryOverride=0

private boolean eccTail=false

private boolean eccPincer=false

private boolean eccReassemble=true

private boolean useEntropy=true

private int entropyK=3

private int minEntropyScore=39

private long sampleseed=-1

private float samplerate=1

private long errorsCorrectedTotal=0

private boolean findAdapterSequence=false

private boolean ignorePhixAdapters=false

private final AdapterTracker atrack=new AdapterTracker()

private final Tadpole tadpole

private int extendRight1=0

private int extendRight2=0

private int extendIterations=1

private boolean eccTadpole=false

private boolean shave=false

private boolean rinse=false

private final BloomFilter bloomFilter

private final BloomFilterCorrector corrector

private boolean forceExactKmerCounts=false

private boolean testMerge=false

private boolean eccBloom=false

private int bloomBits=2

private int bloomHashes=3

int testMergeWidth=4

long testMergeMult=80L

int testMergeThresh=3

private boolean requireExtensionMatch=false

private boolean requireStrictExtensionMatch=false

private int minApproxOverlapRem=26

private boolean extendThroughLeftJunctions=true

private int minCountSeed=3

private int minCountExtend=2

private float branchMult1=20

private float branchMult2=3

private float minProb=0.5f

private int branchLowerConst=3

private boolean MATE_BY_OVERLAP=true

private boolean MIX_BAD_AND_GOOD=false

private boolean ONLY_OUTPUT_INCORRECT=false

private boolean OUTPUT_FALSE_POSITIVE=true

private boolean OUTPUT_FALSE_NEGATIVE=true

private boolean OUTPUT_TRUE_POSITIVE=true

private boolean OUTPUT_TRUE_NEGATIVE=true

private boolean quantizeQuality=false

private static ThreadLocal<int[]> localRvector=new ThreadLocal<int[]>()

static boolean errorState=false

private static boolean showFullArgs=true

*Recalibrate quality scores using matrices
static boolean recalibrateQuality=false

static boolean useQuality=true

static boolean qtrimRight=false

static boolean qtrimLeft=false

static float[] trimq=new float[]{6}

static float[] trimE=QualityTools.phredToProbError(trimq)

static float minAvgQuality=0

static int minAvgQualityBases=0

static float maxExpectedErrors=0

static int minReadLength=1

static int maxReadLength=-1

static int minInsert=15

static int minInsert0=-1

static boolean qtrim1=false

static boolean qtrim2=false

static int TRIM_ON_OVERLAP_FAILURE=1

static int QUAL_ITERS=3

static boolean parseCustom=false

static int maxAdapterLength=21

static boolean trimNonOverlapping=false

*For adapter output
static boolean trimPolyA=true

static int forceTrimLeft

static int forceTrimRight

static int forceTrimRight2

*Trim right bases of the read modulo this value.
*e.g. forceTrimModulo=50 would trim the last 3bp from a 153bp read.
static int forceTrimModulo

public static boolean strict=false

static boolean vstrict=false

static boolean ustrict=false

static boolean xstrict=false

static boolean loose=false

static boolean vloose=false

static boolean uloose=false

static boolean xloose=false

static boolean fast=false

*If true, interpret lowercase bases as adapter sequence
static boolean lowercaseAdapters=false

private static final int histlen=2000

static long[] histTotal=new long[histlen]

static int bin=1

static long readsProcessedTotal=0

static long basesProcessedTotal=0

static long matedCountTotal=0

static long correctCountTotal=0

static long unmergedOverlappingTotal=0

static long ambiguousCountTotal=0

static long tooShortCountTotal=0

static long tooLongCountTotal=0

static long incorrectCountTotal=0

static long noSolutionCountTotal=0

static long insertSumCorrectTotal=0

static long insertSumIncorrectTotal=0

static long fullyExtendedTotal=0

static long partlyExtendedTotal=0

static long notExtendedTotal=0

static long extensionsAttempted=0

static long adaptersExpected=0

static long adaptersFound=0

static int insertMinTotal=999999999

static int insertMaxTotal=0

private static int MIN_OVERLAPPING_BASES=11

private static int MIN_OVERLAPPING_BASES_0=8

private static int MISMATCH_MARGIN=2

private static int MIN_OVERLAPPING_BASES_RATIO_REDUCTION=3

*Skip alignment and calculate insert from mapping info
protected static boolean USE_MAPPING=false

private static boolean NONZERO_ONLY=true

private static boolean showHistStats=true

static boolean TRAINING=false

static boolean useRatioMode=true

static boolean useFlatMode=false

static boolean requireRatioMatch=false

static int MAX_MISMATCHES_R=20

static float MAX_RATIO=0.09f

static float RATIO_MARGIN=5.5f

static float RATIO_OFFSET=0.55f

static float MIN_SECOND_RATIO=0.1f

public static int MAX_MISMATCHES=3

public static int MAX_MISMATCHES0=3

public static byte MIN_QUALITY=10

public static final int RET_NO_SOLUTION=-1

public static final int RET_AMBIG=-2

public static final int RET_BAD=-3

public static final int RET_SHORT=-4

public static final int RET_LONG=-5

private static boolean overwrite=true

private static boolean append=false

private static final boolean verbose=false

static final boolean TAG_CUSTOM=false

static boolean MAKE_VECTOR=false

private static String defaultNetFile=Data.findPath("?bbmerge.bbnet",false)

static String netFile=defaultNetFile

static CellNet net0=CellNetParser.load(netFile,false)

static float netCutoff=(net0 == null ? 0.5f : net0.cutoff)

private static boolean setCutoff=false

private static boolean ONLY_OUTPUT_FALSE_POSITIVE=false

private static boolean ONLY_OUTPUT_FALSE_NEGATIVE=false

private static boolean EXEMPT_SHORT_OVERLAPS_FROM_STATS=false

private static boolean iupacToN=false

public static boolean changeQuality=true

static PrintStream outstream=System.err

private static int THREADS=-1

private static final byte[] phixPrefix="AGATCGGAAGAGCG".getBytes()

private static final String[] defaultAdapters={"AGATCGGAAGAGCACA","AATGATACGGCGACCA","GATCGGAAGAGCACAC","CTGTCTCTTATACACA","GACGCTGCCGACGA","CCGAGCCCACGAGAC","CTGATGGCGCGAGGGA","CTGAGCGGGCTGGCAA","GATCGGAAGAGCGTCG","GATCGTCGGACTGTAG","CCTTGGCACCCGAGAA","CCACGGGAACGTGGTG","TGGAATTCTCGGGTGC","TCGGACTGTAGAACTC","AGATCGGAAGAGCGGT"}

public static ArrayList<byte[]> staticAdapterList=getAdapterList("default")


#Methods
public static void main(String[] args)

private static String[] preparse(String[] args)

public BBMerge(String[] args)

void process()

public static void writeHistogram(String fname, double percentMerged)

public void runPhase(boolean join, long maxReads, boolean perfectonly)

public static final float mergeableFraction(String fname1, String fname2, long numReads, float samplerate)

public static final long[] makeInsertHistogram(String fname1, String fname2, long numReads, float samplerate)

*Returns the insert size as calculated by overlap, or -1
public static final int findOverlapUStrict(Read r1, Read r2, boolean ecc)

*Returns the insert size as calculated by overlap, or -1
public static final int findOverlapVStrict(Read r1, Read r2, boolean ecc)

public static final Read tryToMerge(Read r1, Read r2)

*Returns the insert size as calculated by overlap, or -1
public static final int findOverlapStrict(Read r1, Read r2, boolean ecc)

*Returns the insert size as calculated by overlap, or -1
public static final int findOverlapLoose(Read r1, Read r2, boolean ecc)

*Returns the insert size as calculated by overlap, or -1
public static final int findOverlap(Read r1, Read r2, boolean ecc, int minOverlap, int minOverlap0, int minInsert, int minInsert0, int entropy, float maxRatio, float minSecondRatio, float ratioMargin, float ratioOffset, float efilterRatio, float efilterOffset, float pfilterRatio)

public static int errorCorrectWithInsert(Read r1, Read r2, int insert)

public static int countErrors(Read r1, Read r2, Read joined)

*Assumes both reads are in original orientation
public static int countErrors(Read r1, Read r2, int insert)

*Assumes both reads are in original orientation
public static int countErrors(byte[] bases1, byte[] bases2, int insert)

public static String header()

private static void qtrim(Read r1, Read r2, int iter)

public static final ArrayList<byte[]> getAdapterList(String name)

private static boolean verifyAdaptersStatic(Read r1, Read r2, int bestInsert)

*Returns 0=bad, 1=unknown, 2=good
private static int adapterIsValid(Read r, byte[] adapter, int insert, int minAdapterOverlap, float minAdapterRatio)

public static void resetCounters()

private static void loadNet(String fname)

</class BBMerge>
<class BBMergeOverlapper>
*@author Brian Bushnell
*@date Apr 15, 2014
public final class BBMergeOverlapper

#Fields
private static ThreadLocal<short[]> localKmerCounts=new ThreadLocal<short[]>()

private static final int BAD_MULT=6

private static final int GOOD_MULT_1=8

private static final int GOOD_MULT_2=400

private static boolean TAG_CUSTOM=BBMerge.TAG_CUSTOM

static boolean MAKE_VECTOR=BBMerge.MAKE_VECTOR

private static int extraBadlimit=20

protected static final boolean verbose=false

private static final float[] probCorrect3={0.000f,0.251f,0.369f,0.499f,0.602f,0.684f,0.749f,0.800f,0.842f,0.874f,0.900f,0.921f,0.937f,0.950f,0.960f,0.968f,0.975f,0.980f,0.984f,0.987f,0.990f,0.992f,0.994f,0.995f,0.996f,0.997f,0.997f,0.998f,0.998f,0.999f,0.999f,0.999f,0.999f,0.999f,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}

private static final float[] probCorrect4={0.0000f,0.2501f,0.3690f,0.4988f,0.6019f,0.6838f,0.7488f,0.8005f,0.8415f,0.8741f,0.9000f,0.9206f,0.9369f,0.9499f,0.9602f,0.9684f,0.9749f,0.9800f,0.9842f,0.9874f,0.9900f,0.9921f,0.9937f,0.9950f,0.9960f,0.9968f,0.9975f,0.9980f,0.9984f,0.9987f,0.9990f,0.9992f,0.9994f,0.9995f,0.9996f,0.9997f,0.9997f,0.9998f,0.9998f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f}

private static final float[] probCorrect5={0.20000f,0.20567f,0.36904f,0.49881f,0.60189f,0.68377f,0.74881f,0.80047f,0.84151f,0.87411f,0.90000f,0.92057f,0.93690f,0.94988f,0.96019f,0.96838f,0.97488f,0.98005f,0.98415f,0.98741f,0.99000f,0.99206f,0.99369f,0.99499f,0.99602f,0.99684f,0.99749f,0.99800f,0.99842f,0.99874f,0.99900f,0.99921f,0.99937f,0.99950f,0.99960f,0.99968f,0.99975f,0.99980f,0.99984f,0.99987f,0.99990f,0.99992f,0.99994f,0.99995f,0.99996f,0.99997f,0.99997f,0.99998f,0.99998f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f,0.99999f}


#Methods
private static final int mateByOverlapJNI(byte[] a_bases, byte[] b_bases, byte[] a_quality, byte[] b_quality, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int margin, int maxMismatches0, int maxMismatches, int minq)

private static final int mateByOverlapRatioJNI_WithQualities(byte[] a_bases, byte[] b_bases, byte[] a_quality, byte[] b_quality, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int minInsert, float maxRatio, float margin, float offset)

private static final int mateByOverlapRatioJNI(byte[] a_bases, byte[] b_bases, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int minInsert, float maxRatio, float margin, float offset, float gIncr, float bIncr)

protected static final int mateByOverlap(Read a, Read b, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int margin, int maxMismatches0, int maxMismatches, int minq)

public static final int mateByOverlapRatio(Read a, Read b, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int minInsert, float maxRatio, float minSecondRatio, float margin, float offset, float gIncr, float bIncr, boolean useQuality)

protected static final int mateByOverlapRatioJava_WithQualities(Read a, Read b, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int minInsert, float maxRatio, float minSecondRatio, float margin, float offset)

protected static final int mateByOverlapRatioJava(Read a, Read b, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int minInsert, float maxRatio, float minSecondRatio, float margin, float offset, float gIncr, float bIncr)

protected static final float findBestRatio_WithQualities(Read a, Read b, float[] aprob, float[] bprob, int minOverlap0, int minOverlap, int minInsert, float maxRatio, float offset)

protected static final float findBestRatio_WithQualitiesTraining(Read a, Read b, float[] aprob, float[] bprob, int minOverlap0, int minOverlap, int minInsert, float maxRatio, float offset)

protected static final float findBestRatio(Read a, Read b, int minOverlap0, int minOverlap, int minInsert, float maxRatio, float offset, float gIncr, float bIncr)

protected static final int mateByOverlapJava_unrolled(Read a, Read b, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int margin, int maxMismatches0, int maxMismatches, int minq)

protected static final int mateByOverlapJava_unrolled_training(Read a, Read b, float[] aprob, float[] bprob, int[] rvector, int minOverlap0, int minOverlap, int minInsert0, int margin, int maxMismatches0, int maxMismatches, int minq)

*TODO Use this
*@param a
*@param b
*@param overlap
*@return
public static final float expectedMismatches(Read a, Read b, int overlap)

*Attempt at quantifying probability of an event like this.
*TODO: This returns an incorrect answer if reads are unequal lengths.
public static final float probability(Read a, Read b, int insert)

protected static int minCoverage(Read r, Tadpole tadpole, int k, int cutoff)

protected static int minCoverage(Read r, Tadpole1 tadpole, int k, int cutoff)

protected static int minCoverage(Read r, Tadpole2 tadpole, int k, int cutoff)

protected static int calcMinOverlapByEntropy(byte[] bases, int k, short[] counts, int minscore)

protected static int calcMinOverlapByEntropyTail(byte[] bases, int k, short[] counts, int minscore)

protected static int calcMinOverlapByEntropyHead(byte[] bases, int k, short[] counts, int minscore)

</class BBMergeOverlapper>
<class BBQC>
*Wrapper for BBDukF, BBMap, and BBNorm to perform quality-control and artifact removal.
*@author Brian Bushnell
*@date Jan 20, 2013
public class BBQC

#Fields
private boolean removehuman=true

private boolean normalize=false

private boolean ecc=false

private boolean aecc=false

private boolean cecc=false

private boolean meo=false

private boolean tam=false

private boolean trimAfterFiltering=true

private boolean mue=false

private boolean mw1=false

private int maxdepth=-1

private int mindepth=6

private int target=50

private int prehashes=3

private int passes=2

private int hashes=4

private int bits=16

*Symbols to insert in output filename to denote operations performed
private final String symbols

*True for rna artifacts, false for dna artifacts
private boolean rnaFlag=false

*True if phix should be filtered out
private boolean phixFlag=true

*True if lambda should be filtered out by kmer-match
private boolean lambdaFlag=true

*True if pjet should be filtered out
private boolean pjetFlag=true

*Unused
private boolean tboFlag=false

*Unused
private boolean tpeFlag=false

*Toss reads shorter than this
private int minLen=40

*Toss reads shorter than this fraction of initial length, after trimming
private float minLenFraction=0.6f

*Trim bases at this quality or below
private float trimq=12

*Throw away reads below this average quality after trimming. Default: 8
private float minAvgQuality=8

*If positive, calculate the average quality from the first X bases.
private int minAvgQualityBases=0

*Trim reads to be equal to 0 modulo this value. Mainly for 151, 251, and 301bp runs.
private int forceTrimModulo=5

*Quality-trimming mode
private String qtrim="rl"

*Kmer-trimming mode
private String ktrim="r"

*Kmer length to use for filtering
private int filter_k=27

*Kmer length to use for trimming
private int trim_k=23

*Kmer length to use for normalization and error-correction
private int normalize_k=31

*Kmer length to use for mapping
private int map_k=13

*Shortest kmer to use for trimming
private int mink=11

*Throw away reads containing more than this many Ns. Default: 1
private int maxNs=1

*Use this Hamming distance when kmer filtering
private int hdist_filter=1

*Use this Hamming distance when kmer trimming
private int hdist_trim=1

*Use this Hamming distance when kmer trimming with short kmers
private int hdist2_trim=-1

*Captures the command line "pigz" flag
private String pigz

*Captures the command line "unpigz" flag
private String unpigz

*Captures the command line "zl" flag
private String zl

private float minratio=0.84f

private int maxindel=6

private int kfilter=0

private int minhits=1

private boolean fast=true

private boolean local=true

private boolean copyUndefined=false

private boolean verbose=false

private boolean overwrite=true

private boolean compress=true

*Arguments to pass to BBDuk
private ArrayList<String> primaryArgList=new ArrayList<String>()

*References to pass to BBDuk for artifact removal
private ArrayList<String> trimrefs=new ArrayList<String>()

*References to pass to BBDuk for artifact removal
private ArrayList<String> filterrefs=new ArrayList<String>()

*Directory in which to write all files
private String outDir=""

*Directory in which to write all temp files
private String tmpDir=Shared.tmpdir()

private final String tempSalt

*Primary input reads file (required)
private String in1=null

*Secondary input reads file
private String in2=null

*Primary output reads file (required)
private String out1=null

*Secondary output reads file
private String out2=null

*Primary input qual file
private String qfin1=null

*Secondary input qual file
private String qfin2=null

*Primary output qual file
private String qfout1=null

*Secondary output qual file
private String qfout2=null

private String logName="status.log"

private String fileListName="file-list.txt"

private String rqcStatsName="filterStats.txt"

private String kmerStatsName="kmerStats.txt"

private String scaffoldStatsName="scaffoldStats.txt"

private String kmerHistName="khist.txt"

private String ihistName=null

*ktrim phase rqc stats file
private String rqcStatsName_kt

*ktrim phase stats file
private String kmerStatsName_kt

*ktrim phase scaffold stats file
private String scaffoldStatsName_kt

private String mainArtifactFile="/global/dna/shared/rqc/ref_databases/qaqc/databases/illumina.artifacts/Illumina.artifacts.2013.12.no_DNA_RNA_spikeins.fa"

private String artifactFileRna="/global/dna/shared/rqc/ref_databases/qaqc/databases/illumina.artifacts/RNA_spikeins.artifacts.2012.10.NoPolyA.fa"

private String artifactFileDna="/global/dna/shared/rqc/ref_databases/qaqc/databases/illumina.artifacts/DNA_spikeins.artifacts.2012.10.fa"

private String phixRef="/global/dna/shared/rqc/ref_databases/qaqc/databases/phix174_ill.ref.fa"

private String lambdaRef="/global/dna/shared/rqc/ref_databases/qaqc/databases/lambda.fa.gz"

private String pjetRef="/global/dna/shared/rqc/ref_databases/qaqc/databases/pJET1.2.fasta"

private String allArtifactsLatest="/global/projectb/sandbox/rqc/qcdb/illumina.artifacts/Illumina.artifacts.fa"

private String fragAdapters="/global/cfs/cdirs/bbtools/data/adapters.fa"

private String rnaAdapter="/global/cfs/cdirs/bbtools/data/truseq_rna.fa.gz"

private String indexPath="/global/cfs/cdirs/bbtools/hg19/"

private String mapRef=null


#Methods
*Program entrance from command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
BBQC(String[] args)

*Primary method to fully execute the program.
public void process()

*Runs BBDuk to perform:
*Kmer trimming, short read removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param qfin1 Primary input qual file
*@param qfin2 Secondary input qual file
*@param qfout1 Primary output qual file
*@param qfout2 Secondary output qual file
*@param outPrefix Append this prefix to output filenames
private void ktrim(String in1, String in2, String out1, String out2, String qfin1, String qfin2, String qfout1, String qfout2, String outPrefix)

*Runs BBDuk to perform:
*Quality filtering, quality trimming, n removal, short read removal, artifact removal (via kmer filtering), phiX removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param qfin1 Primary input qual file
*@param qfin2 Secondary input qual file
*@param qfout1 Primary output qual file
*@param qfout2 Secondary output qual file
*@param inPrefix Append this prefix to input filenames
private void filter(String in1, String in2, String out1, String out2, String qfin1, String qfin2, String qfout1, String qfout2, String inPrefix, String outPrefix, boolean prependIndir, boolean prependOutdir, boolean lastPhase)

*Runs BBMap to perform:
*Removal of reads that map to human with high identity (~88%).
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param qfin1 Primary input qual file
*@param qfin2 Secondary input qual file
*@param qfout1 Primary output qual file
*@param qfout2 Secondary output qual file
*@param inPrefix Append this prefix to input filenames
private void dehumanize(String in1, String in2, String out1, String out2, String qfin1, String qfin2, String inPrefix, String outPrefix, boolean prependIndir, boolean prependOutdir, boolean lastPhase)

*Runs BBNorm to perform:
*Error correction, error marking, quality trimming, normalization
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param qfin1 Primary input qual file
*@param qfin2 Secondary input qual file
*@param qfout1 Primary output qual file
*@param qfout2 Secondary output qual file
*@param inPrefix Append this prefix to input filenames
private void normalize(String in1, String in2, String out1, String out2, String qfin1, String qfin2, String qfout1, String qfout2, String inPrefix, String outPrefix, boolean prependIndir, boolean prependOutdir, boolean lastPhase)

*Log a message in the log file
*@param message Message to log
*@param append True to append, false to overwrite
private void log(String message, boolean append)

*Delete all non-null filenames.
*@param prefix Append this prefix to filenames before attempting to delete them
*@param names Filenames to delete
private void delete(String prefix, String names)

*Delete all non-null filenames.
*@param prefix Append this prefix to filenames before attempting to delete them
*@param names Filenames to delete
private void move(String prefix, String names)

*@return String of symbols indicating which processes were applied to the input reads
private String abbreviation()

*TODO: Some machines are set to UTC rather than PST
*@return Timestamp in RQC's format
public static String timeString()

private static String stripDirs(String path)

</class BBQC>
<class CalcTrueQuality>
*@author Brian Bushnell
*@date Jan 13, 2014
public class CalcTrueQuality

#Fields
private VarMap varMap

private ScafMap scafMap

private ReadStats readstats

private boolean callVariants=false

private boolean writeMatrices=true

private boolean useStreamer=true

private int streamerThreads=3

ArrayList<GBMatrixSet> gbmatrices=new ArrayList<GBMatrixSet>()

private PrintStream outstream=System.err

private long maxReads=-1

private String[] in

private String qhist=null

private String varFile=null

private String vcfFile=null

private long readsProcessed=0

private long basesProcessed=0

private long readsUsed=0

private long basesUsed=0

private long varsFixed=0

private long varsTotal=0

private boolean errorState=false

private final int threads

final boolean incrQ102

final boolean incrQap

final boolean incrQbp

final boolean incrQpt

final boolean incrQbt

final boolean incrQ10

final boolean incrQ12

final boolean incrQb12

final boolean incrQb012

final boolean incrQb123

final boolean incrQb234

final boolean incrQ12b12

final boolean incrQp

final boolean incrQ

final VarFilter filter=new VarFilter()

int ploidy=1

boolean prefilter=true

String ref=null

boolean realign=false

public static boolean showStats=true

private static boolean verbose=false

private static boolean overwrite=true

private static final boolean append=false

public static int passes=2

private static String q102matrix="?q102matrix_p#.txt.gz"

private static String qapmatrix="?qapmatrix_p#.txt.gz"

private static String qbpmatrix="?qbpmatrix_p#.txt.gz"

private static String qptmatrix="?qptmatrix_p#.txt.gz"

private static String qbtmatrix="?qbtmatrix_p#.txt.gz"

private static String q10matrix="?q10matrix_p#.txt.gz"

private static String q12matrix="?q12matrix_p#.txt.gz"

private static String qb12matrix="?qb12matrix_p#.txt.gz"

private static String qb012matrix="?qb012matrix_p#.txt.gz"

private static String qb123matrix="?qb123matrix_p#.txt.gz"

private static String qb234matrix="?qb234matrix_p#.txt.gz"

private static String q12b12matrix="?q12b12matrix_p#.txt.gz"

private static String qpmatrix="?qpmatrix_p#.txt.gz"

private static String qmatrix="?qmatrix_p#.txt.gz"

private static String pmatrix="?pmatrix_p#.txt.gz"

private static final boolean[] initialized={false,false}

private static int QMAX=Read.MAX_CALLED_QUALITY()

private static int QEND=QMAX + 1

private static int QMAX2=QEND + 1

private static final int BMAX=6

private static final int LENMAX=361

private static final int TMAX=400

private static final byte[] baseToNum=fillBaseToNum()

private static final byte[] numToBase={'A','C','G','T','E','N'}

private static final float[] PROB_ERROR=QualityTools.PROB_ERROR

private static final float[] INV_PROB_ERROR=Tools.inverse(PROB_ERROR)

private static final CountMatrixSet[] cmatrices=new CountMatrixSet[2]

public static boolean[] use_q102={false,false}

public static boolean[] use_qap={false,false}

public static boolean[] use_qbp={true,true}

public static boolean[] use_qpt={false,false}

public static boolean[] use_qbt={false,false}

public static boolean[] use_q10={false,false}

public static boolean[] use_q12={false,false}

public static boolean[] use_qb12={false,false}

public static boolean[] use_qb012={true,false}

public static boolean[] use_qb123={true,false}

public static boolean[] use_qb234={true,false}

public static boolean[] use_q12b12={false,false}

public static boolean[] use_qp={false,false}

public static boolean[] use_q={false,false}

public static boolean USE_SMR=false

public static boolean USE_WEIGHTED_AVERAGE=true

public static boolean USE_AVERAGE=true

public static boolean USE_PAIRNUM=true

public static boolean COUNT_INDELS=true

public static boolean TRACK_ALL=false

public static boolean USE_TILES=use_qpt[0] || use_qpt[1] || use_qbt[0]|| use_qbt[1]

public static long OBSERVATION_CUTOFF={100,200}

public static float BAD_CUTOFF=0.5f


#Methods
*Calls main() but restores original static variable values.
public static void main2(String[] args)

public CalcTrueQuality(String[] args)

public void process()

public void process(int pass)

public void process_MT(String fname, int pass, int fnum)

static void add(long[] dest, long[] source)

static void add(long[][] dest, long[][] source)

static void add(long[][][] dest, long[][][] source)

static void add(long[][][][] dest, long[][][][] source)

static void add(long[][][][][] dest, long[][][][][] source)

public void writeMatrices(int pass)

public static void writeMatrix(String fname, long[][][][][] goodMatrix, long[][][][][] badMatrix, boolean overwrite, boolean append, int pass)

public static void writeMatrix(String fname, long[][][][] goodMatrix, long[][][][] badMatrix, boolean overwrite, boolean append, int pass)

public static void writeMatrix(String fname, long[][][] goodMatrix, long[][][] badMatrix, boolean overwrite, boolean append, int pass)

public static void writeMatrix(String fname, long[][] goodMatrix, long[][] badMatrix, boolean overwrite, boolean append, int pass)

public static void writeMatrix(String fname, long[] goodMatrix, long[] badMatrix, boolean overwrite, boolean append, int pass)

public static int parseTile(String s)

public static final void recalibrate(Read r)

private static final void recalibrate(Read r, boolean pass0, boolean pass1)

public static final byte[] recalibrate(byte[] bases, byte[] quals, int pairnum, int tile, int pass)

public static final void unloadMatrices()

public static final void initializeMatrices()

public static final void initializeMatrices(int pass)

private static double modify(double sum, double bad, int phred, long cutoff)

public static final float[][][][][] toProbs(long[][][][][] sumMatrix, long[][][][][] badMatrix, long cutoff)

public static final float[][][][] toProbs(long[][][][] sumMatrix, long[][][][] badMatrix, long cutoff)

public static final float[][][] toProbs(long[][][] sumMatrix, long[][][] badMatrix, long cutoff)

public static final float[][] toProbs(long[][] sumMatrix, long[][] badMatrix, long cutoff)

private static String findPath(String fname)

public static final long[][] loadMatrix(String fname, int d0)

public static final long[][][] loadMatrix(String fname, int d0, int d1)

public static final long[][][][] loadMatrix(String fname, int d0, int d1, int d2)

public static final long[][][][][] loadMatrix(String fname, int d0, int d1, int d2, int d3)

public static final long[][][][][][] loadMatrix(String fname, int d0, int d1, int d2, int d3, int d4)

private static byte[] fillBaseToNum()

public static final void setQmax(int x)

</class CalcTrueQuality>
<class CalcTrueQuality.GBMatrixSet>
*Good Bad Matrix.
*Tracks counts of calls being correct or incorrect under the specified conditions.
*For example, q12GoodMatrix[0][10][15] tracks the number of times correct calls were observed,
*for Q10 bases followed by q15 bases, in read 1 (0 for first dimension).
*q = quality
*p = position
*a = average quality
*1 = this position (other positions are relative to this position)
*@author Brian Bushnell
*@date Jan 13, 2014
class CalcTrueQuality.GBMatrixSet

#Fields
final long[][][][] q102GoodMatrix=new long[2][QMAX2][QMAX2][QMAX2]

final long[][][][] q102BadMatrix=new long[2][QMAX2][QMAX2][QMAX2]

final long[][][][] qapGoodMatrix=new long[2][QMAX2][QMAX + 1][LENMAX]

final long[][][][] qapBadMatrix=new long[2][QMAX2][QMAX + 1][LENMAX]

final long[][][][] qbpGoodMatrix=new long[2][QMAX2][BMAX][LENMAX]

final long[][][][] qbpBadMatrix=new long[2][QMAX2][BMAX][LENMAX]

final long[][][][] qptGoodMatrix=new long[2][QMAX2][LENMAX][TMAX]

final long[][][][] qptBadMatrix=new long[2][QMAX2][LENMAX][TMAX]

final long[][][][] qbtGoodMatrix=new long[2][QMAX2][BMAX][TMAX]

final long[][][][] qbtBadMatrix=new long[2][QMAX2][BMAX][TMAX]

final long[][][] q10GoodMatrix=new long[2][QMAX2][QMAX2]

final long[][][] q10BadMatrix=new long[2][QMAX2][QMAX2]

final long[][][] q12GoodMatrix=new long[2][QMAX2][QMAX2]

final long[][][] q12BadMatrix=new long[2][QMAX2][QMAX2]

final long[][][][] qb12GoodMatrix=new long[2][QMAX2][BMAX][BMAX]

final long[][][][] qb12BadMatrix=new long[2][QMAX2][BMAX][BMAX]

final long[][][][][] qb012GoodMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] qb012BadMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] qb123GoodMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] qb123BadMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] qb234GoodMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] qb234BadMatrix=new long[2][QMAX2][BMAX][BMAX][BMAX]

final long[][][][][] q12b12GoodMatrix=new long[2][QMAX2][QMAX2][BMAX][BMAX]

final long[][][][][] q12b12BadMatrix=new long[2][QMAX2][QMAX2][BMAX][BMAX]

final long[][][] qpGoodMatrix=new long[2][QMAX2][LENMAX]

final long[][][] qpBadMatrix=new long[2][QMAX2][LENMAX]

final long[][] qGoodMatrix=new long[2][QMAX2]

final long[][] qBadMatrix=new long[2][QMAX2]

final long[][] pGoodMatrix=new long[2][LENMAX]

final long[][] pBadMatrix=new long[2][LENMAX]

final int pass


#Methods
GBMatrixSet(int pass_)

final void add(GBMatrixSet incr)

public void write()

</class CalcTrueQuality.GBMatrixSet>
<class CalcTrueQuality.CountMatrixSet>
static class CalcTrueQuality.CountMatrixSet

#Fields
public long[][][][][] q102CountMatrix

public long[][][][][] qapCountMatrix

public long[][][][][] qbpCountMatrix

public long[][][][][] qptCountMatrix

public long[][][][][] qbtCountMatrix

public long[][][][] q10CountMatrix

public long[][][][] q12CountMatrix

public long[][][][][] qb12CountMatrix

public long[][][][][][] qb012CountMatrix

public long[][][][][][] qb123CountMatrix

public long[][][][][][] qb234CountMatrix

public long[][][][][][] q12b12CountMatrix

public long[][][][] qpCountMatrix

public long[][][] qCountMatrix

public float[][][][] q102ProbMatrix

public float[][][][] qapProbMatrix

public float[][][][] qbpProbMatrix

public float[][][][] qptProbMatrix

public float[][][][] qbtProbMatrix

public float[][][] q10ProbMatrix

public float[][][] q12ProbMatrix

public float[][][][] qb12ProbMatrix

public float[][][][][] qb012ProbMatrix

public float[][][][][] qb123ProbMatrix

public float[][][][][] qb234ProbMatrix

public float[][][][][] q12b12ProbMatrix

public float[][][] qpProbMatrix

public float[][] qProbMatrix

final int pass


#Methods
CountMatrixSet(int pass_)

*@param bases
*@param quals
*@param pairnum
*@return recalibrated quality scores
public byte[] recalibrate(byte[] bases, byte[] quals, int pairnum, int tile)

void load()

public final float estimateErrorProbAvg(byte[] quals, byte[] bases, int pos, int pairnum, int aq, int tile)

public final float estimateErrorProbMax(byte[] quals, byte[] bases, int pos, int pairnum, int aq, int tile)

public final float estimateErrorProbGeoAvg(byte[] quals, byte[] bases, int pos, int pairnum, int aq, int tile)

public final float estimateErrorProbWeighted(byte[] quals, byte[] bases, int pos, int pairnum, int tile, float obs_cutoff, int aq)

public final float estimateErrorProbSMR(byte[] quals, byte[] bases, int pos, int pairnum, int tile, float obs_cutoff, int aq)

</class CalcTrueQuality.CountMatrixSet>
<class CalcUniqueness>
*@author Brian Bushnell
*@date Mar 24, 2014
public class CalcUniqueness

#Fields
private String in1=null

private String in2=null

private String out=null

private String extin=null

private String extout=null

private final Counter r1CounterFirst=new Counter(1)

private final Counter r1CounterRand=new Counter(2)

private final Counter r2CounterFirst=new Counter(4)

private final Counter r2CounterRand=new Counter(8)

private final Counter pairCounter=new Counter(16)

private final Counter bothCounterFirst=new Counter(32)

private final Counter bothCounterRand=new Counter(64)

private long maxReads=-1

private float samplerate=1f

private long sampleseed=-1

private long interval=25000

private float minprob=0

private float minAverageQuality=0

private int minAverageQualityBases=20

private int singleOffset=0

private boolean cumulative=false

private boolean showPercents=true

private boolean showCounts=false

private boolean printLastBin=false

private boolean showQuality=true

private boolean fixSpikes=false

private final int k

private final int k2

private static final int WAYS=31

private static final int PAIR_OFFSET=10

*Initial size of data structures
private int initialSize=512000

*Hold kmers. A kmer X such that X%WAYS=Y will be stored in keySets[Y]
private final AbstractKmerTable[] keySets

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean testsize=false

private static final boolean useForest=false

private static final boolean useTable=false

private static final boolean useArray=true

private Random randy

private static final float[] probCorrect={0.0000f,0.2501f,0.3690f,0.4988f,0.6019f,0.6838f,0.7488f,0.8005f,0.8415f,0.8741f,0.9000f,0.9206f,0.9369f,0.9499f,0.9602f,0.9684f,0.9749f,0.9800f,0.9842f,0.9874f,0.9900f,0.9921f,0.9937f,0.9950f,0.9960f,0.9968f,0.9975f,0.9980f,0.9984f,0.9987f,0.9990f,0.9992f,0.9994f,0.9995f,0.9996f,0.9997f,0.9997f,0.9998f,0.9998f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,0.9999f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f,1f}


#Methods
public static void main(String[] args)

public CalcUniqueness(String[] args)

void process(Timer t)

private void printCountsToBuffer(StringBuilder sb, long pairsProcessed, boolean paired)

*Generate a kmer from specified start location
*@param bases
*@param start
*@param klen kmer length
*@return kmer
private final long toKmer(byte[] bases, byte[] quals, int start, int klen)

*Generate the probability a kmer is error-free, from specified start location
*@param quals
*@param start
*@param klen kmer length
*@return kmer
private static final float toProb(byte[] quals, int start, int klen)

public void setSampleSeed(long seed)

</class CalcUniqueness>
<class CallPeaks>
*@author Brian Bushnell
*@date Oct 28, 2014
public class CallPeaks

#Fields
private long minHeight=2

private long minVolume=5

private int minWidth=3

private int minPeak=2

private int maxPeak=Integer.MAX_VALUE

private int maxPeakCount=10

private float maxWidthMult=2.5f

private int smoothRadius=0

private boolean smoothProgressiveFlag=true

private int k=31

private int ploidyClaimed=-1

private boolean logScale=false

private double logWidth=0.1

private int logPasses=1

private String in

private String out

private final FileFormat ffin

private final FileFormat ffout

public static int maxRadius=10

public static float progressiveMult=2

private static int countColumn=1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

public static boolean printClass=true

public static boolean callByRawCount=false

public static boolean weightByRelief=false

public static final int BY_VOLUME=0

public static final int BY_HEIGHT=1

public static int CALL_MODE=BY_VOLUME

public static int ploidyLogic=2


#Methods
public CallPeaks(String[] args)

public void process(Timer t)

public static boolean printPeaks(long[] array, long[] gcArray, String fname, boolean ow, long minHeight, long minVolume, int minWidth, int minPeak, int maxPeak, int maxPeakCount, int k, int ploidy, boolean logScale, double logWidth, ArrayList<String> list)

public static LongList[] loadHistogram(FileFormat ff, int k)

private static ArrayList<Peak> condense(ArrayList<Peak> in, int maxCount)

private static void capWidth(ArrayList<Peak> peaks, float maxWidthMult, long[] counts)

private void printPeaks(ArrayList<Peak> peaks, int k, long uniqueKmers, long[] hist, long[] gcHist)

private static Peak firstGenomicPeak(ArrayList<Peak> peaks, float minFraction)

private static float singleCopyKmerFraction(float hetRate, int k, int ploidy)

private static long errorKmers(ArrayList<Peak> peaks, long[] hist, float minVolumeFraction)

private static long genomeSizeInPeaks(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter)

private static long genomeSize2(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter, long[] hist)

private static double gcContent(ArrayList<Peak> peaks, int k)

private static double gcContent2(ArrayList<Peak> peaks, int k, long[] hist, long[] gcHist)

*Based on all peaks
private static long repeatSize(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter)

*Based on ploidy peak only
private static long repeatSize2(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter, long[] hist)

private static int biggestPeak(ArrayList<Peak> peaks)

private static int secondBiggestPeak(ArrayList<Peak> peaks)

private static int homozygousPeak(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter)

private static float haploidPeakCenter(ArrayList<Peak> peaks, int ploidy)

private static int calcPloidy(ArrayList<Peak> peaks, float minVolumeFraction)

private static long calcHetLocations(ArrayList<Peak> peaks, int ploidy, float haploidPeakCenter, int k)

public ArrayList<Peak> callPeaks(LongList list, LongList gcList)

public ArrayList<Peak> callPeaks(long[] original, long gcArray, int length)

private static void recalculate(ArrayList<Peak> peaks, long[] array)

public static long[] logScale(long[] array, double width, double scale, int passes)

public static long[] smoothProgressive(long[] data, int radius0)

public static long[] smooth(long[] data, int radius)

private static long sumPoint(long[] data, int loc, int radius)

public static int[] smoothProgressive(int[] data, int radius0)

public static int[] smooth(int[] data, int radius)

private static long sumPoint(int[] data, int loc, int radius)

</class CallPeaks>
<class CheckStrand>
*Checks the strandedness of RNA-seq reads.
*@author Brian Bushnell
*@date Aug 4, 2023
public class CheckStrand

#Fields
private int sketchSize=20000

private String in1=null

private String out1="stdout.txt"

String fna=null

String gff=null

String pgmFile=null

private final FileFormat ffin1

private final FileFormat ffout1

*Features to pull from gff files
private String types="CDS,rRNA,tRNA,ncRNA,exon,5S,16S,23S"

private boolean normalize=false

private long maxReads=-1

private float samplerate=1

private long sampleseed=17

private boolean errorState=false

static final double[] expectedMinorAlleleCount=makeExpectedMinorAlleleArray(10000,100000)

static final double[] expectedMinorAlleleFreq=makeExpectedMinorAlleleFreq(expectedMinorAlleleCount)

*Output screen messages here
private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CheckStrand(String[] args)

void process(Timer t)

private void setSketchStatics()

*Calculate the Plus/Minus mapping ratio using transcriptome kmers.
*@param canonTool SketchTool for canonical kmers.
*@param fwdTool SketchTool for forward kmers.
*@param canonSketch Read Sketch using canonical kmers.
*@param fwdSketch Read Sketch using forward kmers.
*@return Array of results (see calcPMRatio).
private double[] calcPMRatioWithRef(SketchTool canonTool, SketchTool fwdTool, Sketch canonSketch, Sketch fwdSketch)

*Generate a list of gene sequences from the reference.
*@return The list.
private ArrayList<Read> grabGenes()

*Calculate the Plus/Minus mapping ratio using transcriptome kmers.
*@param canonSketch Read Sketch using canonical kmers.
*@param fwdSketch Read Sketch using forward kmers.
*@param canonGeneSketch Transcriptome Sketch using canonical kmers.
*@param plusSketch Transcriptome Sketch using plus-strand forward kmers.
*@param minusSketch Transcriptome Sketch using minus-strand forward kmers.
*@return Results vector: {ratio, abFractions[0], abFractions[1]}
static double[] calcPMRatioWithGeneSketches(Sketch canonSketch, Sketch fwdSketch, Sketch canonGeneSketch, Sketch plusSketch, Sketch minusSketch)

*Create sketches of the transcriptome.
*@param genes List of gene sequences (sense on plus strand).
*@param canonTool SketchTool for canonical kmers.
*@param fwdTool SketchTool for forward kmers.
*@return Vector of: {canonGeneSketch, plusSketch, minusSketch}
static Sketch[] sketchGenes(ArrayList<Read> genes, SketchTool canonTool, SketchTool fwdTool)

*Print the final program results.
*@param results Results from read kmer depth analysis
*@param refResults Results based on transcriptome kmer comparison
private void outputResults(double[] results, double[] refResults)

*Determine the strandedness of a set of reads by comparing a Sketch of
*canonical kmers to forward kmers.
*@param saCanon Sketch of canonical kmers.
*@param sbFwd Sketch of forward kmers.
*@return Results vector: {totalSum, minSum, expectedMinSum, maxPossibleMinSum,
*strandedness, depth, matches, nonUniqueFraction}
static double[] calcStrandedness(Sketch saCanon, Sketch sbFwd)

*Determine the strandedness of a set of reads by comparing a Sketch of
*canonical kmers to forward kmers.
*In this mode, each kmer contributes 0-1.0 strandedness regardless of its depth.
*@param saCanon Sketch of canonical kmers.
*@param sbFwd Sketch of forward kmers.
*@return Results vector: {totalSum, minSum, expectedMinSum, maxPossibleMinSum,
*strandedness, depth, matches, nonUniqueFraction}
static double[] calcStrandednessNormalized(Sketch saCanon, Sketch sbFwd)

static float strandedness(long plus, long minus)

static float strandedness(long plus, long minus, long maxPossibleMinor, float expectedMinor)

*Counts the fraction of total kmers shared between sketches, which includes their counts.
*@param saFwd Forward sketch of reads.
*@param sbTranscriptStrand Forward (or reverse) sketch of transcriptome.
*@return Results vector: {totalSum, depth, matches, sharedSum}
static double[] countSharedSum(Sketch saFwd, Sketch sbTranscriptStrand)

*Calculate each sketch's fractional coverage of the other sketch, ignoring counts.
*@return Results vector: {aFraction, bFraction},
*where aFraction is sketch a's coverage of sketch b.
static double[] calcCoverage(Sketch sa, Sketch sb)

*This works for a diploid het allele, or a fair coin, or other things with 50/50 outcomes.
*Returns the expected minor allele frequency for a given depth.
*@param depth i.e., number of observations.
*@return Expected number of observations of the minor allele.
public static final double expectedMinorAlleleFrequency(long depth)

public static final double expectedMinorAlleleCount(long depth)

*This is for generating the stats file for loading later; only needed once.
private static void printMinorAlleleCount()

*Runs a simulation. This will happen automatically if minorAlleleCount.txt is not found,
*but it will be less precise due to fewer trials. The total number of coin flips
*is maxDepth*trials.
*@param maxDepth Max total allele count (coin flips in a series).
*@param trials Number of simulated series.
*@return Array of average minor allele counts.
public static final double[] makeExpectedMinorAlleleArray(int maxDepth, int trials)

*Load minor allele counts from a file.
*It should be in bbmap/resources/minorAlleleCount.txt
public static double[] loadExpectedMinorAlleleArray()

*Make the frequency array from the count array
private static double[] makeExpectedMinorAlleleFreq(double[] counts)

*Load a gff file.
*@param gff The file path.
*@param types Types of features to load, such as "CDS,rRNA".
*@return
static ArrayList<GffLine> getGffLines(String gff, String types)

*Load a fasta file as a HashMap of names to sequences.
*@param fna Fasta file.
*@return Map of names to sequences.
static HashMap<String,Read> getSequenceMap(String fna)

*Generate a map of names to sequences from a list of sequences.
*Also maps name prefix up to the first whitespace.
*@param list List of sequences.
*@return The map.
static HashMap<String,Read> getSequenceMap(ArrayList<Read> list)

*Generates a list of sequences by cutting out the specified regions.
*Intended for generating gene sequences given a list of GffLines.
*@param A Feature such as a GffLine.
*@param lines List of features.
*@param map Map of name to sequence (for the reference genome).
*@return A list of sequences of the input features, named by the features.
static ArrayList<Read> grabGenes(ArrayList<? extends K> lines, HashMap<String,Read> map)

*Call genes from a reference file and return the gene sequences.
*@param fna Fasta reference.
*@return Gene sequences.
private ArrayList<Read> callGenes(String fna)

*Makes a read input stream for a file (assumed to be fasta).
*@param fname File path.
*@return The read input stream.
private ConcurrentReadInputStream makeFastaCris(String fname)

*Call genes from a read stream and return the gene sequences.
*@param cris Read stream.
*@param gCaller The gene caller.
*@return Gene sequences.
static ArrayList<Read> callGenes(ConcurrentReadInputStream cris, GeneCaller gCaller)

</class CheckStrand>
<class CheckStrand2>
*Checks the strandedness of RNA-seq reads.
*@author Brian Bushnell
*@date August 7, 2023
public class CheckStrand2

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

String fna=null

String gff=null

String pgmFile=null

private String types="CDS,rRNA,tRNA,ncRNA,exon,5S,16S,23S"

private ArrayList<GffLine> gffLines=null

private ConcurrentHashMap<String,Seq> binMap

*Map associating with contig names with ordered arrays of nonoverlapping ranges
*Each range has attached a list of features that fully contain it.
private HashMap<String,Range[]> rangeMap

*Primary output file path
private String out1="stdout.txt"

*Output file path for plus-aligned reads
private String outPlus=null

*Output file path for minus-aligned reads
private String outMinus=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private String scaffoldReport=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private int binlen=0

*Number of reads processed
protected long readsIn=0

*Number of bases processed
protected long basesIn=0

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

protected long readsMerged=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private float samplerate=1

private long sampleseed=17

private int sketchSize=80000

private float minEntropy=0

private float minProb=0

private byte minQual=0

private boolean mergePairs=false

private final boolean doDepthAnalysis=true

private boolean doStopAnalysis=true

private boolean testPolyA=true

private ArrayList<Read> genes

private SketchTool canonTool

private SketchTool fwdTool

private SketchHeap canonHeap=null

private SketchHeap fwdHeap=null

private Sketch canonSketch=null

private Sketch fwdSketch=null

private Sketch canonGeneSketch=null

private Sketch plusSketch=null

private Sketch minusSketch=null

private long fCountSum=0

private long rCountSum=0

private long fPosSum=0

private long rPosSum=0

private boolean useFirstORF=false

private final long[] fBestFrame=new long[3]

private final long[] rBestFrame=new long[3]

private final long[] ACGTCount=new long[4]

private long polyACount=0

private long polyTCount=0

private int minPolyA=6

private long gCallerPlusCount=0

private long gCallerMinusCount=0

private long gCallerPlusCalled=0

private long gCallerMinusCalled=0

private double gCallerPlusScore=0

private double gCallerMinusScore=0

private long plusAlignedReads=0

private long minusAlignedReads=0

private long allAlignedReads=0

private long samLinesProcessed=0

private long samLinesAlignedToFeatures=0

private boolean scoreReadGenes=true

private final GeneModel pgm

private final GeneCaller gCaller

private int passes=2

private boolean streamGenome=false

private ArrayList<Read> genomeSequenceCache=null

ConcurrentHashMap<String,LongPair> geneMap=new ConcurrentHashMap<String,LongPair>()

*Whether the input reference is a transcriptome or genome
private boolean transcriptome=false

*True for unknown sense contigs from RNA-seq data
private boolean rnaContigs=false

private boolean normalize=false

private int minReads=2

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CheckStrand2(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

*Do math on the raw results to determine strandedness and major strand
void analyze()

*Start a read input stream from the read files
*@return The stream.
private ConcurrentReadInputStream makeCris()

*Start a read output stream for some destination
*@param fname Destination file for stream
*@return The stream.
private ConcurrentReadOutputStream makeCros(String fname)

*Set Sketch static parameters and generate SketchTools
*for forward and canonical kmers.
private void makeTools()

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream crosP, ConcurrentReadOutputStream crosM)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

*Generate sketches of the reference transcriptome.
*@return True if successful.
private boolean makeGeneSketches()

*Load the reference transcriptome; requires a reference fasta file.
*In transcriptome mode, the fasta file is simply loaded and returned.
*In genome mode, uses a gff if provided, otherwise the genes are called
*using CallGenes. Then the genes are cut from the reference like CutGff.
*Does not currently fuse exons together, and is untested on Euk annotations,
*but they are expected to work fine (as long as a gff is provided).
*@return Gene sequences, sense strand as plus.
private ArrayList<Read> grabGenes()

*Calls genes while streaming the fasta to save memory.
*Works fine but for some reason is extremely slow.
*@param fna Genome fasta.
*@return Gene sequences.
@Deprecated private ArrayList<Read> callGenes(String fna)

*Creates a read input stream for the fasta reference.
*@param fname Fasta path.
*@return The stream.
private ConcurrentReadInputStream makeFastaCris(String fname)

*Print the final program results.
*@param results Results from read kmer depth analysis
*@param refResults Results based on transcriptome kmer comparison
private void outputResults(double[] results, double[] resultsN, double[] refResults)

double[] binStrandedness()

void binStrandednessPerSequence(String fname)

*Manages a cached copy of the ref fasta to prevent reading it multiple times.
*@return The reference, as Read objects.
private ArrayList<Read> genomeSequence()

void incrementGeneMap(String gene, ConcurrentHashMap<String,LongPair> map, int senseStrand, int amt)

void incrementBinMap(String gene, ConcurrentHashMap<String,Seq> map, int pos, int strand, int amt)

void increment(ArrayList<LongPair> list, int idx, int strand, int amt)

@Override public final ReadWriteLock rwlock()

</class CheckStrand2>
<class CheckStrand2.ProcessThread>
*Handles all operations on input reads,
*such as merging, sketching, and stop-codon finding.
class CheckStrand2.ProcessThread

#Fields
*Number of reads in to this thread
protected long readsInT=0

*Number of bases in to this thread
protected long basesInT=0

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads merged by this thread
protected long readsMergedT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

private final ConcurrentReadOutputStream crosP

private final ConcurrentReadOutputStream crosM

private ArrayList<Read> pReads

private ArrayList<Read> mReads

final SketchMakerMini canonSmm

final SketchMakerMini fwdSmm

*Counts of stop codons on forward strand
private final int[] fCount=new int[3]

*Counts of stop codons on reverse strand
private final int[] rCount=new int[3]

*Longest initial ORF on forward strand
private final int[] fPos=new int[3]

*Longest initial ORF on reverse strand
private final int[] rPos=new int[3]

*Longest ORF on forward strand
private final int[] fMaxOrf=new int[3]

*Longest ORF on reverse strand
private final int[] rMaxOrf=new int[3]

*Last stop seen on forward strand
private final int[] fLastStop=new int[3]

*Last stop seen on reverse strand
private final int[] rLastStop=new int[3]

private long fCountSumT

private long rCountSumT

private long fPosSumT

private long rPosSumT

private final long[] fBestFrameT=new long[3]

private final long[] rBestFrameT=new long[3]

private final long[] ACGTCountT=new long[4]

private long polyACountT=0

private long polyTCountT=0

private long gCallerPlusCountT=0

private long gCallerMinusCountT=0

private long gCallerPlusCalledT=0

private long gCallerMinusCalledT=0

private double gCallerPlusScoreT=0

private double gCallerMinusScoreT=0

private long plusAlignedReadsT=0

private long minusAlignedReadsT=0

private long allAlignedReadsT=0

private long samLinesProcessedT=0

private long samLinesAlignedToFeaturesT=0

private GeneCaller gCallerT

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream crosP_, ConcurrentReadOutputStream crosM_, int tid_)

@Override public void run()

*Fetch lists of reads from the input stream.
void processInner()

*Iterate through the reads
void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
void processReadPair(Read r1, Read r2)

*Counts stop codons in each frame, and the longest ORF per frame.
void countStopCodons(Read r)

*Counts tip poly-As and poly-Ts.
*TODO: Should take into account pairnum so read 2 can be used.
void analyzePolyA(Read r)

*Calls genes on both strands, and records which strand
*had the highest-scoring gene.
void scoreGenes2(Read r)

@Deprecated void scoreGenes(Read r)

*Associate an aligned read with the plus or minus strand.
*@param r1 The read.
*@param sl The read's SamLine.
void processSamLine(Read r1, SamLine sl)

</class CheckStrand2.ProcessThread>
<class CheckStrand2.Seq>
static class CheckStrand2.Seq

#Fields
String name

int len

ArrayList<LongPair> bins=new ArrayList<LongPair>(1)


#Methods
public Seq(String name_, int len_)

public static ConcurrentHashMap<String,Seq> loadSamHeader(FileFormat ff)

</class CheckStrand2.Seq>
<class Consect>
*Generates a consensus from multiple error correction results.
*@author Brian Bushnell
*@date October 25, 2016
public class Consect

#Fields
*Input file paths
private ArrayList<String> in=new ArrayList<String>()

*Output file path
private String out=null

private String qfout=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private boolean changeQuality=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private long readsFullyCorrected=0

private long readsPartlyCorrected=0

private long readsNotCorrected=0

private long readsErrorFree=0

private long readsWithDisagreements=0

private long readsWithCorrections=0

private long disagreements=0

private long corrections=0

*Primary input file
private final FileFormat[] ffin

*Primary output file
private final FileFormat ffout

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public Consect(String[] args)

*Create read streams and process all data
void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream[] crisa, ConcurrentReadOutputStream ros)

private ArrayList<Read> consensus(ArrayList<Read>[] array)

*The first read becomes the consensus of the other reads, where they all agree.
private int consensus(Read[] reads)

</class Consect>
<class CountDuplicates>
*Counts duplicate sequences probabilistically,
*using around 20 bytes per unique read. Read pairs are treated
*as a single read. Reads are converted to a hashcode and only
*the hashcode is stored when tracking duplicates, so (rare) hash
*collisions will result in false positive duplicate detection.
*Optionally outputs the deduplicated and/or duplicate reads.
*@author Brian Bushnell
*@date November 19, 2022
public class CountDuplicates

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Primary dupe output file path
private String outd1=null

*Secondary dupe output file path
private String outd2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Stats output
private String stats="stdout.txt"

private double maxFraction=-1

private double maxRate=-1

private int failCode=0

boolean failed=false

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private KmerTableSet tables

private boolean hashBases=true

private boolean hashNames=false

private boolean hashQualities=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private double samplerate=1

private int maxCount=1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary dupe output file
private final FileFormat ffoutd1

*Secondary dupe output file
private final FileFormat ffoutd2

private static final long[][] hashcodes=Dedupe.makeCodes2(32)

private static final long salt=new Random(173).nextLong()

private final int sampleMask=1023

private final int sampleThresh

private final int UNSAMPLED=-1

private final int DUPLICATE=-2

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public CountDuplicates(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

private ConcurrentReadOutputStream makeCrosD(boolean pairedInput)

private void calcStatistics(String fname)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosd)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

public static long hash(byte[] bytes, int pairnum)

@Override public final ReadWriteLock rwlock()

</class CountDuplicates>
<class CountDuplicates.ProcessThread>
class CountDuplicates.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Shared output stream for duplicate reads
private final ConcurrentReadOutputStream rosd

*Thread ID
final int tid

final LongList codes=new LongList(Shared.bufferLen())


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, ConcurrentReadOutputStream rosd_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

private int processCodes()

private void hashList(ArrayList<Read> reads)

long hashRead(Read r1, Read r2)

private long hashBases(Read r1, Read r2)

private long hashNames(Read r1, Read r2)

private long hashQualities(Read r1, Read r2)

</class CountDuplicates.ProcessThread>
<class CountDuplicatesBuffered>
*Counts duplicate sequences probabilistically,
*using around 20 bytes per unique read. Read pairs are treated
*as a single read. Reads are converted to a hashcode and only
*the hashcode is stored when tracking duplicates, so (rare) hash
*collisions will result in false positive duplicate detection.
*Optionally outputs the deduplicated and/or duplicate reads.
*This version buffers hashtable writes to increase concurrency;
*not sure if it's been tested or is faster.
*@author Brian Bushnell
*@date November 19, 2022
public class CountDuplicatesBuffered

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Primary dupe output file path
private String outd1=null

*Secondary dupe output file path
private String outd2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Stats output
private String stats="stdout.txt"

private double maxFraction=-1

private double maxRate=-1

private int failCode=0

boolean failed=false

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private KmerTableSet tables

private boolean hashBases=true

private boolean hashNames=false

private boolean hashQualities=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private double samplerate=1

private int maxCount=1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary dupe output file
private final FileFormat ffoutd1

*Secondary dupe output file
private final FileFormat ffoutd2

private static final long[][] hashcodes=Dedupe.makeCodes2(32)

private static final long salt=new Random(173).nextLong()

private final int sampleMask=1023

private final int sampleThresh

private final int UNSAMPLED=-1

private final int DUPLICATE=-2

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public CountDuplicatesBuffered(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

private ConcurrentReadOutputStream makeCrosD(boolean pairedInput)

private void calcStatistics(String fname)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosd)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

public static long hash(byte[] bytes, int pairnum)

@Override public final ReadWriteLock rwlock()

</class CountDuplicatesBuffered>
<class CountDuplicatesBuffered.ProcessThread>
class CountDuplicatesBuffered.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Shared output stream for duplicate reads
private final ConcurrentReadOutputStream rosd

*Thread ID
final int tid

final HashBuffer table


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, ConcurrentReadOutputStream rosd_, int tid_)

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

long hashBases(Read r1, Read r2)

long hashNames(Read r1, Read r2)

long hashQualities(Read r1, Read r2)

</class CountDuplicatesBuffered.ProcessThread>
<class CountGC>
*@author Brian Bushnell
*@date Dec 13, 2012
public class CountGC

#Fields
private static final byte[] charToNum=makeCharToNum()

public static int FORMAT=1

public static boolean SUMMARY_ONLY=false

private static long LIMSUM=0

static final byte slashr='\r'

static final byte slashn='\n'

static final byte carrot='>'

static final byte at='@'

static PrintStream outstream=System.err


#Methods
public static void main(String[] args)

public static long bench2(InputStream is)

public static long[] countFasta(InputStream is, String out)

public static long[] countFastq(InputStream is, String out)

private static String toString2(StringBuilder sb, int[] counts)

private static String toString2(StringBuilder sb, long[] counts)

*@return
private static byte[] makeCharToNum()

</class CountGC>
<class CountUniqueness>
*TODO
*@author Brian Bushnell
*@date Jan 14, 2014
public class CountUniqueness

#Fields
private static final int MAX=41

private static final int MAX2=MAX + 1

private long[][][] goodMatrix=new long[MAX2][MAX2][MAX2]

private long[][][] badMatrix=new long[MAX2][MAX2][MAX2]

private PrintStream outstream=System.err

private boolean verbose=false

private long maxReads=-1

private String in

private String out

private boolean overwrite=true

private boolean append=false

private long readsProcessed=0

private long basesProcessed=0

private boolean errorState=false


#Methods
public void process()

private void process(Read r1, Read r2)

public void process(String fname)

</class CountUniqueness>
<class CoveragePileup>
*@author Brian Bushnell
*@date Jan 4, 2013
public class CoveragePileup

#Fields
*The list of all scaffolds
private ArrayList<Scaffold> list

*Maps names to scaffolds
private HashMap<String,Scaffold> table

*Converts BBMap index coordinates to scaffold coordinates
private final ScaffoldCoordinates coords=new ScaffoldCoordinates()

*Converts BBMap index coordinates to scaffold coordinates
private final ScaffoldCoordinates coords2=new ScaffoldCoordinates()

*Mapping program name
private String program=null

*Mapping program version
private String version=null

*Primary input file (typically sam)
public String in1=null

*Secondary input file (typically for coverage directly from BBMap)
public String in2=null

public ArrayList<String> covIn=new ArrayList<String>()

*Optional, for calculating GC
public String reference=null

public String orffasta=null

*Stream unaltered sam input to this output
public String outsam=null

*Coverage statistics, one line per scaffold
public String covstats=null

public String outorf=null

*Coverage histogram, one line per depth and one point per base
public String histogram=null

*Coverage with one line per base
public String basecov=null

*Coverage with one file per scaffold
public String basecov_ps=null

*Coverage with one line per bin
public String bincov=null

*Coverage with one line per bin, normalized by length and/or height
public String normcov=null

*Coverage with one line per bin, normalized by length and/or height, for combined reference
public String normcovOverall=null

*rpkm/fpkm output, similar to Seal
public String outrpkm=null

public String rangecov=null

*Typically indicates that a header line was encountered in an unexpected place, e.g. with concatenated sam files.
private boolean error=false

private boolean warned=false

private final boolean EA=Shared.EA()

*Total length of reference
public long refBases=0

public long mappedBases=0

public long mappedNonClippedBases=0

public long mappedBasesWithDels=0

public long mappedReads=0

public long properPairs=0

public long readsProcessed=0

public long basesProcessed=0

public long kmersProcessed=0

public long mappedKmers=0

public double correctKmers=0

public long totalCoveredBases1=0

public long totalCoveredBases2=0

public long scaffoldsWithCoverage1=0

public long scaffoldsWithCoverage2=0

public long totalScaffolds=0

public int k=0

public long maxReads=-1

public int initialScaffolds=4096

public int binsize=1000

public boolean bits32=false

public int minMapq=0

public boolean useStreamer=true

public int streamerThreads=2

public int minDepthToBeCovered=1

private boolean qtrimLeft=false

private boolean qtrimRight=false

private float trimq=-1

private final float trimE

private int border=0

*Don't print coverage info for scaffolds shorter than this
public int minscaf=0

public HashMap<String,SamLine> pairTable=new HashMap<String,SamLine>()

public PrintStream outstream=System.err

private boolean errorState=false

private final LineParser1 lp=new LineParser1('\t')

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Print verbose log messages
public static boolean verbose=false

*Print the arguments to main
public static boolean printCommand=true

*Print headers in output files
public static boolean printHeader=true

*Prepend '#' symbol to header lines
public static boolean headerPound=true

*Calculate standard deviation of coverage
public static boolean calcCovStdev=true

*Window size to use when calculating average coverage,
*for detecting contiguous low-coverage areas
public static int LOW_COV_WINDOW=500

*Min average coverage to not be classified as low-depth
public static double LOW_COV_DEPTH=5

*Print number of bases below a certain average coverage in a window
public static boolean USE_WINDOW=false

*Track base composition of reads covering each scaffold
public static boolean COUNT_GC=true

*Output in 2-column format ("#ID\tAvg_fold\n")
public static boolean TWOCOLUMN=false

*Track coverage for strands independently
public static boolean STRANDED=false

*Add scaffold information from the reference (in addition to sam header)
public static boolean ADD_FROM_REF=true

*Add scaffold information from reads mapped to unknown scaffolds (in addition to sam header)
public static boolean ADD_FROM_READS=false

*Only print scaffolds with nonzero coverage
public static boolean NONZERO_ONLY=false

*Store coverage info in numeric arrays
public static boolean USE_COVERAGE_ARRAYS=true

*Store coverage info in bitsets
public static boolean USE_BITSETS=false

*Only print lines when coverage changes (for compatibility with Jigsaw)
public static boolean DELTA_ONLY=false

*Process secondary alignments
public static boolean USE_SECONDARY=true

*Include coverage of unsequenced middle portion of pairs
public static boolean PHYSICAL_COVERAGE=false

*Use 'tlen' field when calculating physical coverage
public static boolean USE_TLEN=true

*Abort on error; otherwise, errors may be ignored
public static boolean ABORT_ON_ERROR=true

*Print coverage for the last bin of a scaffold, even if it is shorter than binsize
public static boolean KEEP_SHORT_BINS=true

*Only track coverage for start location
public static boolean START_ONLY=false

*Only track coverage for stop location
public static boolean STOP_ONLY=false

*This appears to be the same as nonzeroonly...
public static boolean CONCISE=false

*Normalize coverage by expression contig coverage as a fraction of its max coverage
public static boolean NORMALIZE_COVERAGE=false

*Normalize contig length by binning into this many bins per contig
public static int NORMALIZE_LENGTH_BINS=100

*Include soft-clipped bases in coverage
public static boolean INCLUDE_SOFT_CLIP=false

*Include deletions/introns in coverage
public static boolean INCLUDE_DELETIONS=true

*Include reads flagged as duplicates in coverage
public static boolean INCLUDE_DUPLICATES=true

public static boolean KEY_VALUE

*Translation array for tracking base counts
private static final byte[] charToNum=AssemblyStats2.makeCharToNum()

private static final int NOTHING_MODE=0

private static final int BITSET_MODE=1

private static final int ARRAY_MODE=2


#Methods
public CoveragePileup(String[] args)

*The goal if this is to garbage-collect unnecessary objects, not really for reusing the object
public void clear()

public void createDataStructures()

*Read and process all input data.
public void process()

private void processViaStreamer(ByteStreamWriter tsw)

private void processViaByteFile(ByteFile tf, ByteStreamWriter tsw)

private void loadCoverageFile(String fname)

*Process all sam header lines from the tf.
*Once a non-header line is encountered, return it.
*If non-null, print all lines to the tsw.
public void processHeader(ByteFile tf, ByteStreamWriter tsw)

public void loadScaffoldsFromIndex(int minChrom, int maxChrom)

public void processReference()

public void processOrfsFasta(String fname_in, String fname_out, HashMap<String,Scaffold> map)

public boolean addCoverage(String scafName, byte[] seq, byte[] match, int start0, int stop0, int readlen, int nonClippedBases, int strand, int incrementFrags, boolean properPair, SamLine sl)

public boolean addCoverage(Scaffold scaf, byte[] seq, byte match, int start0, int stop0, int readlen, int nonClippedBases, int strand, int incrementFrags, boolean properPair, SamLine sl)

private boolean addCoverageIgnoringDeletions(Scaffold scaf, byte[] seq, byte match, int start, int stop, int readlen, int strand, int incrementFrags)

public boolean processSamLine(byte[] line)

private int trim(SamLine sl)

public boolean processSamLine(SamLine sl)

public boolean processRead(Read r)

public boolean processRead(Read r, SiteScore ss)

public void printOutput()

public int basesUnderAverageCoverage(int[] array, double avg, int window)

public int basesUnderAverageCoverage(char[] array, double avg, int window)

public long[] writeStats(String fname, int strand)

*Write a histogram of number of bases covered to each depth
*@param fname Output filename
*@param counts counts[X] stores the number of bases with coverage X
public static void writeHist(String fname, long[] counts)

*Prints coverage in this format:
*scafname TAB position TAB coverage
*scafname TAB position TAB coverage
*@param fname Output filename
*@param list List of reference scaffolds
*@param deltaOnly Only write lines when coverage changes
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public void writeCoveragePerBase(String fname, ArrayList<Scaffold> list, boolean deltaOnly, int strand, int minscaf)

*Prints coverage in this format, skipping zero-coverage positions:
*#scafname
*position TAB coverage
*position TAB coverage
*@param fname Output filename
*@param list List of reference scaffolds
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public void writeCoveragePerBaseConcise(String fname, ArrayList<Scaffold> list, int strand, int minscaf)

*Prints coverage in this format, skipping zero-coverage positions:
*#scafname
*position TAB coverage
*position TAB coverage
*@param fname Output filename
*@param list List of reference scaffolds
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public void writeCoverageRanges(String fname, ArrayList<Scaffold> list, int strand, int minscaf)

*Note. As written, this will truncate all trailing bases of each scaffold's length modulo binsize.
*For example, with binsize 1000, the last 500 bases of a 1500 base scaffold will be ignored.
*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseBinned(String fname, ArrayList<Scaffold> list, int binsize, int strand, int minscaf)

*This version will NOT truncate all trailing bases of each scaffold's length modulo binsize.
*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseBinned2(String fname, ArrayList<Scaffold> list, int binsize, int strand, int minscaf)

public static double[] standardDeviationBinnedUnsafe(String fname, ArrayList<Scaffold> scaffolds, int binsize, int strand, int minscaf)

public static double[] standardDeviationBinned(ArrayList<Scaffold> scaffolds, int binsize, int strand, int minscaf)

public static double[] standardDeviation(ArrayList<Scaffold> scaffolds, int strand, int minscaf)

*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseNormalized(String fname, ArrayList<Scaffold> list, double binsize, int strand, int minscaf)

*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseNormalizedOverall(String fname, ArrayList<Scaffold> list, double binsize, int strand, int minscaf)

*Write RPKM statistics.
public static void writeRPKM(String out, String in1, String in2, long readsIn, boolean printNonZeroOnly, ArrayList<Scaffold> list)

</class CoveragePileup>
<class CoveragePileupMT>
*@author Brian Bushnell
*@date April 17, 2024
public class CoveragePileupMT

#Fields
private final ArrayBlockingQueue<String> queue=new ArrayBlockingQueue(8)

private final String POISON="POISON_NOT_A_FILE"

private boolean atomic=false

private boolean prealloc=false

private Class<? extends CoverageArray> caType

*The list of all scaffolds
private ArrayList<Scaffold> list

*Maps names to scaffolds
private HashMap<String,Scaffold> table

*Mapping program name
private String program=null

*Mapping program version
private String version=null

*Primary input files (typically sam)
public ArrayList<String> inputFiles=new ArrayList<String>()

public int streams=-1

*Optional, for calculating GC
public String reference=null

public String orffasta=null

*Coverage statistics, one line per scaffold
public String covstats=null

public String outorf=null

*Coverage histogram, one line per depth and one point per base
public String histogram=null

*Coverage with one line per base
public String basecov=null

*Coverage with one file per scaffold
public String basecov_ps=null

*Coverage with one line per bin
public String bincov=null

*Coverage with one line per bin, normalized by length and/or height
public String normcov=null

*Coverage with one line per bin, normalized by length and/or height, for combined reference
public String normcovOverall=null

*rpkm/fpkm output, similar to Seal
public String outrpkm=null

*Typically indicates that a header line was encountered in an unexpected place, e.g. with concatenated sam files.
private boolean error=false

private boolean warned=false

private final boolean EA=Shared.EA()

*Total length of reference
public long refBases=0

public long refKmers=0

public long mappedBases=0

public long mappedNonClippedBases=0

public long mappedBasesWithDels=0

public long mappedReads=0

public long properPairs=0

public long readsProcessed=0

public long basesProcessed=0

public long kmersProcessed=0

public long mappedKmers=0

public double correctKmers=0

public long totalCoveredBases1=0

public long totalCoveredBases2=0

public long scaffoldsWithCoverage1=0

public long scaffoldsWithCoverage2=0

public long totalScaffolds=0

public int k=0

public long maxReads=-1

public int initialScaffolds=4096

public int binsize=1000

public boolean bits32=false

public int minMapq=0

public int streamerThreads=2

public int minDepthToBeCovered=1

private boolean qtrimLeft=false

private boolean qtrimRight=false

private float trimq=-1

private final float trimE

private int border=0

*Don't print coverage info for scaffolds shorter than this
public int minscaf=0

public HashMap<String,SamLine> pairTable=new HashMap<String,SamLine>()

public PrintStream outstream=System.err

private boolean errorState=false

private final LineParser1 lp=new LineParser1('\t')

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Print verbose log messages
public static boolean verbose=false

*Print timing messages
public static boolean verboseTime=false

*Print the arguments to main
public static boolean printCommand=true

*Print headers in output files
public static boolean printHeader=true

*Prepend '#' symbol to header lines
public static boolean headerPound=true

*Calculate standard deviation of coverage
public static boolean calcCovStdev=true

*Window size to use when calculating average coverage,
*for detecting contiguous low-coverage areas
public static int LOW_COV_WINDOW=500

*Min average coverage to not be classified as low-depth
public static double LOW_COV_DEPTH=5

*Print number of bases below a certain average coverage in a window
public static boolean USE_WINDOW=false

public static int HISTMAX=-1

*Track base composition of reads covering each scaffold
public static boolean COUNT_GC=true

*Output in 2-column format ("#ID\tAvg_fold\n")
public static boolean TWOCOLUMN=false

*Track coverage for strands independently
public static boolean STRANDED=false

*Add scaffold information from the reference (in addition to sam header)
public static boolean ADD_FROM_REF=true

*Only print scaffolds with nonzero coverage
public static boolean NONZERO_ONLY=false

*Store coverage info in numeric arrays
public static boolean USE_COVERAGE_ARRAYS=true

*Store coverage info in bitsets
public static boolean USE_BITSETS=false

*Only print lines when coverage changes (for compatibility with Jigsaw)
public static boolean DELTA_ONLY=false

*Process secondary alignments
public static boolean USE_SECONDARY=true

*Include coverage of unsequenced middle portion of pairs
public static boolean PHYSICAL_COVERAGE=false

*Use 'tlen' field when calculating physical coverage
public static boolean USE_TLEN=true

*Abort on error; otherwise, errors may be ignored
public static boolean ABORT_ON_ERROR=true

*Print coverage for the last bin of a scaffold, even if it is shorter than binsize
public static boolean KEEP_SHORT_BINS=true

*Only track coverage for start location
public static boolean START_ONLY=false

*Only track coverage for stop location
public static boolean STOP_ONLY=false

*This appears to be the same as nonzeroonly...
public static boolean CONCISE=false

*Normalize coverage by expression contig coverage as a fraction of its max coverage
public static boolean NORMALIZE_COVERAGE=false

*Normalize contig length by binning into this many bins per contig
public static int NORMALIZE_LENGTH_BINS=100

*Include soft-clipped bases in coverage
public static boolean INCLUDE_SOFT_CLIP=false

*Include deletions/introns in coverage
public static boolean INCLUDE_DELETIONS=true

*Include reads flagged as duplicates in coverage
public static boolean INCLUDE_DUPLICATES=true

public static boolean KEY_VALUE

*Translation array for tracking base counts
private static final byte[] charToNum=AssemblyStats2.makeCharToNum()

private static final int NOTHING_MODE=0

private static final int BITSET_MODE=1

private static final int ARRAY_MODE=2


#Methods
public static void main(String[] args)

public CoveragePileupMT(String[] args)

*The goal of this is to garbage-collect unnecessary objects, not really for reusing the object
public void clear()

public void createDataStructures()

final CoverageArray makeCA(int len)

*Read and process all input data.
public void process()

*Spawn process threads
private void spawnThreads()

*Process all sam header lines from the tf.
*Once a non-header line is encountered, return it.
*If non-null, print all lines to the tsw.
public void processHeader(ByteFile tf)

void processHeaderLine(byte[] line)

public void processReference()

public void processOrfsFasta(String fname_in, String fname_out, HashMap<String,Scaffold> map)

private int trim(SamLine sl)

public void printOutput(LongList hist0, LongList hist1)

public void writeStats(String fname, int strand)

*Write a histogram of number of bases covered to each depth
*@param fname Output filename
*@param counts counts[X] stores the number of bases with coverage X
public static void writeHist(String fname, long[] counts)

*Prints coverage in this format:
*scafname TAB position TAB coverage
*scafname TAB position TAB coverage
*@param fname Output filename
*@param list List of reference scaffolds
*@param deltaOnly Only write lines when coverage changes
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public void writeCoveragePerBase(String fname, ArrayList<Scaffold> list, boolean deltaOnly, int strand, int minscaf)

*Prints coverage in this format, skipping zero-coverage positions:
*#scafname
*position TAB coverage
*position TAB coverage
*@param fname Output filename
*@param list List of reference scaffolds
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public void writeCoveragePerBaseConcise(String fname, ArrayList<Scaffold> list, int strand, int minscaf)

*Note. As written, this will truncate all trailing bases of each scaffold's length modulo binsize.
*For example, with binsize 1000, the last 500 bases of a 1500 base scaffold will be ignored.
*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseBinned(String fname, ArrayList<Scaffold> list, int binsize, int strand, int minscaf)

*This version will NOT truncate all trailing bases of each scaffold's length modulo binsize.
*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseBinned2(String fname, ArrayList<Scaffold> list, int binsize, int strand, int minscaf)

*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseNormalized(String fname, ArrayList<Scaffold> list, double binsize, int strand, int minscaf)

*@param fname Output filename
*@param list List of reference scaffolds
*@param binsize Width of coverage bins in bp
*@param strand Only use coverage from reads mapped to this strand (0=plus, 1=minus)
public static void writeCoveragePerBaseNormalizedOverall(String fname, ArrayList<Scaffold> list, double binsize, int strand, int minscaf)

*Write RPKM statistics.
public static void writeRPKM(String out, ArrayList<String> in1, long readsIn, boolean printNonZeroOnly, ArrayList<Scaffold> list)

private String getNext()

private void addToQueue(String s)

@Override public void accumulate(LoadThread t)

@Override public boolean success()

@Override public final ReadWriteLock rwlock()

</class CoveragePileupMT>
<class CoveragePileupMT.LoadThread>
class CoveragePileupMT.LoadThread

#Fields
final int tid

public long mappedBases=0

public long mappedNonClippedBases=0

public long mappedBasesWithDels=0

public long mappedReads=0

public long properPairs=0

public long readsProcessed=0

public long basesProcessed=0

public long kmersProcessed=0

public long mappedKmers=0

public double correctKmers=0


#Methods
LoadThread(int tid_)

@Override public void run()

private void processViaStreamer(String fname)

private void processHeader(ArrayList<byte[]> lines)

public boolean processSamLine(SamLine sl)

public boolean addCoverage(String scafName, byte[] seq, byte[] match, int start0, int stop0, int readlen, int nonClippedBases, int strand, int incrementFrags, boolean properPair, SamLine sl)

public boolean addCoverage(Scaffold scaf, byte[] seq, byte match, int start0, int stop0, int readlen, int nonClippedBases, int strand, int incrementFrags, boolean properPair, SamLine sl)

private boolean addCoverageIgnoringDeletions(Scaffold scaf, byte[] seq, byte match, int start, int stop, int readlen, int strand, int incrementFrags)

int addCoverageIgnoringDeletions(int start, int stop, byte[] match, CoverageArray ca)

int addCoverageIgnoringDeletions(int start, int stop, byte[] match, BitSet bs)

</class CoveragePileupMT.LoadThread>
<class CovStatsLine>
*@author Brian Bushnell
*@date Oct 10, 2014
public class CovStatsLine

#Fields
public String id

public int length

public int coveredBases

public long plusReads

public long minusReads

public double avgFold

public double refGC

public long median

public int underMin

public double readGC

public double stdDev

private static int id_FNUM=-1

private static int length_FNUM=-1

private static int coveredBases_FNUM=-1

private static int plusReads_FNUM=-1

private static int minusReads_FNUM=-1

private static int avgFold_FNUM=-1

private static int refGC_FNUM=-1

private static int median_FNUM=-1

private static int underMin_FNUM=-1

private static int readGC_FNUM=-1

private static int stdDev_FNUM=-1


#Methods
public CovStatsLine(String s)

*ID Avg_fold Length Ref_GC Covered_percent Covered_bases Plus_reads Minus_reads (optional.... Read_GC)
*@param split
public CovStatsLine(String[] split)

public final double coveredPercent()

public final long reads()

*@param csl
public void add(CovStatsLine csl)

@Override public String toString()

public static void initializeHeader(String header)

</class CovStatsLine>
<class CrisprFinder>
*Designed to find Crispr repeats within reads.
*Helpful Tadpole command:
*java -ea -Xmx8g assemble.Tadpole mode=extend k=93 in=merged.fq.gz
*int=f out=extended.fq.gz el=50 er=50 ow ibb=f mce=5 bm2=5 bm1=30
*java -Xmx8g clump.Clumpify in=merged.fq.gz out=clumped.fq.gz ecc passes=12 int=f ow conservative
*java -Xmx8g assemble.Tadpole in=clumped.fq.gz out=eccClumped.fq.gz ecc conservative k=72 int=f
*@author Brian Bushnell
*@date August 29, 2023
public class CrisprFinder

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Primary reject output file path
private String outu1=null

*Secondary reject output file path
private String outu2=null

private String ref=null

private String outCrispr=null

private String outCrisprHist=null

private String outPalindromeHist=null

private String outRepeat=null

private String outSpacer=null

private String outRef=null

private String outRefAndRepeats=null

private boolean forceMaps=true

private int minCountToPrint=0

private boolean printPals=true

private boolean printScore=true

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private int kRepeat=13

private int rqhdist=0

private int maskMiddle=0

private final long midmaskRepeat

private int minSpacer=14

private int maxSpacer=60

private int minRepeat0=11

private int minRepeat=22

private int maxRepeat=56

private int minTailRepeat=9

private final int minPeriod

private final int minCrispr

private final int minTailPeriod

private final int minTailCrispr

private float minRGC=0.09f

private float maxRGC=0.89f

private int maxRepeatMismatches=3

private int maxRepeatMismatchesTail=1

private int mrmmPad=3

private int crisprOutPad=0

private int minOverlapConsensus=18

private int maxTrimConsensus=5

private float minEntropy=0.84f

private int entropyWindow=80

private int entropyK=4

private int maxPoly=7

private int maxNs=0

private int kRef=13

private int maskMiddleRef=1

private int minRefMatches=18

private int maxRefMismatches=5

private float maxRefMismatchFraction=0.2f

private int minRefCount=0

private int minRefOverlap=7

private int maxRefSkew=8

private int maxRefTrim=10

private float minRefOverlapFractionQ=.00f

private float minRefOverlapFractionR=.00f

private boolean sortRefCandidates=false

private boolean autoSortRefCandidates=true

private boolean incrementRef=false

private HashMap<SeqCountM,AtomicLong> refUseSet

private boolean revertAlignmentFailures=false

private boolean shrinkAlignmentFailures=false

private boolean discardAlignmentFailures=true

private boolean discardUnaligned=false

private boolean doubleAlign=true

private boolean doubleFetch=true

private int minRepeats=2

private boolean masked=false

private boolean consensus=true

private final boolean bruteForce

private boolean bruteForceLeft=true

private boolean bruteForceRight=true

private boolean bruteForceMiddle=false

private boolean refinement=false

private boolean grow=true

private int growLookahead=5

private int minPal=5

private int minPalMatches=4

private int maxPalMismatches=2

private int minLoop=3

private int maxLoop=26

private int minTail=0

private int maxTail=24

private int maxTailDif=21

private boolean forceSymmetry=false

private boolean requirePalindrome=false

private boolean annotate=false

private final CrisprTracker cTracker=new CrisprTracker()

private final PalindromeTracker pTracker=new PalindromeTracker()

private final PalindromeTracker pTrackerFull=new PalindromeTracker()

private boolean fullLengthPalStats=true

private boolean printStats=true

private boolean printHist=false

private boolean useQueues=false

private final ArrayBlockingQueue<SeqCountM> repeatQueue=new ArrayBlockingQueue<SeqCountM>(256)

private final ArrayBlockingQueue<SeqCountM> spacerQueue=new ArrayBlockingQueue<SeqCountM>(256)

private HashMap<SeqCount,SeqCountM> repeatMap

private HashMap<SeqCount,SeqCountM> spacerMap

private SeqMap refMap

private int maxRefCount=0

private long refMapSum=0

static final byte[] symbolToNumber=AminoAcid.baseToNumber

static final byte[] symbolToComplementNumber=AminoAcid.baseToComplementNumber

private final ThreadLocal<Alignment[]> localAlignments=new ThreadLocal<Alignment[]>(){
  @Override protected Alignment[] initialValue(){
    return new Alignment[]{new Alignment(),new Alignment(),new Alignment()};
  }
}

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

protected long repeatsFound

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private boolean merge=false

private long readsMerged=0

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary reject output file
private final FileFormat ffoutu1

*Secondary reject output file
private final FileFormat ffoutu2

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

private static final String defaultNetFile=Data.findPath("?crispr.bbnet.gz",false)

private static String netFile=defaultNetFile

private static CellNet net0

private static boolean setCutoff=false

private static float netCutoff=-1

private static boolean useNet=false

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*Print more verbose messages
public static final boolean verbose2=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CrisprFinder(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ByteBuilder crisprStats(long readsTotal, boolean stats, boolean hist)

private ByteBuilder palindromeStats(long crisprsTotal, boolean stats, boolean hist)

private ConcurrentReadInputStream makeCris()

private static ConcurrentReadOutputStream makeCros(FileFormat ff1, FileFormat ff2, boolean pairedInput, boolean ordered)

private ConcurrentReadOutputStream makeCrosCrispr()

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosu, ConcurrentReadOutputStream rosCrispr)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

public static final ArrayList<Crispr> findRanges(Read r, int k, int hdist, long midMask, int minSpacer, int maxSpacer, int minRepeat, int maxRepeat, int maxMismatches, boolean grow, int lookahead, float minRGC, float maxRGC, LongLongListHashMap kmerPositionMap, LongList allKmers, int[] acgtn)

private static int shrink(byte[] bases, Crispr rp)

private static int shrinkLeft(byte[] bases, Crispr rp)

private static int shrinkRight(byte[] bases, Crispr rp)

private static int grow(byte[] bases, Crispr rp, int maxMismatches, int lookahead)

private static int growLeft(byte[] bases, Crispr rp, int maxMismatches, int lookahead)

private static int growRight(byte[] bases, Crispr rp, int maxMismatches, int lookahead)

private static int checkLeft(byte[] bases, int a, int b, int limit)

private static int checkRight(byte[] bases, int a, int b, int limit)

public static final LongList fetchListWithHdist(long kmer, long midMask, int hdist, int pos, LongLongListHashMap map)

public static final int countMatches(byte[] s, int a1, int b1, int a2, int b2)

public static final int fillMap(Read r, int k, long midMask, LongLongListHashMap kmerPositionMap, LongList allKmers)

public static void findPalindromes(byte[] bases, ArrayList<Crispr> pairs, PalindromeFinder palFinder, boolean forceSymmetry, boolean requirePalindrome, int minRepeat)

private final int scoreRepeats(byte[] bases, ArrayList<Crispr> pairs, float[] vec, CellNet net)

private final float scoreRepeat(byte[] bases, Crispr rp, float[] vec, CellNet net)

private static int addToMap(SeqCountM s, HashMap<SeqCount,SeqCountM> map, boolean copy)

private static ArrayList<SeqCountM> toSortedList(HashMap<SeqCount,SeqCountM> map, CellNet net, long minCount)

private static ArrayList<SeqCountM> toSortedListSA(HashMap<SeqCountM,AtomicLong> map, CellNet net, long minCount)

private static void printList(ArrayList<X> list, String fname, PalindromeFinder palFinder, CellNet net, boolean overwrite, int minCount)

private static int cullLowCountRepeats(ArrayList<Crispr> list, int minRepeats)

@Override protected Alignment[] initialValue()

@Override public final ReadWriteLock rwlock()

public static void loadNet()

private static void loadNet(String fname)

</class CrisprFinder>
<class CrisprFinder.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class CrisprFinder.ProcessThread

#Fields
private LongLongListHashMap kmerPositionMap

private LongList allKmers

private int[] acgtn

private PalindromeFinder palFinder

private CrisprTracker cTrackerT

private SeqMap refMapT

private EntropyTracker eTracker

private CellNet net

private float[] vec

private HashMap<SeqCount,SeqCountM> repeatMapT

private HashMap<SeqCount,SeqCountM> spacerMapT

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads merged by this thread
protected long readsMergedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Shared reject output stream
private final ConcurrentReadOutputStream rosu

*Crispr output stream
private final ConcurrentReadOutputStream rosCrispr

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, ConcurrentReadOutputStream rosu_, ConcurrentReadOutputStream rosCrispr_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2, ArrayList<Read> crisprs)

boolean processRead(Read r, ArrayList<Read> crisprs)

int filterPairs(byte[] bases, ArrayList<Crispr> pairs)

int removeMistakes(ArrayList<Crispr> list, int length)

void trackCopies(ArrayList<Crispr> pairs)

private void put(X x, ArrayBlockingQueue<X> queue)

void addToMaps(ArrayList<Crispr> pairs, byte[] bases)

@Deprecated public void shrinkToMasked(byte[] bases, ArrayList<Crispr> list)

public void alignToRef(byte[] bases, ArrayList<Crispr> list)

public Alignment alignRefToRange(byte[] bases, Range r, Range alt, int mm)

public Alignment doubleAlignRefToRange(byte[] bases, Range left, Range right, int repeatMismatches)

public void consensus(byte[] bases, ArrayList<Crispr> list)

int removeShort(byte[] bases, ArrayList<Crispr> list)

public int consensus(Crispr left, Crispr right, byte[] bases)

*Looks for repeats that did not get found from kmer seeds.
int bruteForce(byte[] bases, ArrayList<Crispr> list)

*Looks for a repeat to the left of the leftmost detected repeat.
Crispr bruteForceLeft(byte[] bases, Crispr rp0)

*Looks for a repeat to the right of the rightmost detected repeat.
Crispr bruteForceRight(byte[] bases, Crispr rp0)

*Looks for repeats between repeats.
Crispr bruteForceMiddle(byte[] bases, Crispr left, Crispr right, ArrayList<Crispr> list)

int alignLeft(byte[] bases, int a2, int b2, int b1, int maxmm)

int alignRight(byte[] bases, int a1, int b1, int a2, int maxmm)

int countMismatches(Crispr p, byte[] bases)

int countMatches(Crispr p, byte[] bases)

public final int countMatchesLeft(Crispr p, byte[] bases)

public final int countMatchesRight(Crispr p, byte[] bases)

void clearMap()

</class CrisprFinder.ProcessThread>
<class CrisprFinder.Alignment>
class CrisprFinder.Alignment

#Fields
byte[] seq

int count

int pos

int matches

int mismatches

int a2

int b2

int score

int shift

boolean valid

boolean perfect


#Methods
public Alignment()

void set(byte[] s, int p, int a0, int b0, int m, int mm, int c)

Alignment setFrom(Alignment o)

void clear()

public int compareTo(Alignment b)

public String toString()

</class CrisprFinder.Alignment>
<class CutPrimers>
*Uses two sam files defining primer mapping locations to cut the primed sequence out of the reference.
*@author Brian Bushnell
*@date Nov 24, 2014
public class CutPrimers

#Fields
private String in1=null

private String sam1=null

private String sam2=null

private String out1=null

private boolean ADD_FAKE_READS=true

private boolean INCLUDE_PRIMERS=false

private final FileFormat ffin1

private final FileFormat ffout1

private long maxReads=-1

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public CutPrimers(String[] args)

void process(Timer t)

public static LinkedHashMap<String,SamLine> toSamLines(String fname)

</class CutPrimers>
<class DecontaminateByNormalization>
*@author Brian Bushnell
*@date October 9, 2014
public class DecontaminateByNormalization

#Fields
private final ArrayList<String> readNames=new ArrayList<String>()

private final ArrayList<String> refNames=new ArrayList<String>()

private String logName=null

private String resultsName="results.txt"

private String tempdir=(Shared.tmpdir() == null ? "" : Shared.tmpdir())

private String outdir=null

private int kfilter=55

private String ambigMode="random"

private long maxReads=-1

private float minc=3.5f

private float minp=20

private int minr=20

private int minl=500

*Delete temp files after use
private boolean deleteFiles=true

*Error correct with Tadpole
private boolean ecct=false

private boolean tadpoleAggressive=false

private boolean tadpoleConservative=false

private boolean tadpolePrealloc=true

private int tadpoleK=42

private int tadpolePrefilter=1

*Scaffolds will be discarded if there are at least this many bases in windows below a coverage cutoff.
private int basesUnderMin=-1

private float depthPercentile=0.75f

private float minprob=0.5f

private int minDepth=2

private int normK=31

private int normTarget=20

private int normHashes=4

private int normPasses=1

private int filterBits=32

private int prefilterBits=2

private boolean ecc=false

private boolean cecc=false

private boolean aecc=false

private boolean prefilter=true

private boolean normalizeByLowerDepth=false

private double minRatio=1.2f

private boolean mapRawReads=true

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true


#Methods
public DecontaminateByNormalization(String[] args)

void process(Timer t)

public static void parseStringsFromFiles(ArrayList<String> list)

private void renameAndMux_ST(ArrayList<String> readPaths, String fnameOut)

private void renameAndMux_MT(ArrayList<String> readPaths, String fnameOut)

private void eccTadpole(String fnameIn, String fnameOut)

private void normalize(String fnameIn, String fnameOut, int k, int min, int target, int hashes, int passes, boolean ecc, boolean prefilter, boolean uselowerdepth)

private void demux(String fnameIn, ArrayList<String> readPaths)

private void map(ArrayList<String> readPaths, ArrayList<String> refnames, int pass)

private void filter(ArrayList<String> readPaths, ArrayList<String> refnames)

*Log a message in the log file
*@param message Message to log
*@param append True to append, false to overwrite
private void log(String message, boolean append)

*TODO: Some machines are set to UTC rather than PST
*@return Timestamp in RQC's format
public static String timeString()

</class DecontaminateByNormalization>
<class Dedupe>
*@author Brian Bushnell
*@date Jul 18, 2013
public final class Dedupe

#Fields
private ConcurrentReadInputStream crisa

private final ByteStreamWriter dupeWriter

private String[] in1=null

private String[] in2=null

private String out=null

private String clusterFilePattern=null

private String outbest=null

private String outdupe=null

private String outcsf=null

private String outgraph=null

private int maxNs=-1

private long maxReads=-1

public boolean errorState=false

boolean sort=false

boolean absorbContainment=true

boolean absorbMatch=true

boolean findOverlaps=false

boolean makeClusters=false

boolean processClusters=false

boolean renameClusters=false

boolean absorbOverlap=false

boolean storeSuffix=false

boolean storeName=true

boolean storeQuality=true

boolean exact=true

boolean uniqueNames=true

boolean mergeHeaders=false

String mergeDelimiter=">"

boolean maxSpanningTree=false

boolean canonicizeClusters=true

boolean removeCycles=true

boolean fixMultiJoins=true

boolean fixCanonContradictions=false

boolean fixOffsetContradictions=false

boolean countTransitive=false

boolean countRedundant=false

private boolean multipleInputFiles=false

private boolean rigorousTransitive=false

private int numAffixMaps=1

private int maxAffixCopies=2000000000

private int maxEdges=2000000000

private int maxEdges2=2000000000

private boolean allowAllContainedOverlaps=false

*Trim left bases of the read to this position (exclusive, 0-based)
private int forceTrimLeft=-1

*Trim right bases of the read after this position (exclusive, 0-based)
private int forceTrimRight=-1

private boolean qTrimLeft=false

private boolean qTrimRight=false

private float trimQ=6

*Error rate for trimming (derived from trimq)
private final float trimE

int maxEdits=0

int maxSubs=0

int bandwidth=9

final boolean customBandwidth

float minIdentity=100

float minIdentityMult=0

float minLengthPercent=0

int minOverlapCluster=100

int minOverlapMerge=1

float minOverlapPercentCluster=0

float minOverlapPercentMerge=0

private int minClusterSize=1

private int minClusterSizeForStats=1

private boolean pickBestRepresentativePerCluster=false

long readsProcessed=0

long basesProcessed=0

long collisions=0

long containments=0

long baseContainments=0

long containmentCollisions=0

long matches=0

long baseMatches=0

long overlaps=0

long baseOverlaps=0

long overlapCollisions=0

long addedToMain=0

private final int subset

private final int subsetCount

private final boolean subsetMode

private final int k

private final int k2

private final boolean EA=Shared.EA()

private static ReadComparator comparator=ReadLengthComparator.comparator

private static int tcount=0

private LinkedHashMap<Long,ArrayList<Unit>> codeMap=new LinkedHashMap<Long,ArrayList<Unit>>(4000000)

private HashMap<LongM,ArrayList<Unit>> affixMap1=null

private HashMap<LongM,ArrayList<Unit>> affixMap2=null

private HashMap<LongM,ArrayList<Unit>>[] affixMaps=null

private ArrayDeque<ArrayList<Unit>> clusterQueue=null

private ArrayList<ArrayList<Unit>> processedClusters=null

private AtomicIntegerArray clusterNumbers=null

private static final UnitOffsetComparator UNIT_OFFSET_COMPARATOR=new UnitOffsetComparator()

private static final ClusterLengthComparator CLUSTER_LENGTH_COMPARATOR=new ClusterLengthComparator()

private static final long[][] hashcodes=makeCodes2(32)

public static final byte[] baseToNumber=new byte[128]

public static final byte[] baseToComplementNumber=new byte[128]

public static final byte[] baseToComplementExtended=new byte[128]

public static final int nmerLength=4

public static final int[] nmerIndex=makeNmerIndex(nmerLength)

public static final int maxNmer=Tools.max(nmerIndex)

private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

public static boolean showSpeed=true

public static boolean verbose=false

public static boolean ignoreReverseComplement=false

public static boolean preventTransitiveOverlaps=false

public static boolean ignoreAffix1=false

public static boolean parseDepth=false

public static boolean printLengthInEdges=false

public static float depthRatio=2

public static int MINSCAF=0

public static int THREADS=Shared.threads()

public static int threadMaxReadsToBuffer=4000

public static int threadMaxBasesToBuffer=32000000

public static boolean DISPLAY_PROGRESS=true

public static boolean UNIQUE_ONLY=false

public static boolean REQUIRE_MATCHING_NAMES=false

public static boolean NUMBER_GRAPH_NODES=true

public static boolean ADD_PAIRNUM_TO_NAME=true

public static boolean HASH_NS=false

public static final int FORWARD=0

public static final int FORWARDRC=1

public static final int REVERSE=2

public static final int REVERSERC=3

public static final String[] OVERLAP_TYPE_NAMES=new String[]{"FORWARD","FORWARDRC","REVERSE","REVERSERC"}

public static final String[] OVERLAP_TYPE_ABBREVIATIONS=new String[]{"F","FRC","R","RRC"}


#Methods
public static void main(String[] args)

public Dedupe(String[] args)

public void process()

public void process2()

private void killAffixMaps()

private ConcurrentReadInputStream[] makeCrisArray(ArrayList<Read> list)

private void processMatches(Timer t)

private void processContainments(Timer t)

private void findOverlaps(Timer t)

private long makeTransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countIntransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countRedundant(Timer t, ArrayList<Read> list)

private long countOverlaps(Timer t, ArrayList<Read> list)

private long fillClusterSizeMatrix(ArrayList<ArrayList<Unit>> clusters, long[][] clusterSize)

private void makeClusters(Timer t, ArrayList<Read> list)

private String toClusterSizeString(long[][] clusterSizeMatrix)

private void renameClusters(Timer t)

private void processMst(Timer t)

private void processClusters(Timer t, boolean mergeClusters)

private long removeInvalid(ArrayList<Read> list)

private static ArrayList<Read> addToArray(HashMap<Long,ArrayList<Unit>> codeMap, boolean sort, boolean clear, long outNum)

private void writeOutput(String clusterStatsFile, Timer t)

private void writeOutput(ArrayList<Read> list)

private void writeOutputClusters(String clusterStatsFile, ArrayList<ArrayList<Unit>> clist)

private void writeGraph(String graphFile, ArrayList<ArrayList<Unit>> clist)

private static String toGraphName(Read r)

private Unit pickBestRepresenative(ArrayList<Unit> alu, boolean clearList)

public static long hash(byte[] bases)

public static long hashReversed(byte[] bases)

public static boolean isCanonical(byte[] bases)

private static long[][] makeCodes(int symbols, int modes)

*Handles IUPAC codes and invalid symbols
static long[][] makeCodes2(int modes)

private void addDupe(Read r, Read primary)

*@param cluster
private void unvisit(ArrayList<Unit> cluster)

*@param cluster
private void reorderClusterBreadthFirst(ArrayList<Unit> cluster)

*Returns next cluster larger than 1 element.
*Singleton clusters are added directly to 'processed'.
private ArrayList<Unit> nextCluster()

public static boolean equalsRC(byte[] a, byte[] b)

public static boolean pairedEqualsRC(Unit ua, Unit ub)

private static boolean equalsRC(Unit ua, Unit ub)

public static int comparePairedRC(Unit ua, Unit ub)

private static int compareRC(Unit ua, Unit ub)

private static long hashTip(byte[] bases, boolean prefix, int k, int skipInitialBases)

private static final int calcMaxEdits(int maxEdits, float minIdentityMult, int len)

*@return
private int determineCluster2(int uid)

private int mergeClusterIds(int cluster1, int cluster2)

public static final int[] makeNmerIndex(int n)

*Makes a nmer (e.g., tetramer) profile of a cluster
private static final float[] makeNmerProfile(ArrayList<Unit> alu, long[] array_)

private static int reverseType(int type)

</class Dedupe>
<class Dedupe2>
*@author Brian Bushnell
*@date Jul 18, 2013
public final class Dedupe2

#Fields
private ConcurrentReadInputStream crisa

private final ByteStreamWriter dupeWriter

private String[] in1=null

private String[] in2=null

private String out=null

private String clusterFilePattern=null

private String outbest=null

private String outdupe=null

private String outcsf=null

private String outgraph=null

private int maxNs=-1

private long maxReads=-1

public boolean errorState=false

boolean sort=false

boolean absorbContainment=true

boolean absorbMatch=true

boolean findOverlaps=false

boolean makeClusters=false

boolean processClusters=false

boolean renameClusters=false

boolean absorbOverlap=false

boolean storeSuffix=true

boolean storeName=true

boolean storeQuality=true

boolean exact=true

boolean uniqueNames=true

boolean maxSpanningTree=false

boolean canonicizeClusters=true

boolean removeCycles=true

boolean fixMultiJoins=true

boolean fixCanonContradictions=false

boolean fixOffsetContradictions=false

boolean countTransitive=false

boolean countRedundant=false

private boolean multipleInputFiles=false

private boolean rigorousTransitive=false

private int numAffixMaps=1

private int maxAffixCopies=2000000000

private int maxEdges=2000000000

private int maxEdges2=2000000000

private boolean allowAllContainedOverlaps=false

*Trim left bases of the read to this position (exclusive, 0-based)
private int forceTrimLeft=-1

*Trim right bases of the read after this position (exclusive, 0-based)
private int forceTrimRight=-1

private boolean qTrimLeft=false

private boolean qTrimRight=false

private float trimQ=6

*Error rate for trimming (derived from trimq)
private final float trimE

int maxEdits=0

int maxSubs=0

int bandwidth=9

final boolean customBandwidth

float minIdentity=100

float minIdentityMult=0

float minLengthPercent=0

int minOverlapCluster=100

int minOverlapMerge=1

float minOverlapPercentCluster=0

float minOverlapPercentMerge=0

private int minClusterSize=1

private int minClusterSizeForStats=1

private boolean pickBestRepresentativePerCluster=false

long readsProcessed=0

long basesProcessed=0

long collisions=0

long containments=0

long baseContainments=0

long containmentCollisions=0

long matches=0

long baseMatches=0

long overlaps=0

long baseOverlaps=0

long overlapCollisions=0

long addedToMain=0

private final int subset

private final int subsetCount

private final boolean subsetMode

private final int k

private final int k2

private final boolean EA=Shared.EA()

private static ReadComparator comparator=ReadLengthComparator.comparator

private static int tcount=0

private LinkedHashMap<Long,ArrayList<Unit>> codeMap=new LinkedHashMap<Long,ArrayList<Unit>>(4000000)

private HashMap<LongM,ArrayList<Unit>>[] affixMaps=null

private ArrayDeque<ArrayList<Unit>> clusterQueue=null

private ArrayList<ArrayList<Unit>> processedClusters=null

private AtomicIntegerArray clusterNumbers=null

private static final UnitOffsetComparator UNIT_OFFSET_COMPARATOR=new UnitOffsetComparator()

private static final ClusterLengthComparator CLUSTER_LENGTH_COMPARATOR=new ClusterLengthComparator()

private static final long[][] hashcodes=makeCodes2(32)

public static final byte[] baseToNumber=new byte[128]

public static final byte[] baseToComplementNumber=new byte[128]

public static final byte[] baseToComplementExtended=new byte[128]

public static final int nmerLength=4

public static final int[] nmerIndex=makeNmerIndex(nmerLength)

public static final int maxNmer=Tools.max(nmerIndex)

private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

public static boolean showSpeed=true

public static boolean verbose=false

public static boolean ignoreReverseComplement=false

public static boolean preventTransitiveOverlaps=false

public static boolean ignoreAffix1=false

public static boolean parseDepth=false

public static boolean printLengthInEdges=false

public static float depthRatio=2

public static int MINSCAF=0

public static int THREADS=Shared.threads()

public static int threadMaxReadsToBuffer=4000

public static int threadMaxBasesToBuffer=32000000

public static boolean DISPLAY_PROGRESS=true

public static boolean UNIQUE_ONLY=false

public static boolean REQUIRE_MATCHING_NAMES=false

public static boolean NUMBER_GRAPH_NODES=true

public static boolean ADD_PAIRNUM_TO_NAME=true

public static boolean HASH_NS=false

public static final int FORWARD=0

public static final int FORWARDRC=1

public static final int REVERSE=2

public static final int REVERSERC=3

public static final String[] OVERLAP_TYPE_NAMES=new String[]{"FORWARD","FORWARDRC","REVERSE","REVERSERC"}

public static final String[] OVERLAP_TYPE_ABBREVIATIONS=new String[]{"F","FRC","R","RRC"}


#Methods
public Dedupe2(String[] args)

public void process()

public void process2()

private void killAffixMaps()

private ConcurrentReadInputStream[] makeCrisArray(ArrayList<Read> list)

private void processMatches(Timer t)

private void processContainments(Timer t)

private void findOverlaps(Timer t)

private long makeTransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countIntransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countRedundant(Timer t, ArrayList<Read> list)

private long countOverlaps(Timer t, ArrayList<Read> list)

private long fillClusterSizeMatrix(ArrayList<ArrayList<Unit>> clusters, long[][] clusterSize)

private void makeClusters(Timer t, ArrayList<Read> list)

private String toClusterSizeString(long[][] clusterSizeMatrix)

private void renameClusters(Timer t)

private void processMst(Timer t)

private void processClusters(Timer t, boolean mergeClusters)

private long removeInvalid(ArrayList<Read> list)

private static ArrayList<Read> addToArray(HashMap<Long,ArrayList<Unit>> codeMap, boolean sort, boolean clear, long outNum)

private void writeOutput(String clusterStatsFile, Timer t)

private void writeOutput(ArrayList<Read> list)

private void writeOutputClusters(String clusterStatsFile, ArrayList<ArrayList<Unit>> clist)

private void writeGraph(String graphFile, ArrayList<ArrayList<Unit>> clist)

private static String toGraphName(Read r)

private Unit pickBestRepresenative(ArrayList<Unit> alu, boolean clearList)

public static long hash(byte[] bases)

public static long hashReversed(byte[] bases)

public static boolean isCanonical(byte[] bases)

private static long[][] makeCodes(int symbols, int modes)

*Handles IUPAC codes and invalid symbols
private static long[][] makeCodes2(int modes)

private void addDupe(Read r)

*@param cluster
private void unvisit(ArrayList<Unit> cluster)

*@param cluster
private void reorderClusterBreadthFirst(ArrayList<Unit> cluster)

*Returns next cluster larger than 1 element.
*Singleton clusters are added directly to 'processed'.
private ArrayList<Unit> nextCluster()

public static boolean equalsRC(byte[] a, byte[] b)

public static boolean pairedEqualsRC(Unit ua, Unit ub)

private static boolean equalsRC(Unit ua, Unit ub)

public static int comparePairedRC(Unit ua, Unit ub)

private static int compareRC(Unit ua, Unit ub)

private static long hashTip(byte[] bases, boolean prefix, int k, int skipInitialBases)

private static final int calcMaxEdits(int maxEdits, float minIdentityMult, int len)

*@return
private int determineCluster2(int uid)

private int mergeClusterIds(int cluster1, int cluster2)

private static final int[] makeNmerIndex(int n)

*Makes a nmer (e.g., tetramer) profile of a cluster
private static final float[] makeNmerProfile(ArrayList<Unit> alu, long[] array_)

private static int reverseType(int type)

</class Dedupe2>
<class DedupeByMapping>
*@author Brian Bushnell
*@date Jan 30, 2015
public class DedupeByMapping

#Fields
private boolean keepUnmapped

private boolean keepSingletons

private boolean sorted

private static boolean usePairOrder

private long duplicateReads=0

private long duplicateBases=0

private long unmappedReads=0

private long unmappedBases=0

private long retainedReads=0

private long retainedBases=0

private int initialSize=(int)Tools.min(2000000,Tools.max(80000,Shared.memAvailable(1) / 4000))

private HashMap<String,Integer> contigToNumber=new HashMap<String,Integer>(initialSize)

private LinkedHashMap<Quad,Read> quadToRead=new LinkedHashMap<Quad,Read>(initialSize)

private LinkedHashMap<String,Read> nameToRead=new LinkedHashMap<String,Read>(initialSize)

private ArrayList<Read> unmapped=new ArrayList<Read>(initialSize / 2)

private PriorityQueue<Quad> queue


#Methods
*@param args
public DedupeByMapping(String[] args)

@Override protected void setDefaults()

@Override public boolean parseArgument(String arg, String a, String b)

@Override protected final boolean useSharedHeader()

@Override protected boolean processReadPair(Read r1, Read r2)

boolean processReadPair_unsorted(Read r1)

boolean processReadPair_sorted(Read r1)

@Override protected void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

void processInner_unsorted(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

void processInner_sorted(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

@Override protected void startupSubclass()

@Override protected void shutdownSubclass()

@Override protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

private Quad toQuad(Read r1, Read r2)

</class DedupeByMapping>
<class DedupeProtein>
*@author Brian Bushnell
*@date Nov 30, 2017
public final class DedupeProtein

#Fields
private ConcurrentReadInputStream crisa

private final ByteStreamWriter dupeWriter

private String[] in1=null

private String[] in2=null

private String out=null

private String clusterFilePattern=null

private String outbest=null

private String outdupe=null

private String outcsf=null

private String outgraph=null

private int maxNs=-1

private long maxReads=-1

public boolean errorState=false

boolean sort=false

boolean absorbContainment=true

boolean absorbMatch=true

boolean findOverlaps=false

boolean makeClusters=false

boolean processClusters=false

boolean renameClusters=false

boolean absorbOverlap=false

boolean storeSuffix=false

boolean storeName=true

boolean storeQuality=true

boolean exact=true

boolean uniqueNames=true

boolean maxSpanningTree=false

boolean removeCycles=true

boolean fixMultiJoins=true

boolean fixOffsetContradictions=false

boolean countTransitive=false

boolean countRedundant=false

private boolean multipleInputFiles=false

private boolean rigorousTransitive=false

private int numAffixMaps=1

private int maxAffixCopies=2000000000

private int maxEdges=2000000000

private int maxEdges2=2000000000

private boolean allowAllContainedOverlaps=false

*Trim left bases of the read to this position (exclusive, 0-based)
private int forceTrimLeft=-1

*Trim right bases of the read after this position (exclusive, 0-based)
private int forceTrimRight=-1

private boolean qTrimLeft=false

private boolean qTrimRight=false

private float trimQ=6

*Error rate for trimming (derived from trimq)
private final float trimE

int maxEdits=0

int maxSubs=0

int bandwidth=9

final boolean customBandwidth

float minIdentity=100

float minIdentityMult=0

float minLengthPercent=0

int minOverlapCluster=100

int minOverlapMerge=1

float minOverlapPercentCluster=0

float minOverlapPercentMerge=0

private int minClusterSize=1

private int minClusterSizeForStats=1

private boolean pickBestRepresentativePerCluster=false

long readsProcessed=0

long basesProcessed=0

long collisions=0

long containments=0

long baseContainments=0

long containmentCollisions=0

long matches=0

long baseMatches=0

long overlaps=0

long baseOverlaps=0

long overlapCollisions=0

long addedToMain=0

private final int subset

private final int subsetCount

private final boolean subsetMode

private final int k

private final int k2

private final boolean EA=Shared.EA()

static final int bitsPerBase=5

private static ReadComparator comparator=ReadLengthComparator.comparator

private static int tcount=0

private LinkedHashMap<Long,ArrayList<Unit>> codeMap=new LinkedHashMap<Long,ArrayList<Unit>>(4000000)

private HashMap<LongM,ArrayList<Unit>> affixMap1=null

private HashMap<LongM,ArrayList<Unit>> affixMap2=null

private HashMap<LongM,ArrayList<Unit>>[] affixMaps=null

private ArrayDeque<ArrayList<Unit>> clusterQueue=null

private ArrayList<ArrayList<Unit>> processedClusters=null

private AtomicIntegerArray clusterNumbers=null

private static final UnitOffsetComparator UNIT_OFFSET_COMPARATOR=new UnitOffsetComparator()

private static final ClusterLengthComparator CLUSTER_LENGTH_COMPARATOR=new ClusterLengthComparator()

private static final long[][] hashcodes=makeCodes2(32,1)

private static final long[][] hashcodesR=makeCodes2(32,2)

public static final byte[] acidToNumber=new byte[128]

public static final int nmerLength=4

public static final int maxNmer=((int)Math.pow(20,nmerLength)) - 1

private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

public static boolean showSpeed=true

public static boolean verbose=false

public static boolean preventTransitiveOverlaps=false

public static boolean ignoreAffix1=false

public static boolean parseDepth=false

public static boolean printLengthInEdges=false

public static float depthRatio=2

public static int MINSCAF=0

public static int THREADS=Shared.threads()

public static int threadMaxReadsToBuffer=4000

public static int threadMaxBasesToBuffer=32000000

public static boolean DISPLAY_PROGRESS=true

public static boolean UNIQUE_ONLY=false

public static boolean REQUIRE_MATCHING_NAMES=false

public static boolean NUMBER_GRAPH_NODES=true

public static boolean ADD_PAIRNUM_TO_NAME=true

public static boolean HASH_NS=false

public static final int FORWARD=0

public static final int REVERSE=2

public static final String[] OVERLAP_TYPE_NAMES=new String[]{"FORWARD","FORWARDRC","REVERSE","REVERSERC"}

public static final String[] OVERLAP_TYPE_ABBREVIATIONS=new String[]{"F","FRC","R","RRC"}


#Methods
public DedupeProtein(String[] args)

private void killAffixMaps()

private ConcurrentReadInputStream[] makeCrisArray(ArrayList<Read> list)

private void processMatches(Timer t)

private void processContainments(Timer t)

private void findOverlaps(Timer t)

private long makeTransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countIntransitive(Timer t, ArrayList<Read> list, boolean rigorous)

private int countRedundant(Timer t, ArrayList<Read> list)

private long countOverlaps(Timer t, ArrayList<Read> list)

private long fillClusterSizeMatrix(ArrayList<ArrayList<Unit>> clusters, long[][] clusterSize)

private void makeClusters(Timer t, ArrayList<Read> list)

private String toClusterSizeString(long[][] clusterSizeMatrix)

private void renameClusters(Timer t)

private void processMst(Timer t)

private void processClusters(Timer t, boolean mergeClusters)

private long removeInvalid(ArrayList<Read> list)

private static ArrayList<Read> addToArray(HashMap<Long,ArrayList<Unit>> codeMap, boolean sort, boolean clear, long outNum)

private void writeOutput(String clusterStatsFile, Timer t)

private void writeOutput(ArrayList<Read> list)

private void writeOutputClusters(String clusterStatsFile, ArrayList<ArrayList<Unit>> clist)

private void writeGraph(String graphFile, ArrayList<ArrayList<Unit>> clist)

private static String toGraphName(Read r)

private Unit pickBestRepresenative(ArrayList<Unit> alu, boolean clearList)

public static long hash(byte[] bases)

public static long hashReversed(byte[] bases)

private static long[][] makeCodes(int symbols, int modes, long seed)

*Handles IUPAC codes and invalid symbols
private static long[][] makeCodes2(int modes, long seed)

private void addDupe(Read r)

*@param cluster
private void unvisit(ArrayList<Unit> cluster)

*@param cluster
private void reorderClusterBreadthFirst(ArrayList<Unit> cluster)

*Returns next cluster larger than 1 element.
*Singleton clusters are added directly to 'processed'.
private ArrayList<Unit> nextCluster()

public static boolean equalsRC(byte[] a, byte[] b)

public static boolean pairedEqualsRC(Unit ua, Unit ub)

private static boolean equalsRC(Unit ua, Unit ub)

public static int comparePairedRC(Unit ua, Unit ub)

private static int compareRC(Unit ua, Unit ub)

private long hashTip(byte[] bases, boolean prefix, int k, int skipInitialBases)

private static final int calcMaxEdits(int maxEdits, float minIdentityMult, int len)

*@return
private int determineCluster2(int uid)

private int mergeClusterIds(int cluster1, int cluster2)

*Makes a nmer (e.g., tetramer) profile of a cluster
private final float[] makeNmerProfile(ArrayList<Unit> alu, long[] array_)

private static boolean isFullyDefined(byte b)

private static int reverseType(int type)

</class DedupeProtein>
<class DemuxByName>
*@author Brian Bushnell
*@date Oct 9, 2014
public class DemuxByName

#Fields
private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String outu1=null

private String outu2=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

private long maxReads=-1

private String delimiter=null

private boolean prefixMode=true

private boolean substringMode=false

private boolean perheader=false

private int column=-1

private boolean warned=false

private int fixedAffixLength=-1

private int[] affixLengths

private HashSet<String> names=new HashSet<String>()

private HashMap<String,ArrayList<Read>> nameToArray=new HashMap<String,ArrayList<Read>>()

private HashMap<String,ConcurrentReadOutputStream> nameToStream=new HashMap<String,ConcurrentReadOutputStream>()

private final FileFormat ffin1

private final FileFormat ffin2

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean useSharedHeader=false


#Methods
public static void main(String[] args)

public DemuxByName(String[] args)

void process(Timer t)

</class DemuxByName>
<class DemuxByName2>
*This class is designed to handle very large numbers of output files
*with a fixed number of file handles. An example use case is demultiplexing
*Illumina Novaseq runs.
*@author Brian Bushnell
*@date May 1, 2019
public class DemuxByName2

#Fields
*Primary input file
private String in1=null

*Optional input file for read 2 of paired reads in twin files
private String in2=null

*Input qual file 1
private String qfin1=null

*Input qual file 2
private String qfin2=null

*Output file pattern 1
private String out1=null

*Output file pattern 2
private String out2=null

*Output qual file 1
private String qfout1=null

*Output qual file 2
private String qfout2=null

*Unmatched read output file 1
private String outu1=null

*Unmatched read output file 2
private String outu2=null

*File extension override for input files
private String extin=null

*File extension override for output files
private String extout=null

*Pre-counted barcodes
private String countsIn=null

*Output for barcode counts
private String countsOut=null

*Ignore barcodes occuring fewer times than this.
*Saves memory and speeds processing.
private long minCount0=0

private long minCountR=4

private long minCountA=4

*Premade assignment map
private String mapIn=null

*Assignment map output
private String mapOut=null

*Primary input file
private final FileFormat ffin1

*Read 2 input file
private final FileFormat ffin2

*Input reads
long readsProcessed=0

long basesProcessed=0

*Demultiplexed output reads
long readsOut=0

long basesOut=0

*Output reads that did not get demultiplexed
long readsUnmatched=0

long basesUnmatched=0

*Stop after this many input reads
private long maxReads=-1

*File to print number of reads sent to each output file
private String stats=null

*For splitting headers on a symbol
private String delimiter=null

*For splitting headers faster if the delimiter is just one character
private char delimiterChar=0

*Precompiled pattern matching the delimiter
private Pattern delimiterPattern=null

*For replacing symbols in the filename
private byte[] remap=null

*If there is a delimiter, use this column after splitting.
*Column is 1-based.
private int column=-1

*Use the prefix of a header. If false, use the suffix.
*This is ignored if column is set.
private boolean prefixMode=true

*How to select a read's key; see static modes array
private int mode=AFFIX_MODE

*Track per-output-file cardinality; may be slow
private boolean trackCardinality=false

*Prevents issuing warnings multiple times
private boolean warned=false

private boolean printRetireTime=false

*Hamming distance for read indexes
private int hdist=0

*Do not create files with under this many reads.
*Increases memory usage since reads must be retained until processing is finished.
*Upon running out of memory the program may go very slowly.
private long minReadsToDump=0

*Affix length if fixed
private int fixedLength=-1

*All possible affix lengths if there are multiple.
*Basically, the lengths of everything in names.
private int[] lengthArray

*A set of recognized names and the output names they map to.
*The keys and values will be identical unless a Hamming distance is used.
*This is only filled if explicit names are provided.
private HashMap<String,String> assignmentMap=new HashMap<String,String>()

private ArrayList<String> expectedList

*These are for dual barcodes and normally null unless
*the mutant table would grow too big.
private HashMap<String,String> leftNames=null

*These are for dual barcodes and normally null unless
*the mutant table would grow too big.
private HashMap<String,String> rightNames=null

*Names in list form, for substring matching
private ArrayList<String> nameList=new ArrayList<String>()

*Whether input file interleaving was explicitly set
private boolean setInterleaved=false

private IlluminaHeaderParser2 ihp=new IlluminaHeaderParser2()

private int barcodeDelimiter=0

private int barcodeLength1=0

private int barcodeLength2=0

private boolean rcIndex1=false

private boolean rcIndex2=false

private PCRMatrix pcrMatrix

private boolean useMatrix=false

private boolean hdistSum=true

*Print messages here
private PrintStream outstream=System.err

*True if errors were encountered
public boolean errorState=false

*Permission to overwrite existing files.
private boolean overwrite=true

*Append to existing files rather than overwriting.
*It is not advisable to set this flag for this class.
private boolean append=false

*Retain header of sam/bam files.
private boolean useSharedHeader=false

*Operation mode for selection of key
public static final int AFFIX_MODE=1

*Operation mode for selection of key
public static final int DELIMITER_MODE=2

*Operation mode for selection of key
public static final int BARCODE_MODE=3

*Operation mode for selection of key
public static final int SUBSTRING_MODE=4

*Operation mode for selection of key
public static final int HEADER_MODE=5

*Operation mode for selection of key
public static final int CHROM_MODE=6

*Operation mode for selection of key
public static final int TILE_MODE=7

*Symbols allowed to substitute for Hamming distance.
*Hamming distance is intended for barcodes only.
private static final byte[] symbols={'A','C','G','T','N'}

private static final String empty=""

*Verbose messages for debugging
public static boolean verbose=false

public static boolean statsOnly=false


#Methods
*Constructor.
*@param args Command line arguments
public DemuxByName2(String[] args)

*Parse command-line arguments
*@param args Command-line arguments
*@return A Parser object with fields filled from the parameters
private Parser parse(String[] args)

*Ensure input and output files are specified correctly,
*and that interleaved mode is consistent with the number of input files.
private void validate()

*Perform necessary setup of variables and data structures
*related to the processing mode and the names table.
private void handleModeAndNames()

*Primary method.
*Starts and stops I/O streams, processes the data, and prints results.
*@param t A timer that was already started.
void process(Timer t)

*Create and start the input stream (cris).
private ConcurrentReadInputStream makeInputStream()

*Create and start the normal output streams (mcros).
private BufferedMultiCros makeMatchedOutputStream(boolean pairedInput)

*Create and start the unmatched output stream (rosu).
private ConcurrentReadOutputStream makeUnmatchedOutputStream()

*Process all reads.
*@param cris Input stream (required).
*@param mcros Matched read output stream (optional).
*@param rosu Unmatched read output stream (optional).
private void processInner(ConcurrentReadInputStream cris, BufferedMultiCros mcros, ConcurrentReadOutputStream rosu)

*Finish writing and close streams.
*@param cris Input stream (required).
*@param mcros Matched read output stream (optional).
*@param rosu Unmatched read output stream (optional).
private void cleanup(ConcurrentReadInputStream cris, BufferedMultiCros mcros, ConcurrentReadOutputStream rosu)

*@param t A Timer that has already been stopped
private void printResultsToScreen(Timer t)

*Generate mutants for all names according to the hamming distance
*@param names Map of names to mutate
*@param hdist Hamming distance
*@param outstream Report results here
*@return Number of mutants added (net)
private static int mutate_old(HashMap<String,String> names, int hdist, PrintStream outstream)

*Generate mutants for one name, recursively
*@param keyArray Current key (name) as a byte array, to be modified
*@param value Name to which this key should map
*@param hdist Remaining Hamming distance
*@param names Names table to insert the mutants
*@param collisions Set of keys mapping to multiple values
*@return Number of mutants added
private static int addMutants_old(byte[] keyArray, String value, int hdist, HashMap<String,String> names, HashSet<String> collisions)

private static void mutateUnified(HashMap<String,String> input, int maxHDist, PrintStream outstream)

@SuppressWarnings private static HashMap<String,String>[] mutateDual(HashMap<String,String> input, int maxHDist, int delimiter, PrintStream outstream)

private static void addMutants(HashMap<String,String> input)

private static int addMutants2(String k0, String v0, HashMap<String,String> map)

*Returns the value this read maps to; meaning, the variable part of the output filename
private String getValue(Read r)

private int hdist(String q, String r)

public String findClosest(String q, int maxHDist, int clearzone)

*Generates a key from the read header
private String getKey(Read r)

*Print statistics about demultiplexing to a file.
*@param mcros Output stream, after processing is completely finished.
void printReport(BufferedMultiCros mcros)

</class DemuxByName2>
<class Difference>
*@author Brian Bushnell
*@date Oct 9, 2013
public class Difference

#Methods
public static void main(String[] args)

</class Difference>
<class FilterByCoverage>
*@author Brian Bushnell
*@date October 8, 2014
public class FilterByCoverage

#Fields
private String in1=null

private String covStatsBefore=null

private String covStatsAfter=null

private String name=null

private String qfin1=null

private String outclean=null

private String outdirty=null

private String qfoutclean=null

private String qfoutdirty=null

private String extin=null

private String extout=null

private long maxReads=-1

*Scaffolds shorter than this will be discarded.
private int minLength=0

*Scaffolds with fewer mapped reads will be discarded.
private long minReads=0

*Scaffolds with lower average coverage will be discarded.
private double minCoverage=5

*Scaffolds with a lower percent of covered bases will be discarded.
private double minCoveredPercent=40

*Scaffolds will NOT be discarded based on low coverage unless the coverage dropped by at least this factor.
private double minRatio=0

*Scaffolds will be discarded if there are at least this many bases in windows below a coverage cutoff.
private int basesUnderMin=-1

*Trim this much from sequence ends
private int trimEnds=0

private final FileFormat ffin1

private final FileFormat ffCov0

private final FileFormat ffCov1

private final FileFormat ffoutclean

private final FileFormat ffoutdirty

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean logappend=false

private String logfile=null

private boolean logheader=true

private static boolean PRINT_SHORT_CONTIG_RESULTS=false


#Methods
public FilterByCoverage(String[] args)

void process(Timer t)

</class FilterByCoverage>
<class FilterBySequence>
*Filters by exact sequence matches.
*Similar to Dedupe.
*@author Brian Bushnell
*@date December 18, 2015
public class FilterBySequence

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Ref input file path
private String[] ref=null

*Literals
private String[] literal=null

private HashSet<Code> refSet

private ArrayList<byte[]> refList

private boolean storeBases=true

private boolean include=true

private boolean rcomp=true

private boolean toUpperCase=true

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

protected long readsLoaded=0

protected long basesLoaded=0

*Number of reads output
protected long readsOut=0

*Number of bases output
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private int maxSubs=0

private float mismatchFraction=0f

private int maxLengthDif=0

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Reference Files
private final FileFormat[] ffref

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public FilterBySequence(String[] args)

*Create read streams and process all data
void process(Timer t)

*Load ref sequences
private void processReference(FileFormat ff)

*Spawn process threads
private void spawnLoadThreads(ConcurrentReadInputStream cris)

*Spawn process threads
private void spawnProcessThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

private void addToRef(Collection<Code> codes)

private void addToRef(Code c)

</class FilterBySequence>
<class FilterReadsWithSubs>
*Filters to select only reads with substitution errors
*for bases with quality scores in a certain interval.
*Used for manually examining specific reads that may have
*incorrectly calibrated quality scores, for example.
*@author Brian Bushnell
*@date May 5, 2015
public class FilterReadsWithSubs

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private long maxReads=-1

private long readsProcessed=0

private long readsOut=0

private long basesProcessed=0

private long basesOut=0

public int minq

public int maxq

public int minSubs

public int maxClips=Integer.MAX_VALUE

public int minClips=0

public boolean countIndels

public boolean keepPerfect

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public FilterReadsWithSubs(String[] args)

void process(Timer t)

private boolean processRead(Read r1)

</class FilterReadsWithSubs>
<class FindHiCJunctions>
*@author Brian Bushnell
*@date Oct 17, 2014
public class FindHiCJunctions

#Fields
private String in1=null

private String out1=null

private String extin=null

private String extout=null

private String junctionFile="junctions_k%.txt"

private long maxReads=-1

private int minClipLength=8

private int minTrimLength=25

private int minCount=2

private float minFraction=0.0005f

boolean printKmers=true

boolean trim=true

private long[][] counts

private long[][] leftCounts

private long[][] rightCounts

private final FileFormat ffin1

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public FindHiCJunctions(String[] args)

void process(Timer t)

private void printKmers(int k, long[] array, String direction)

private boolean process(Read r, SamLine sl)

public static byte[] softClipMatch(byte[] match, int minClipLength, boolean allowMutation)

</class FindHiCJunctions>
<class FindPrimers>
*@author Brian Bushnell
*@date Oct 6, 2014
public class FindPrimers

#Fields
private String in1=null

private String out1=null

private String outIdHist=null

private AtomicIntegerArray idHist=new AtomicIntegerArray(101)

private final float cutoff

private boolean rcomp=true

private boolean replicateAmbiguous=false

private boolean swapQuery=false

private boolean addR=false

private boolean printZeros=true

private boolean oneColumn=false

private boolean useMSA2=false

private boolean useSSA2=true

private boolean useSSA1D=false

private final FileFormat ffin1

private final FileFormat ffout1

private ArrayList<Read> queries

private final int maxqlen

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

protected long readsProcessed=0

protected long basesProcessed=0

protected long readsOut=0

protected long basesOut=0

private long maxReads=-1

double identitySum=0

long identityCount=0

boolean ordered=true

boolean errorState=false

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public FindPrimers(String[] args)

void process(Timer t)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

public static int makeFlag(SiteScore ss)

@Override public final ReadWriteLock rwlock()

</class FindPrimers>
<class FindPrimers.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class FindPrimers.ProcessThread

#Fields
Aligner msa=Shared.AMINO_IN ? new SingleStateAlignerFlat2Amino() : useMSA2 ? new MultiStateAligner9PacBioAdapter2() : useSSA1D ? new SingleStateAlignerFlat2_1D() : useSSA2 ? new SingleStateAlignerFlat2() : new SingleStateAlignerFlat()

SingleStateAlignerFlat xxx0

MultiStateAligner9PacBioAdapter2 xxx1

SingleStateAlignerFlat2 xxx2

SingleStateAlignerFlat2_1D xxx3

Aligner xxx9

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

double identitySumT=0

long identityCountT=0

*True only if this thread has completed successfully
boolean success=false

private ByteBuilder bb=new ByteBuilder(1000)

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processRead(Read r)

private ByteBuilder toBytes(Read r, Read query, SiteScore ss)

private ByteBuilder toBytes(Read r, Read query)

</class FindPrimers.ProcessThread>
<class FindPrimers_old>
*@author Brian Bushnell
*@date Oct 6, 2014
public class FindPrimers_old

#Fields
private String in1=null

private String out1=null

private final float cutoff

private boolean rcomp=true

private boolean replicateAmbiguous=true

private final FileFormat ffin1

private final FileFormat ffout1

private ArrayList<Read> queries

private final int maxqlen

private int columns=2000

private String msaType="MultiStateAligner11ts"

private long maxReads=-1

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public FindPrimers_old(String[] args)

void process(Timer t)

private ByteBuilder toBytes(Read r, Read query, SiteScore ss)

public static int makeFlag(SiteScore ss)

</class FindPrimers_old>
<class FindString>
*@author Brian Bushnell
*@date Jun 18, 2013
public class FindString
</class FindString>
<class FungalRelease>
*Reformats a fungal assembly for release. Also creates contig and agp files.
*@author Brian Bushnell
*@date December 9, 2015
public class FungalRelease

#Fields
private int minGapIn=1

private int minGapOut=10

private int minScaf=1

private int minContig=1

private long scafNum=1

private long contigNum=1

private boolean sortScaffolds=true

private boolean sortContigs=false

private boolean banIupac=true

private boolean renameScaffolds=true

private boolean renameContigs=false

*Primary input file path
private String in1=null

private String qfin1=null

*Primary output file path
private String out1=null

private String outC=null

private String qfout1=null

private String qfoutC=null

private String agpFile=null

private String legendFile=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads processed
protected long readsOut=0

*Number of bases processed
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffout1

private final FileFormat ffoutC

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=false

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Constructor.
*@param args
*Command line arguments
public FungalRelease(String[] args)

*Create read streams and process all data
void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosc)

*Iterate through the reads
private ArrayList<Read> getReads(ConcurrentReadInputStream cris)

*Process a single read pair.
*@param r1
*Read 1
*@return True if the reads should be kept, false if they should be
*discarded.
boolean processRead(Read r1)

</class FungalRelease>
<class GatherKapaStats>
*@author Brian Bushnell
*@date May 9, 2016
public class GatherKapaStats

#Fields
private String in1=null

private String out1=null

private String addressPrefix="https://rqc.jgi.doe.gov/api/plate_ui/page/"

private String addressSuffix="/kapa spikein"

private boolean printRaw=false

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

private final FileFormat ffin1

private final FileFormat ffout1

private final JsonParser jp=new JsonParser()

private final LinkedHashMap<String,TagData> tagMap=new LinkedHashMap<String,TagData>(203)

private final LinkedHashMap<String,Plate> plateMap=new LinkedHashMap<String,Plate>(203)

final Well dummy=new Well("X",new JsonObject(),"X")

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public GatherKapaStats(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private ArrayList<Plate> loadPlates(ByteFile bf)

private void analyzePlates(ArrayList<Plate> plates)

private void printResults(ByteStreamWriter bsw)

private void printRawResults0(ByteStreamWriter bsw)

private void printRawResults(ByteStreamWriter bsw)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class GatherKapaStats>
<class GatherKapaStats.Plate>
class GatherKapaStats.Plate

#Fields
final String name

final String lot

ArrayList<Well> wells

LinkedHashMap<String,Well> tagToCorrectWellMap=new LinkedHashMap<String,Well>()


#Methods
public Plate(String name_, String lot_)

void fillFromWeb()

JsonObject grabData()

</class GatherKapaStats.Plate>
<class GatherKapaStats.Well>
class GatherKapaStats.Well

#Fields
final String name

String library

String instrument

String date

String alq_container_barcode

String seq_unit_name

String seq_proj_id

long reads

String seq_proj_name

String run_configuration

String correctKapaTag

long correctKapaReads

long incorrectKapaReads

double converted_offtarget_reads_ppm

LinkedHashMap<String,KapaEntry> kapaMap


#Methods
public Well(String name_, JsonObject jo, String plate)

void loadKapa(JsonObject kapa)

@Override public String toString()

</class GatherKapaStats.Well>
<class GatherKapaStats.KapaEntry>
class GatherKapaStats.KapaEntry

#Fields
String wellName

long reads

String tagName


#Methods
KapaEntry(Object[] array)

KapaEntry(String wellName_, long reads_, String tagName_)

@Override public String toString()

</class GatherKapaStats.KapaEntry>
<class GatherKapaStats.TagData>
class GatherKapaStats.TagData

#Fields
final String name

final String wellName

int timesSeen=0

LinkedHashMap<String,ArrayList<Double>> ppmMap=new LinkedHashMap<String,ArrayList<Double>>(203)

LinkedHashMap<String,ArrayList<String>> plateNameMap=new LinkedHashMap<String,ArrayList<String>>(203)


#Methods
TagData(String name_, String wellName_)

void add(String tag, double ppmk, String plate)

double[] getPpmArray(String key, boolean sort)

String[] getPlateNameArray(String key, boolean sort)

double[] toPpmArray(ArrayList<Double> list, boolean sort)

String[] toPlateArray(ArrayList<String> list, boolean sort)

@Override public int compareTo(TagData other)

</class GatherKapaStats.TagData>
<class GetReads>
*Grab reads with specified numbers from a file.
*TODO Note that much of this is ripped directly from ReformatReads, but is incorrect, because this class does not support dual output files.
*@author Brian Bushnell
*@date Jul 10, 2013
public class GetReads

#Fields
private PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public GetReads(String[] args)

</class GetReads>
<class GradeMergedReads>
*@author Brian Bushnell
*@date May 20, 2014
public class GradeMergedReads

#Fields
private String in=null

private String extin=null

private String raw1=null

private String raw2=null

private long maxReads=-1

private final FileFormat ffin

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false


#Methods
public static void main(String[] args)

public GradeMergedReads(String[] args)

void process(Timer t)

public static int parseInsert(String s)

</class GradeMergedReads>
<class GreedyBarCodeFinder>
*@author Brian Bushnell
*@date Jul 10, 2014
public class GreedyBarCodeFinder

#Fields
private final int k

private final int hdist

private int rounds

static int MAX_HOMOPOLYMER_LENGTH=99


#Methods
public static void main(String[] args)

public GreedyBarCodeFinder(String[] args)

public int find(int rounds)

static int mainOld(int k, int hdist, ArrayList<String> list)

static int test(int k, int hdist, int[] set, ArrayList<String> list)

</class GreedyBarCodeFinder>
<class IdentityMatrix>
*Calculates an all-to-all identity matrix.
*@author Brian Bushnell
*@date Nov 23, 2014
public class IdentityMatrix

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private boolean percent=false

private ArrayList<Read> allReads

private long maxReads=-1

private final int maxEdits

private final int maxWidth

private int longestSequence

private double minID=1

private double maxID=0

private double avgID=0

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public IdentityMatrix(String[] args)

void process(Timer t)

private ArrayList<Read> load()

</class IdentityMatrix>
<class Info>
*@author Brian Bushnell
*@date Sep 19, 2012
public final class Info

#Fields
private static final byte[] numberToBase={'A','C','G','T','N'}

*Element i is: 0 for 'A', 1 for 'C', 2 for 'G', 3 for 'T', -1 otherwise
public static final byte[] baseToNumber=new byte[128]

private static final long MAX=Long.MAX_VALUE

private static final double invlog2=1.0 / Math.log(2)


#Methods
public static void main(String[] args)

public static void printInfo(String s)

public static long info(String s)

public static int infoInBits(byte[] array, int from, int len)

public static double infoInBitsDouble(byte[] array, int from, int len)

public static long info(byte[] array)

public static long info(byte[] array, int from, int len)

public static int prefixForInfoBits(byte[] array, int bits)

public static int prefixForInfoBits(byte[] array, int bits, int from)

public static int prefixForInfo(byte[] array, long info)

public static int prefixForInfo(byte[] array, long info, int from)

private static final int min(int x, int y)

private static final int max(int x, int y)

</class Info>
<class KeepBestCopy>
*Designed to keep the best copy of an SSU per organism.
*@author Brian Bushnell
*@date Oct 4, 2019
public class KeepBestCopy

#Fields
private String in1=null

private String qfin1=null

private String out1=null

private String qfout1=null

private String extin=null

private String extout=null

int maxLen=1600

private long maxReads=-1

private LinkedHashMap<Integer,Read> map=new LinkedHashMap<Integer,Read>()

private final FileFormat ffin1

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public KeepBestCopy(String[] args)

ConcurrentReadInputStream makeCris()

private boolean process(Read r)

private boolean isBetterThan(Read r, Read old)

</class KeepBestCopy>
<class KExpand>
*Generates mutants of kmers.
*@author Brian Bushnell
*@date January 8, 2021
public class KExpand

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private boolean rcomp=true

private int k=31

*k-1; used in some expressions
final int k2

private int speed=0

private int skip=0

private int editDist=0

private int maxSubs=99

private int maxDels=99

private int maxInss=99

private int maxEdits=99

private int subDist=0

private int delDist=0

private int insDist=0

private LongListSet set=new LongListSet()

*True for amino acid data, false for nucleotide data
final boolean amino

final int bitsPerBase

final int maxSymbol

final int symbols

final int symbolArrayLen

final int symbolSpace

final long symbolMask

final int minlen

final int minlen2

final int shift

final int shift2

final long mask

*x&clearMasks[i] will clear base i
final long[] clearMasks

*x|setMasks[i][j] will set base i to j
final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
final long[] rightMasks

private final byte[] symbolToNumber0

private final byte[] symbolToComplementNumber0

private final byte[] symbolToNumber

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of kmers processed
protected long kmersProcessed=0

*Number of kmers added (includes mutants)
protected long kmersAdded=0

*Number of reads output
protected long readsOut=0

*Number of bases output
protected long basesOut=0

*Number of kmers output
protected long kmersOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public KExpand(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Create read streams and process all data
void process(Timer t)

private void dumpKmers(ConcurrentReadOutputStream ros)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros()

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris)

*Process a list of Reads.
*@param ln The list.
*@param cris Read Input Stream
*@param ros Read Output Stream for reads that will be retained
void processList(ListNum<Read> ln, ConcurrentReadInputStream cris)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return Number of kmers added.
long processReadPair(Read r1, Read r2)

private long addToMap(Read r, int skip)

*Adds this kmer to the table, including any mutations implied by subDist, etc.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len Kmer length
*@param subDist Number of substitutions to allow
*@param delDist Number of deletions to allow
*@param insDist Number of insertions to allow
*@param extraBase Base added to end in case of deletions
*@param extraBase2 Base added to end in case of deletions
*@param extraBase3 Base added to end in case of deletions
*@return Number of kmers stored
private long addAndMutate(long kmer, long rkmer, int len, long extraBase, long extraBase2, long extraBase3)

*Adds this kmer to the set.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len Kmer length
*@return Number of kmers added
private long addKey(long kmer, long rkmer, int len)

@Deprecated private long mutateSDI(long kmer, long rkmer, int len, int maxEdits, int subDist, int delDist, int insDist, long extraBase, long extraBase2, long extraBase3)

*Mutate and store this kmer through 'dist' recursions.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len Kmer length
*@param editDist Number of edits to allow
*@param extraBase Base added to end in case of deletions
*@param extraBase2 Base added to end in case of deletions
*@param extraBase3 Base added to end in case of deletions
*@return Number of kmers stored
private long mutateE(long kmer, long rkmer, int len, int editDist, int maxSubs, int maxDels, int maxInss, long extraBase, long extraBase2, long extraBase3)

*Transforms a kmer into a canonical value. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@return Canonical value
final long toValue(long kmer, long rkmer)

final long rcomp(long kmer, int len)

final boolean passesSpeed(long key)

final boolean failsSpeed(long key)

*Returns true if the symbol is not degenerate (e.g., 'N') for the alphabet in use.
final boolean isFullyDefined(byte symbol)

*For verbose / debugging output
final String kmerToString(long kmer, int k)

</class KExpand>
<class KmerCountExact>
*@author Brian Bushnell
*@date Nov 22, 2013
public class KmerCountExact

#Fields
*Hold kmers.
private final AbstractKmerTableSet tables

private AbstractKmerTableSet tables2

private boolean shave=false

private boolean rinse=false

private int shaveDepth=1

private double averageCount=-1

private long basesIn=-1

private long readsIn=-1

private int decimals=3

private long kmersRemoved=0

*Kmer count output file
private String outKmers=null

*Histogram output file
private String outHist=null

*Histogram peak output file
private String outPeaks=null

private int smoothRadius=1

private boolean smoothKhist=false

private boolean smoothPeaks=false

private boolean errorState=false

*Histogram columns
private int histColumns=2

*Histogram rows
private int histMax=100000

*Print a histogram header
private boolean histHeader=true

*Histogram show rows with 0 count
private boolean histZeros=false

*Add gc information to kmer histogram
protected boolean gcHist=false

boolean doLogScale=true

double logWidth=0.1

int logPasses=1

private long minHeight=2

private long minVolume=5

private int minWidth=3

private int minPeak=2

private int maxPeak=Integer.MAX_VALUE

private int maxPeakCount=12

private int ploidy=-1

private String sketchPath=null

private int sketchLength=10000

private String sketchName

private int sketchID

private final FileFormat ffSketch

private String ref=null

private String intersectionFile=null

private boolean bidirectional=true

private int refMax=6

*min kmer count to dump to text
private int minToDump=1

private int maxToDump=Integer.MAX_VALUE

final int k

*Print messages to this stream
private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

*Verbose messages
public static final boolean verbose=false

*Number of ProcessThreads
public static int THREADS=Shared.threads()


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public KmerCountExact(String[] args)

public void process(Timer t)

public void process2()

void processRef()

public static long[][] intersectionST_first(AbstractKmerTableSet tables, AbstractKmerTableSet tables2, int xMax, int yMax, boolean bidirectional)

public static long[][] intersectionST_second(AbstractKmerTableSet tables, AbstractKmerTableSet tables2, int xMax, int yMax, boolean bidirectional)

public static long[][] intersectionST(AbstractKmerTableSet tables, AbstractKmerTableSet tables2, int xMax, int yMax, boolean bidirectional)

long shave(boolean shave, boolean rinse, int maxShaveDepth)

private double makeKhist(String fname, String peaks, int cols, int max, boolean printHeader, boolean printZeros, boolean printTime, boolean smoothKhist, boolean smoothPeaks)

private void makeSketch()

private void makeKhistAndPeaks()

</class KmerCountExact>
<class KmerCountMulti>
*Counts unique kmers in a file.
*Tracks multiple kmer lengths independently.
*@author Brian Bushnell
*@date December 30, 2016
public class KmerCountMulti

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out=null

*Override input file extension
private String extin=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Number of hash functions to use
int ways=1

boolean showStdev=false

boolean useWavg=false

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout

private final MultiLogLog[] mlogArray

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public KmerCountMulti(String[] args)

*Create read streams and process all data
void process(Timer t)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris)

private void writeOutput0()

private void writeOutput()

</class KmerCountMulti>
<class KmerCoverage>
*@author Brian Bushnell
*@date Oct 11, 2012
public class KmerCoverage

#Fields
public static PrintStream outstream=System.err

public static int HIST_LEN=1 << 14

public static long HIST_LEN_PRINT=HIST_LEN

public static boolean USE_HISTOGRAM=false

public static boolean PRINT_ZERO_COVERAGE=false

public static long[] histogram_total

private static int THREADS=8

private static boolean verbose=false

private static boolean USE_HEADER=false

private static boolean ADD_CARROT=false

private static boolean OUTPUT_ATTACHMENT=true

private static int MIN_MEDIAN=0

private static int MIN_AVERAGE=0

public static int kmersamplerate=1

public static int readsamplerate=1

public static boolean DONT_SAMPLE_OUTPUT=false

public static boolean CANONICAL=true

public static boolean ZERO_BIN=false

public static boolean FIX_SPIKES=true

public static boolean ordered=true

public static boolean overwrite=true

public static boolean append=false

public static boolean prefilter=false

public static AtomicLong peaks=new AtomicLong()

public static AtomicLong spikes=new AtomicLong()

public static AtomicLong flats=new AtomicLong()

public static AtomicLong valleys=new AtomicLong()

public static AtomicLong slopes=new AtomicLong()


#Methods
public static void printTopology()

public static long count(String reads1, String reads2, KCountArray kca, int k, long maxReads, String output, boolean ordered, boolean overwrite, String histFile, long estUnique)

public static long count(String[] list1, String[] list2, KCountArray kca, int k, long maxReads, String output, boolean ordered, boolean overwrite, String histFile, long estUnique)

public static long calcCoverage(ConcurrentReadInputStream cris, KCountArray kca, int k, long maxReads, ConcurrentReadOutputStream ros, String histFile, boolean overwrite, long estUnique)

*Locates and fixes spikes in a coverage profile (potentially) caused by false positives in a bloom filter.
*Theory: If a high-count kmer is adjacent on both sides to low-count kmers, it may be a false positive.
*It could either be reduced to the max of the two flanking points or examined in more detail.
*@param array An array of kmer counts for adjacent kmers in a read.
private static void fixSpikes(int[] array)

private static void fixSpikes(int[] array, long[] kmers, KCountArray kca, int k)

private static void analyzeSpikes(int[] array, int width)

public static int[] generateCoverage(Read r, KCountArray kca, int k)

public static int[] generateCoverageLong(Read r, KCountArray kca, int k)

</class KmerCoverage>
<class KmerFilterSetMaker>
*@author Brian Bushnell
*@date Nov 22, 2013
public class KmerFilterSetMaker

#Fields
private ArrayList<String> tableArgs=new ArrayList<String>()

private long basesIn=0

private long readsIn=0

private long kmersIn=0

private long kmersOut=0

private long numPasses

private long initialSetSize=0

private int maxPasses=3000

private int minCount=1

private int minKmersPerIteration=1

private int maxKmersPerIteration=2

private int maxNs=Integer.MAX_VALUE

private int minLen=1

*Kmer count output file
private String kmerOutFile=null

private String inFile=null

private String initialKmerFile=null

private String outTemp=null

private String tempKmerFile=makeTempFile("ktemp",".fa")

private boolean errorState=false

final int k

*Print messages to this stream
private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=false

*Verbose messages
public static final boolean verbose=false

*Number of ProcessThreads
public static int THREADS=Shared.threads()


#Methods
*Constructor.
*@param args Command line arguments
public KmerFilterSetMaker(String[] args)

public void process(Timer t)

public void process2()

int runAllPasses(String initialInputFile, String tempPattern)

int runOnePass(String inFile, String outFile, String kmerFile, int lastMaxSeen, int pass)

private String makeTempFile(String prefix, String ext)

</class KmerFilterSetMaker>
<class KmerNormalize>
*AKA BBNorm.
*Normalize depth by downsampling reads with high coverage.
*Uses atomic arrays for bloom filter and an atomic histogram.
*Succeeds KmerDownsampleAH.
*Includes fast error correction and keep-count-based (rather than random) normalization.
*@author Brian Bushnell
*@date May 30, 2013
public class KmerNormalize

#Fields
public static PrintStream outstream=System.err

private static long minHeight=2

private static long minVolume=5

private static int minWidth=3

private static int minPeak=2

private static int maxPeak=Integer.MAX_VALUE

private static int maxPeakCount=10

private static int ploidy=-1

private static boolean doLogScale=false

private static double logWidth=0.05

public static int THREAD_HIST_LEN=1 << 12

public static int HIST_LEN=1 << 20

public static long HIST_LEN_PRINT=HIST_LEN

public static long HIST_COLUMNS=3

public static boolean USE_KHISTOGRAM=false

public static boolean USE_RHISTOGRAM=false

public static boolean PRINT_ZERO_COVERAGE=false

public static AtomicLongArray khistogram

public static AtomicLongArray rhistogram

public static AtomicLongArray bhistogram

public static long[] qhist_total

private static int THREADS=Shared.threads()

private static boolean verbose=false

private static boolean errorState=false

private static boolean EA=Shared.EA()

private static boolean eccByOverlap=false

private static boolean eccByOverlapAuto=false

*High-depth reads will be downsampled to this level in the current pass
private static int TARGET_DEPTH=100

*Error-containing reads will be downsampled to at least this level in the current pass
private static int TARGET_DEPTH_BAD_LOW=100

*Error-containing reads will be downsampled to at most this level in the current pass
private static int TARGET_DEPTH_BAD_HIGH=100

*High-depth reads will be downsampled to this level in the final pass
private static int TARGET_DEPTH_F=100

*High-depth reads will be downsampled to this level in the first pass
private static int TARGET_DEPTH_1=-1

*Reads under this depth will not be downsampled
private static int MAX_DEPTH=-1

*Reads under this depth will be discarded, and kmers under this depth will be ignored
private static int MIN_DEPTH=5

*Reads without this many kmers of at least min depth will be discarded
private static int MIN_KMERS_OVER_MIN_DEPTH=15

*Position in sorted kmer depths array to use as proxy for overall read depth
private static float DEPTH_PERCENTILE=0.54f

*Normalize based on depth of read with lower depth, instead of read with higher depth
public static boolean USE_LOWER_DEPTH=true

*Throw out reads with depth at absolute depth percentile below mindepth
public static boolean TOSS_BY_LOW_TRUEDEPTH=true

*Throw out reads containing errors in the current pass
public static boolean TOSS_ERROR_READS=false

*Throw out reads containing errors in the final pass
public static boolean TOSS_ERROR_READS_F=false

*Throw out reads containing errors in the first pass
public static boolean TOSS_ERROR_READS_1=false

*Only downsample error reads on current pass (keep all error-free reads)
public static boolean DISCARD_BAD_ONLY=false

*Only downsample error reads on first pass (keep all error-free reads)
public static boolean DISCARD_BAD_ONLY_F=false

*Only downsample error reads on final pass (keep all error-free reads)
public static boolean DISCARD_BAD_ONLY_1=false

*Require both reads in a pair to be bad before tossing the read
public static boolean REQUIRE_BOTH_BAD=false

*Don't toss error reads with depth below max
public static boolean SAVE_RARE_READS=false

*Position in sorted kmer depths array to use as proxy for high depth kmer
public static float HIGH_PERCENTILE=0.90f

*Position in sorted kmer depths array to use as proxy for low depth kmer
public static float LOW_PERCENTILE=0.25f

*Position in sorted kmer depths array to use as proxy for low depth kmer, during countup presort pass
public static float LOW_PERCENTILE_COUNTUP=0.20f

*Set to true to keep error reads during countup presort pass
public static boolean ADD_BAD_READS_COUNTUP=false

*Reads with a high/low ratio of at least this are considered error reads.
public static int ERROR_DETECT_RATIO=125

*Threshold for high kmer in detection. A high kmer at this or above is considered possibly non-error.
public static int HTHRESH=12

*Threshold for low kmer in detection. Kmers at this and below are always considered errors.
public static int LTHRESH=3

*Reads with a high/low ratio of at least this are considered error reads.
public static int ERROR_CORRECT_RATIO=140

*Threshold for high kmer in correction. A high kmer at this or above considered possibly non-error.
public static int EC_HTHRESH=22

*Threshold for low kmer in correction. Kmers at this and below are considered errors if an adjacent kmer is at or above the high thresh.
public static int EC_LTHRESH=2

public static double TARGET_BAD_PERCENT_LOW=0.85

public static double TARGET_BAD_PERCENT_HIGH=1.5

private static long FILTERBYTES=-1

private static int SUFFIX_LEN=3

private static int PREFIX_LEN=3

private static boolean TRIM_LEFT_THIS_PASS=false

private static boolean TRIM_RIGHT_THIS_PASS=false

private static boolean RENAME_THIS_PASS=false

private static boolean CORRECT_ERRORS_THIS_PASS=false

private static boolean MARK_ERRORS_ONLY=false

private static boolean TRIM_AFTER_MARKING=false

private static boolean TRIM_EVEN_IF_NO_ERRORS_DETECTED=true

private static boolean MARK_WITH_1=false

private static boolean MARK_UNCORRECTABLE_ERRORS=false

private static boolean USE_ECC1=false

private static boolean USE_ECCF=false

private static boolean CORRECT_FROM_LEFT=true

private static boolean CORRECT_FROM_RIGHT=true

private static double prefilterFraction=0.35

private static int LOW_BIN_DEPTH=10

private static int HIGH_BIN_DEPTH=80

*ECC_LIMIT
private static int MAX_ERRORS_TO_CORRECT=3

private static int MAX_QUAL_TO_CORRECT=127

public static boolean IGNORE_DUPLICATE_KMERS_COUNTUP=true

public static boolean CANONICAL=true

public static boolean ZERO_BIN=false

public static boolean FIX_SPIKES=false

public static boolean KEEP_ALL=false

public static boolean ordered=false

public static boolean overwrite=true

public static boolean append=false

public static boolean prefilter=false

public static boolean renameReads=false

public static boolean DETERMINISTIC=true

public static boolean COUNTUP=false

public static boolean ANALYZE_TOPOLOGY=false

*Quality-trim left side of reads before further processing.
public static boolean TRIM_LEFT=false

*Quality-trim right side of reads before further processing.
public static boolean TRIM_RIGHT=false

public static int MIN_LENGTH=1

*Trim until 2 consecutive bases are encountered with at least this quality.
public static float TRIM_QUALITY=5

*Error rate for trimming (derived from trimq)
private static float trimE

public static boolean REMOVE_TEMP_FILES=true

public static boolean USE_TMPDIR=true

public static String TMPDIR=Shared.tmpdir()

private static HashSet<String> temp_file_set=null

public static AtomicLong peaks=new AtomicLong()

public static AtomicLong spikes=new AtomicLong()

public static AtomicLong flats=new AtomicLong()

public static AtomicLong valleys=new AtomicLong()

public static AtomicLong slopes=new AtomicLong()

public static final byte FIXED_N_QUAL=20


#Methods
public static void main(String[] args)

private static String getTempPrefix(String inFname, String outFname, int pass, int pairnum)

private static String getTempOut(String outFname, String tempOutPrefix)

public static String getSalt(String fname, int attempt)

private static boolean inMemorySort(ArrayList<Read> reads, String sorted, boolean reverse)

private static long runPass(boolean auto, long memory, int cbits, long cells, int pcbits, long precells, int buildpasses, int hashes, int prehashes, int k, long maxReads, long tablereads, int minq, int buildStepsize, String in1, String in2, String outKeep1, String outToss1, String outLow1, String outMid1, String outHigh1, String outUnc1, String outKeep2, String outToss2, String outLow2, String outMid2, String outHigh2, String outUnc2, String khistFile, String rhistFile, String peakFile, List<String> extra, int targetDepth, int targetDepthBadLow, int targetDepthBadHigh, int maxDepth, int minDepth, int minKmersOverMinDepth, float depthPercentile, boolean tossErrorReads, boolean rbb, boolean discardBadOnly, float highPercentile, float lowPercentile, int errorDetectRatio, int hthresh, int lthresh, boolean fixSpikes, boolean countup, boolean rename)

public static void printTopology()

public static long count(String in1, String in2, KCountArray kca, int k, long maxReads, String outKeep1, String outToss1, String outLow1, String outMid1, String outHigh1, String outUnc1, String outKeep2, String outToss2, String outLow2, String outMid2, String outHigh2, String outUnc2, boolean ordered, boolean overwrite, String khistFile, String rhistFile, String peakFile, long estUnique, ArrayList<Read> storage)

public static long count(String[] list1, String[] list2, KCountArray kca, int k, long maxReads, String outKeep1, String outToss1, String outLow1, String outMid1, String outHigh1, String outUnc1, String outKeep2, String outToss2, String outLow2, String outMid2, String outHigh2, String outUnc2, boolean ordered, boolean overwrite, String khistFile, String rhistFile, String peakFile, long estUnique, ArrayList<Read> storage)

public static long downsample(ConcurrentReadInputStream cris, KCountArray kca, int k, long maxReads, ConcurrentReadOutputStream rosKeep, ConcurrentReadOutputStream rosToss, ConcurrentReadOutputStream rosLow, ConcurrentReadOutputStream rosMid, ConcurrentReadOutputStream rosHigh, ConcurrentReadOutputStream rosUnc, String khistFile, String rhistFile, String peakFile, boolean overwrite, long estUnique, ArrayList<Read> storage)

*Locates and fixes spikes in a coverage profile (potentially) caused by false positives in a bloom filter.
*Theory: If a high-count kmer is adjacent on both sides to low-count kmers, it may be a false positive.
*It could either be reduced to the max of the two flanking points or examined in more detail.
*@param cov An array of kmer counts for adjacent kmers in a read.
private static void fixSpikes(int[] cov)

private static void fixSpikes(int[] cov, long[] kmers, KCountArray kca, int k)

private static int correctErrors(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int high, int mult, int maxToCorrect, int maxQual, boolean kmersAlreadyValid, boolean coverageAlreadyValid, long[] qhist, boolean markOnly, Kmer longkmer)

private static int markErrors(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int high, int mult, int maxToCorrect, boolean kmersAlreadyValid, boolean coverageAlreadyValid, long[] qhist, Kmer longkmer)

*Returns number of discontinuities detected. This is not the same as the number of errors,
*but the presence of discontinuities indicates the presence of errors.
*@param cov
*@param low
*@param high
*@param mult
*@return
private static int countDiscontinuities(int[] cov, int low, int high, int mult)

private static void regenerateKmersAndCoverage(Read r, long[] kmers, int[] cov, KCountArray kca, int k, boolean makeCanonical, Kmer longkmer)

private static int correctErrorsFromLeft(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int high, int mult, int maxToCorrect, int maxQual, byte[] suffix, long[] qhist, boolean markOnly, Kmer longkmer)

private static int correctErrorsFromRight(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int high, int mult, int maxToCorrect, int maxQual, byte[] suffix, long[] qhist, boolean markOnly, Kmer longkmer)

private static int markErrorsFromLeft(Read r, int[] cov, int k, int low, int high, int mult, int maxToCorrect, long[] qhist)

private static int markErrorsFromRight(Read r, int[] cov, int k, int low, int high, int mult, int maxToCorrect, long[] qhist)

private static boolean correctErrorFromLeft(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int targetLowerBound, int targetUpperBound, int mult, int loc, byte[] suffix)

private static boolean correctErrorFromRight(Read r, int[] cov, long[] kmers, KCountArray kca, int k, int low, int targetLowerBound, int targetUpperBound, int mult, int loc, byte[] suffix)

private static int testRightSuffix(KCountArray kca, int k, long kmer0, byte[] suffix)

private static int testLeftSuffix(KCountArray kca, int k, long kmer0, byte[] suffix)

private static void analyzeSpikes(int[] array, int width)

*kmer array must be valid at this point
*@param r
*@param kca
*@param k
*@param out
*@param kmers
*@return Array of coverage per kmer
public static int[] generateCoverage(Read r, KCountArray kca, int k, int[] out, long[] kmers)

*kmer array must be valid at this point
*@param kca
*@param k
*@param out
*@param kmers
*@param makeCanonical
*@return Array of coverage per kmer
public static int[] generateCoverage(KCountArray kca, int k, int[] out, long[] kmers, boolean makeCanonical)

*Returns {depth1, depth2, errors1, errors2}
public static int[] parseDepth(String s, int[] array)

public static boolean errorState()

public static boolean setErrorState(boolean b)

public static boolean useTmpdir()

</class KmerNormalize>
<class KmerSample>
*@author Brian Bushnell
*@date Oct 10, 2012
public class KmerSample

#Methods
public static int[] makeKmerSet(int K, String filename)

public static boolean containsKmer(long kmer, int[] array)

</class KmerSample>
<class MakeLengthHistogram>
*@author Brian Bushnell
*@date Jul 16, 2012
public class MakeLengthHistogram

#Fields
public static long maxReads=-1

public static long readsProcessed=0

public static long basesProcessed=0

public static int MAX_LENGTH=80000

public static int MULT=10

public static boolean ROUND_BINS=false

public static boolean NON_ZERO_ONLY=true

static PrintStream outstream=System.err

public static boolean append=false

public static boolean overwrite=true

public static boolean verbose=false


#Methods
public static void calc(String in1, String in2, String out)

</class MakeLengthHistogram>
<class MakePolymers>
*@author Brian Bushnell
*@date Oct 17, 2014
public class MakePolymers

#Fields
private long readsProcessed=0

private long basesProcessed=0

private int mink=1

private int maxk=1

private int minLen=31

private String out1=null

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public MakePolymers(String[] args)

void process(Timer t)

private void writeSequence(int k, ByteStreamWriter bsw)

public static final void toBytes(long kmer, int k, ByteBuilder bb)

</class MakePolymers>
<class MergeBarcodes>
*@author Brian Bushnell
*@date Sep 11, 2012
public class MergeBarcodes

#Fields
private String inbar=null

private String in1=null

private String in2=null

private String qfin2=null

private String out1=null

private String out2=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

private boolean reverseComplementMate=false

private boolean reverseComplement=false

*Add /1 and /2 to read names
private boolean addslash=false

*Add 1: and 2: to read names
private boolean addcolon=false

private long maxReads=-1

private final FileFormat ffbar

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public MergeBarcodes(String[] args)

public HashMap<String,Read> loadBarcodes()

public static HashMap<String,Read> loadBarcodes(PrintStream outstream, FileFormat ffbar, long maxReads)

void mergeWithMap(Timer t, HashMap<String,Read> map)

</class MergeBarcodes>
<class MergeSam>
*@author Brian Bushnell
*@date March 8, 2017
public class MergeSam

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out="stdout.sam"

private String outInvalid=null

private long linesProcessed=0

private long linesValid=0

private long bytesProcessed=0

private long maxLines=Long.MAX_VALUE

private final FileFormat[] ffin

private final FileFormat ffout

private final FileFormat ffoutInvalid

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public MergeSam(String[] args)

</class MergeSam>
<class Orf>
*This class is designed to help calculate coverage of ORFs
*@author Brian Bushnell
*@date May 13, 2013
public class Orf

#Fields
*Name of ORF (not necessarily the name of its scaffold)
public String name

public int start

public int stop

public byte strand

*Number of bases with nonzero coverage
public long baseCoverage

*Number of reads mapped to this orf
public long readDepth=0

*Number of bases mapped to this orf
public long baseDepth=0

*Lowest base depth
public long minDepth=0

*Highest base depth
public long maxDepth=0

*Median base depth
public long medianDepth=0

*Standard deviation of depth
public double stdevDepth=0


#Methods
public Orf(String name_, int start_, int stop_, byte strand_)

@Override public String toString()

public int length()

public double avgCoverage()

public double fractionCovered()

public int[] readCoverageArray(CoverageArray ca)

@Override public int compareTo(Orf o)

@Override public boolean equals(Object o)

public boolean equals(Orf o)

@Override public int hashCode()

</class Orf>
<class PartitionReads>
*@author Brian Bushnell
*@date June 1, 2016
public class PartitionReads

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String[] qfout1Array=null

private String[] qfout2Array=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Split data into this many output files
private int ways=-1

*Keep PacBio subreads together in the same file
private boolean pacBioMode=false

*Optimize for similar numbers of bp instead of sequences
private boolean splitByBP=false

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat[] ffout1

*Secondary output file
private final FileFormat[] ffout2

private boolean useSharedHeader=false

*Print status messages to this output stream
private PrintStream outstream=System.err

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public PartitionReads(String[] args)

*Create read streams and process all data
void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Iterate through the reads; outputs data trying to keep an equal number of bp per file.
void processInner_heap(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

</class PartitionReads>
<class PhylipToFasta>
*@author Brian Bushnell
*@date Oct 3, 2014
public class PhylipToFasta

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public PhylipToFasta(String[] args)

void process(Timer t)

</class PhylipToFasta>
<class PickSubset>
*Select a maximally diverse subset from an all-to-all ANI comparison,
*by removing a node with the highest pairwise ANI until the
*desired number of nodes remain, or the desired ANI threshold
*is reached.
*Unlike RepresentativeSet, it does not use taxonomy or centroids.
*@author Brian Bushnell
*@date July 30, 2024
public class PickSubset

#Fields
private HashMap<String,Node> nodeMap=new HashMap<String,Node>()

private LineParser1 lp=new LineParser1('\t')

*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Junk output file path
private String outInvalid=null

private int desiredNodes=0

private float desiredANI=0

private long edgesProcessed=0

private long nodesProcessed=0

private long edgesOut=0

private long nodesOut=0

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Output File
private final FileFormat ffout1

*Optional Output File for Junk
private final FileFormat ffoutInvalid

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public PickSubset(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create streams and process all data
void process(Timer t)

private ArrayList<Edge> readFile(ByteFile bf)

ArrayList<Node> pickNodes(ArrayList<Edge> list, int desiredNodes)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class PickSubset>
<class ReadKmerDepthDistribution>
*This class is designed to visualize the distribution of kmer depths across individual reads.
*@author Brian Bushnell
*@date May 15, 2013
public class ReadKmerDepthDistribution

#Fields
public static PrintStream outstream=System.err

public static int THREAD_HIST_LEN=1 << 12

public static int HIST_LEN=1 << 20

public static long HIST_LEN_PRINT=HIST_LEN

public static boolean USE_HISTOGRAM=false

public static boolean PRINT_ZERO_COVERAGE=false

public static AtomicLongArray histogram_total

private static int THREADS=8

private static boolean verbose=false

private static int TARGET_DEPTH=50

private static int MAX_DEPTH=-1

private static int MIN_DEPTH=3

private static int MIN_KMERS_OVER_MIN_DEPTH=10

private static float DEPTH_PERCENTILE=0.5f

public static boolean CANONICAL=true

public static boolean ZERO_BIN=false

public static boolean FIX_SPIKES=true

public static boolean ordered=false

public static boolean overwrite=true

public static boolean append=false

public static boolean prefilter=false

public static AtomicLong peaks=new AtomicLong()

public static AtomicLong spikes=new AtomicLong()

public static AtomicLong flats=new AtomicLong()

public static AtomicLong valleys=new AtomicLong()

public static AtomicLong slopes=new AtomicLong()


#Methods
public static void printTopology()

public static long count(String in1, String in2, KCountArray kca, int k, long maxReads, String outKeep, boolean overwrite, String histFile, long estUnique)

public static long downsample(ConcurrentReadInputStream cris, KCountArray kca, int k, long maxReads, ConcurrentReadOutputStream rosKeep, String histFile, boolean overwrite, long estUnique)

*Locates and fixes spikes in a coverage profile (potentially) caused by false positives in a bloom filter.
*Theory: If a high-count kmer is adjacent on both sides to low-count kmers, it may be a false positive.
*It could either be reduced to the max of the two flanking points or examined in more detail.
*@param array An array of kmer counts for adjacent kmers in a read.
private static void fixSpikes(int[] array)

private static void fixSpikes(int[] array, long[] kmers, KCountArray kca, int k)

private static void analyzeSpikes(int[] array, int width)

public static int[] generateCoverage(Read r, KCountArray kca, int k, int[] out, long[] kmers)

public static int[] generateCoverageLong(Read r, KCountArray kca, int k, int[] out)

</class ReadKmerDepthDistribution>
<class RedirectTest>
*@author Brian Bushnell
*@date Jan 22, 2013
public class RedirectTest

#Methods
public static void main_0(String[] args)

</class RedirectTest>
<class ReformatReads>
*@author Brian Bushnell
*@date Sep 11, 2012
public class ReformatReads

#Fields
*For converting headers to filesystem-valid Strings
private static final byte[] headerSymbols=new byte[128]

private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String outsingle=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

private String ref=null

public long readsProcessed=0

public long basesProcessed=0

public long kmersProcessed=0

public double correctKmers=0

public long readsOut1=0

public long readsOut2=0

public long readsOutSingle=0

public long basesOut1=0

public long basesOut2=0

public long basesOutSingle=0

*For calculating kmer cardinality
private final CardinalityTracker loglog

private int k=0

*Tracks names to ensure no duplicate names.
private final HashMap<String,Integer> nameMap1

*Tracks names to ensure no duplicate names.
private final HashMap<String,Integer> nameMap2

private boolean uniqueNames=false

private boolean reverseComplementMate=false

private boolean reverseComplement=false

private boolean complement=false

private boolean verifyinterleaving=false

private boolean verifypairing=false

private boolean allowIdenticalPairNames=true

private boolean trimBadSequence=false

private boolean chastityFilter=false

*Crash if a barcode is encountered that contains Ns or is not in the table
private final boolean failBadBarcodes

*Remove reads with Ns in barcodes or that are not in the table
private final boolean removeBadBarcodes

*Fail reads missing a barcode
private final boolean failIfNoBarcode

*A set of valid barcodes; null if unused
private final HashSet<String> barcodes

private boolean deleteEmptyFiles=false

private boolean mappedOnly=false

private boolean pairedOnly=false

private boolean unpairedOnly=false

private boolean unmappedOnly=false

private boolean primaryOnly=false

*For sam file filtering: These bits must be set.
private int requiredBits=0

*For sam file filtering: These bits must be unset
private int filterBits=0

*Add /1 and /2 to read names
private boolean addslash=false

*Add 1: and 2: to read names
private boolean addcolon=false

*Change read name whitespace to underscores
private boolean addunderscore=false

private boolean stoptag=false

private boolean iupacToN=false

boolean bottom=true

boolean top=true

private float minIdFilter=-1

private float maxIdFilter=-1

private int subfilter=-1

private int minsubs=-1

private int clipfilter=-1

private int delfilter=-1

private int insfilter=-1

private int indelfilter=-1

private int dellenfilter=-1

private int inslenfilter=-1

private int editfilter=-1

private int minMapq=-1

private int maxMapq=-1

boolean USE_EDIT_FILTER=false

private long maxReads=-1

private long skipreads=-1

private float samplerate=1f

private long sampleseed=-1

private boolean sampleReadsExact=false

private boolean sampleBasesExact=false

private boolean allowUpsample=false

private boolean prioritizeLength=false

private long sampleReadsTarget=0

private long sampleBasesTarget=0

*Recalibrate quality scores using matrices
private boolean recalibrateQuality=false

private boolean qtrimRight=false

private boolean qtrimLeft=false

private final int forceTrimLeft

private final int forceTrimRight

private final int forceTrimRight2

*Trim right bases of the read modulo this value.
*e.g. forceTrimModulo=50 would trim the last 3bp from a 153bp read.
private final int forceTrimModulo

private float trimq=6

*Error rate for trimming (derived from trimq)
private final float trimE

private float minAvgQuality=0

private int minAvgQualityBases=0

private int maxNs=-1

private int minConsecutiveBases=0

private int breakLength=0

private int maxReadLength=0

private int minReadLength=0

private float minLenFraction=0

private float minGC=0

private float maxGC=1

private boolean filterGC=false

*Average GC for paired reads.
private boolean usePairGC

private boolean tossJunk=false

*Toss pair only if both reads are shorter than limit
private boolean requireBothBad=false

*Invert filters.
private boolean invertFilters

*Replace problematic symbols in read headers.
private boolean fixHeaders

*Change the last underscore to a space, to fix UCSF headers
private boolean lastUnderscoreToSpace=false

private boolean useSharedHeader

private byte[] remap1=null

private byte[] remap2=null

private boolean quantizeQuality=false

private boolean fixCigar=false

private final boolean pad

private byte padSymbol='N'

private byte padQ=0

private int padLeft=0

private int padRight=0

*Parse headers for this tag, like "count="
private String tag

*Use this delimiter when parsing the header
private char delimiter=0

private String delimiterS=null

*Min value for numeric terms
private float minValue=Float.MIN_VALUE

*Max value for numeric terms
private float maxValue=Float.MAX_VALUE

*A specific String value for terms
private String requiredValue=null

ReadHeaderParser rhp=new IlluminaHeaderParser2()

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private final FileFormat ffoutsingle

private final boolean qtrim

private static String slash1=" /1"

private static String slash2=" /2"

private static final String colon1=" 1:"

private static final String colon2=" 2:"

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean silent=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean testsize=false

private boolean deleteInput=false

private Random randy


#Methods
public ReformatReads(String[] args)

void process(Timer t)

private void pad(Read r)

public static final void pad(Read r, int padLeft, int padRight, byte padSymbol, byte padQ)

private static final byte[] pad(byte[] old, int padLeft, int padRight, byte padSymbol)

public static final boolean passesIDFilter(Read r, float minId, float maxId, boolean requireMapped)

public static final boolean passesMinIDFilter(Read r, float minId, boolean requireMapped)

public static final boolean passesMaxIDFilter(Read r, float maxId)

public final boolean passesEditFilter(Read r, boolean requireMapped)

public boolean passesTagFilter(String s, String tag, char delimiter)

private void deleteEmpty(long readsOut1, long readsOut2, long readsOutSingle)

private static void deleteEmpty(long count, FileFormat ff, String qf)

private long[] countReads(long maxReads)

private SuperLongList makeLengthHist(long maxReads)

public void setSampleSeed(long seed)

public static final void underscoreToSpace(Read r)

public static String underscoreToSpace(String header)

public static final void fixHeader(Read r)

public static final String fixHeader(String header)

</class ReformatReads>
<class RefRenamer>
*Converts reference sequence names in SAM files.
*Updates both @SQ header lines and RNAME/RNEXT fields in alignment records.
*@author Brian Bushnell
*@author Isla
*@date July 8, 2025
public class RefRenamer

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Reference mapping file path
private String mappingFile=null

*Crash on unknown references
private boolean strict=false

*Flip the order of the map file names
private boolean invert=false

private final HashMap<String,String> refMap=new HashMap<String,String>()

private final HashSet<String> unknownRefs=new HashSet<String>()

private long linesProcessed=0

private long bytesProcessed=0

private long headersProcessed=0

private long unknownsProcessed=0

private long headersConverted=0

private long recordsConverted=0

private long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Output File
private final FileFormat ffout1

*Mapping File
private final FileFormat ffMapping

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public RefRenamer(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Load the reference name mapping from TSV file
private void loadMapping()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create streams and process all data
void process(Timer t)

*Process the input file line by line, converting reference names based on file type.
*Automatically detects FASTA vs SAM format and processes accordingly.
*@param bf Input ByteFile to read from
*@param bsw Output ByteStreamWriter to write to
private void processInner(ByteFile bf, ByteStreamWriter bsw)

*Process a SAM header line, converting @SQ reference names if mappings exist.
*Other header lines pass through unchanged.
*@param line Raw header line bytes
*@param bb ByteBuilder for output construction
*@param lp LineParser for field parsing
private void processSamHeaderLine(byte[] line, ByteBuilder bb, LineParser1 lp)

*Process a SAM alignment line, converting RNAME and RNEXT fields if mappings exist.
*Maintains all other fields unchanged while tracking conversion statistics.
*@param line Raw alignment line bytes
*@param bb ByteBuilder for output construction
*@param lp LineParser for field parsing
private void processAlignmentLine(byte[] line, ByteBuilder bb, LineParser1 lp)

*Process a FASTA header line, converting reference names while preserving descriptions.
*Handles both full header replacement and partial replacement with whitespace.
*Sequence lines pass through unchanged.
*@param line Raw FASTA line bytes
*@param bb ByteBuilder for output construction
*@return Updated ByteBuilder with processed line
private ByteBuilder processFastaLine(byte[] line, ByteBuilder bb)

*Process a VCF line, converting chromosome names in headers and data records.
*Handles ##contig header lines and CHROM field in variant records.
*@param line Raw VCF line bytes
*@param bb ByteBuilder for output construction
*@param lp LineParser for field parsing
*@return Updated ByteBuilder with processed line
private ByteBuilder processVcfLine(byte[] line, ByteBuilder bb, LineParser1 lp)

*Process a GFF line, converting sequence names in annotation records.
*Comment lines and headers pass through unchanged.
*Converts the seqname field (field 0) in feature records.
*@param line Raw GFF line bytes
*@param bb ByteBuilder for output construction
*@param lp LineParser for field parsing
*@return Updated ByteBuilder with processed line
private ByteBuilder processGffLine(byte[] line, ByteBuilder bb, LineParser1 lp)

*Handle unknown reference names by tracking them and optionally warning or crashing.
*Each unknown reference is only reported once to avoid spam.
*@param ref Unknown reference name encountered
private void handleUnknownRef(String ref)

*Create a ByteStreamWriter for the specified FileFormat.
*@param ff FileFormat to create writer for
*@return ByteStreamWriter or null if ff is null
private static ByteStreamWriter makeBSW(FileFormat ff)

</class RefRenamer>
<class RemapQuality>
*Changes quality scores to other quality scores.
*@author Brian Bushnell
*@date Apr 27, 2015
public class RemapQuality

#Fields
public String mapString

public final byte[] map


#Methods
*Code entrance from the command line.
*Must be overridden; the commented body is an example.
*@param args Command line arguments
public static void main(String[] args)

@Override protected void setDefaults()

*@param args
public RemapQuality(String[] args)

@Override public boolean parseArgument(String arg, String a, String b)

@Override protected void startupSubclass()

@Override protected void shutdownSubclass()

@Override protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

@Override protected final boolean useSharedHeader()

@Override protected boolean processReadPair(Read r1, Read r2)

</class RemapQuality>
<class RemoveBadBarcodes>
*@author Brian Bushnell
*@date Mar 16, 2015
public class RemoveBadBarcodes

#Fields
long good=0

long bad=0

long noBarcode=0


#Methods
*@param args
public RemoveBadBarcodes(String[] args)

@Override protected void setDefaults()

@Override public boolean parseArgument(String arg, String a, String b)

@Override protected boolean processReadPair(Read r1, Read r2)

@Override protected void startupSubclass()

@Override protected void shutdownSubclass()

@Override protected final boolean useSharedHeader()

@Override protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

</class RemoveBadBarcodes>
<class RenameReads>
*@author Brian Bushnell
*@date Aug 23, 2013
public class RenameReads

#Fields
private PrintStream outstream=System.err

private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

private String prefix=null

private String suffix=null

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private boolean overwrite=true

private boolean append=false

private boolean verbose=false

private long maxReads=-1

public boolean errorState=false

public int trimBeforeSymbol=0

public char symbol

public int trimRight=0

public int trimLeft=0

public boolean addUnderscore=true

public boolean renameByMapping=false

public boolean renameByInsert=false

public boolean renameByTrim=false

public boolean renameByCoords=false

public boolean addPrefix=false

public boolean prefixOnly=false

public boolean fixSRA=false

public boolean addPairnum=true

public boolean quantizeQuality=false

private String[] pairnums={" 1:"," 2:"}

private static final Pattern spacePattern=Pattern.compile("\\s+")

private static final Pattern whitespacePattern=Pattern.compile(" ")


#Methods
public static void main(String[] args)

public RenameReads(String[] args)

void process(Timer t)

private void fixSRA(Read r)

private static String trim(String s, int left, int right)

private static String trimBeforeSymbol(String s, int right, char symbol)

</class RenameReads>
<class ReplaceHeaders>
*Replaces read headers with other headers.
*@author Brian Bushnell
*@date May 23, 2016
public class ReplaceHeaders

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary header input file path
private String hin1=null

*Secondary header input file path
private String hin2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Override output file extension
private String extout=null

*Prepend the new name to the old name
private boolean prefix=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary header input file
private final FileFormat ffhin1

*Secondary header input file
private final FileFormat ffhin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public ReplaceHeaders(String[] args)

*Create read streams and process all data
void process(Timer t)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadInputStream hcris, ConcurrentReadOutputStream ros)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2, Read h1, Read h2)

</class ReplaceHeaders>
<class RepresentativeSet>
*From a 3+ column text file of {node 1, node 2, dist, optionally sizeratio and others},
*makes a minimal representative set by retaining nodes
*such that all original nodes are within a minimum distance
*of at least one representative node.
*Singleton nodes will only be included if they are
*represented by a self-edge.
*@author Brian Bushnell
*@date October 26, 2017
public class RepresentativeSet

#Fields
private String in1=null

private String out1=null

private String outInvalid=null

private long nodesProcessed=0

private long nodesValid=0

private long sizeValid=0

private long basesValid=0

private long linesProcessed=0

private long bytesProcessed=0

private long sizeProcessed=0

private long basesProcessed=0

private long nodesIgnored=0

private long sizeIgnored=0

private long basesIgnored=0

private long maxLines=Long.MAX_VALUE

private double threshold=0

private double minRatio=0

*Ignore nodes over this estimated size in unique kmers
private long maxSize=-1

*Ignore nodes under this estimated size in unique kmers
private long minSize=0

*Ignore nodes over this estimated size in total bp
private long maxBases=-1

*Ignore nodes under this estimated size in total bp
private long minBases=0

boolean invertRatio=false

boolean printSize=true

boolean printHeader=true

boolean printClusters=true

private TaxFilter filter

private final FileFormat ffin1

private final FileFormat ffout1

private final FileFormat ffoutInvalid

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public RepresentativeSet(String[] args)

void process(Timer t)

private HashMap<Long,Node> load()

private void printResults(Timer t)

</class RepresentativeSet>
<class RQCFilter2>
*Wrapper for several other programs to implement Rolling QC's filter stage.
*Calls SendSketch, Clumpify, KmerCountExact, BBNorm, BBDuk, BBMap, BBMerge, and SplitNexteraLMP.
*Trims adapters, removes contaminants, and does quality-trimming.
*@author Brian Bushnell
*@date Nov 26, 2013
public class RQCFilter2

#Fields
*Screen output
private static PrintStream outstream=System.err

*Synthetic contaminant filtering
private final boolean doFilter

*Forcibly override synthetic contaminant filtering
private boolean skipFilter=false

*Spikein filtering
private final boolean doSpikein

*Clumpify
private boolean doClump=false

*QScore recalibration
private boolean recalibrate=true

*QScore quantizer
private String quantize="2"

*FilterByTile
private boolean doFilterByTile=true

*Polyfilter
private String polyfilter="GC"

*Adapter-trimming
private final boolean doAdapterTrim

*Run BBMerge for insert size calculation
private final boolean doMerge

*Run KmerNormalize for kmer histogram generation
private boolean doKhist=false

*Do NexteraLMP splitting
private final boolean doNexteraLMP

*Symbols to insert in output filename to denote operations performed
private final String symbols

*Name of raw input file, minus directory and file extension
private final String rawName

*Type of library; controls processing methods and references to use
private int libType=FRAG

*Legacy; affects output file name
private boolean rnaArtifactFlag=false

*Legacy; affects output file name
private boolean dnaArtifactFlag=true

*True if phix should be filtered out
private boolean phixFlag=true

*True if Lambda should be filtered out by kmer-matching
private boolean lambdaFlag=true

*True if pjet should be filtered out
private boolean pjetFlag=true

*True if SIP spikeins should be filtered out
private boolean sipFlag=false

*True if poly-A tails should be right-trimmed
private boolean trimPolyA=false

*True if poly-A should be filtered out
private boolean filterPolyA=false

*Positive if poly-G should be left-trimmed during filter1
public int trimPolyGLeft=6

*Positive if poly-G should be right-trimmed during filter1
public int trimPolyGRight=6

*Positive if poly-G prefixes should be filtered during filter1
public int filterPolyG=0

*True if mtst should be quantified and filtered out
private boolean mtstFlag=false

*True if kapa should be quantified and filtered out
private boolean kapaFlag=true

*Enables tbo during adapter trimming
private boolean tboFlag=true

*Enables tpe during adapter trimming
private boolean tpeFlag=true

*Unused
private String jointSeq=null

*Toss reads shorter than this
private int minLen=25

*Toss reads shorter than this fraction of initial length, after trimming
private float minLenFraction=0.333f

*Trim bases at this quality or below
private float trimq=10

*Throw away reads below this average quality after trimming. Default: 5
private float minAvgQuality=5

*If positive, calculate the average quality from the first X bases.
private int minAvgQualityBases=0

*Trim reads to be equal to 0 modulo this value. Mainly for 151, 251, and 301bp runs.
private int forceTrimModulo=5

*Quality-trimming mode
private String qtrim="f"

*Kmer-trimming mode
private String ktrim="r"

*Kmer length to use for filtering
private int filter_k=31

*Kmer length to use for trimming
private int trim_k=23

*Kmer length to use for normalization and error-correction
private int normalize_k=31

*Kmer length to use for mapping
private int map_k=14

*Shortest kmer to use for trimming
private int mink=11

*Throw away reads containing more than this many Ns. Default: 0 (toss reads with any Ns)
private int maxNs=0

*Use this Hamming distance when kmer filtering
private int hdist_filter=1

*Use this query Hamming distance when kmer filtering
private int qhdist_filter=0

*Use this Hamming distance when kmer trimming
private int hdist_trim=1

*Use this Hamming distance when kmer trimming with short kmers
private int hdist2_trim=-1

*Use this Hamming distance when kmer trimming with short kmers
private int hdist_ribo=0

*Use this Hamming distance when kmer trimming with short kmers
private int edist_ribo=0

*Kmer length to use for filtering spikeins
private int spikein_k=31

*Use this Hamming distance when kmer filtering spikeins
private int hdist_spikein=0

*Force-trim left during filter1 stage
private int ftl=-1

*Force-trim right during filter1 stage
private int ftr=-1

*Force-trim right 2 during filter1 stage
private int ftr2=-1

*Merge strictness: strict, normal, loose, vloose
private String mergeStrictness="loose"

*Trim Truseq and Nextera adapters from right side of reads
private boolean fragAdapterFlag=true

*Trim Truseq-RNA adapters from right side of reads
private boolean rnaAdapterFlag=false

*Trim Swift low-complexity sequence
private boolean swiftFlag=false

*Trim 1bp from right side after adapter-trimming/
private boolean bisulfite=false

*Performed quality-trimming on reads
private boolean qtrimFlag=false

*Performed kmer-trimming on reads
private boolean ktrimFlag=false

*Performed nextera splitting on reads
private boolean splitNexteraFlag=false

*Remove reads mapping to human with high identity
private boolean humanFlag=false

*Remove reads mapping to dog with high identity
private boolean dogFlag=false

*Remove reads mapping to cat with high identity
private boolean catFlag=false

*Remove reads mapping to mouse with high identity
private boolean mouseFlag=false

*Remove mouse, cat, dog, and human reads at the same time with BBSplit.
private boolean mouseCatDogHumanFlag=false

*Perform cat, dog, mouse, and human removal aggressively, using unmasked genomes.
private boolean aggressiveHumanFlag=false

*Report, but do not remove, cat/dog/mouse/human sequence
private boolean keepHumanReads=false

*Perform microbe removal aggressively, using unmasked genomes.
private boolean aggressiveMicrobeFlag=false

*Remove reads from common microbial contaminants with BBMap
private boolean removeCommonMicrobeFlag=false

*Detect but do not remove reads from common microbial contaminants with BBMap
private boolean detectMicrobeFlag=false

*Detect but do not remove reads from other microbial contaminants with BBMap
private boolean otherMicrobeFlag=false

*Screen reads with a Bloom filter prior to mapping
private boolean bloomFilter=true

*Bloom filter kmer length
private int bloomFilterK=29

*Bloom filter hashes per kmer
private int bloomFilterHashes=1

*Min consecutive hits to consider a read as matching
private int bloomFilterMinHits=6

*Don't use Bloom filter for libraries under this size
private long minReadsToBloomFilter=4000000

*Use the serialized Bloom filter
private boolean bloomSerial=true

private boolean trimUntrim=true

*Use BBMerge to determine the adapter sequence, and use that instead of the default adapters
private boolean discoverAdaptersFlag=true

*True if it looks like the discovered adapters are usable
private boolean discoveredAdaptersValid=false

*Extend reads to merge longer inserts
private boolean extendFlag=false

*Set extendFlag based on the number of unique kmers
private boolean extendFlagAuto=true

*Remove ribosomal reads via kmer-matching
private boolean riboKmerFlag=false

*Remove reads from specific ribosomal sequence with BBMap
private boolean riboMapFlag=false

*Remove reads from specific chloroplast sequence with BBMap
private boolean chloroMapFlag=false

*Remove reads from specific mitochondrial sequence with BBMap
private boolean mitoMapFlag=false

*Query the sketch server
private boolean sketchFlag=true

*Use local flag for Silva
private boolean SILVA_LOCAL=true

*Sketch server to query
private String sketchDB="nt,refseq,silva,prokprot"

*Estimate kmer cardinality
private boolean doCardinality=true

private boolean verbose=false

private boolean overwrite=true

private boolean compress=true

private boolean copyUndefined=false

*Write temp files to $TMPDIR (localdisk)
private boolean writeTempToTmpdir=true

*Captures the command line "pigz" flag
private String pigz="t"

*Captures the command line "unpigz" flag
private String unpigz="t"

*Captures the command line "zl" flag
private String zl

*Mode for processing chastity flag in Illumina read names
private String chastityfilter="t"

*Consider the absence of a barcode to mean failure
private String failnobarcode=null

*May be set to true, false, or crash to determine how to handle reads with no barcode
private String barcodefilter="f"

*An optional list of literal barcodes that are allowed
private String barcodes=null

*Arguments to pass to BBDuk
private ArrayList<String> primaryArgList=new ArrayList<String>()

*References to pass to BBDuk for artifact removal
private ArrayList<String> bbdukFilterRefs=new ArrayList<String>()

*References to pass to Seal for spikein removal
private ArrayList<String> spikeinRefs=new ArrayList<String>()

*References to pass to BBMap for contaminant removal
private ArrayList<String> mappingRefs=new ArrayList<String>()

*List of taxa to NOT map against
private String taxList=null

*Taxonomic level for filtering
private String taxLevel="order"

*Only needed if there are gi numbers in the references
private boolean loadGiTable=false

*Number of reads used for SendSketch
private int sketchReads=2000000

private String sketchMinProb="0.2"

private String sketchSamplerate="1.0"

private boolean sketchMerge=true

private boolean entropyFilter=false

private double minEntropy=0.42

private int entropyk=2

private int entropywindow=40

private boolean removeDuplicates=false

private boolean removeAllDuplicates=false

private boolean removeOpticalDuplicates=false

private boolean removeEdgeDuplicates=false

private int duplicatePasses=1

private int duplicateSubs=-1

private int duplicateDist=-1

private boolean lowComplexity=false

private int clumpifyGroups=-1

private boolean clumpifyTmpdir=false

private final String tempSalt

private final String clumpPrefix

private final String recalPrefix

private final String fbtPrefix

private final String trimPrefix

private final String polyPrefix

private final String humanPrefix

private final String spikeinPrefix

private final String filterPrefix1

private final String filterPrefix2

private final String sipPrefix

private final String taxaPrefix

private final String microbePrefix

private final String riboPrefix

private final String chloroPrefix

private final String[] mappingPrefix

*Directory in which to write all files
private String outDir=""

*Directory in which to write all temp files
private String tmpDir=Shared.tmpdir()

*Primary input reads file (required)
private String in1=null

*Secondary input reads file
private String in2=null

*Primary output reads file (required)
private String out1=null

*Secondary output reads file
private String out2=null

private String phixSam=null

private String tiledump=null

private boolean deleteTemp=true

private boolean deterministic=true

private boolean ordered=false

private boolean dryrun=false

private String riboOutFile="ribo.fq.gz"

private String fbtOutFile="filteredByTile.fq.gz"

private String chloroOutFile="chloro.fq.gz"

private String humanOutFile="human.fq.gz"

private String spikeinOutFile="spikein.fq.gz"

private String synthOutFile1="synth1.fq.gz"

private String synthOutFile2="synth2.fq.gz"

private String microbeOutFile="microbes.fq.gz"

private RQCFilterStats filterstats=new RQCFilterStats()

private String logName="status.log"

private String reproduceName="reproduce.sh"

private String fileListName="file-list.txt"

private String rqcStatsName="filterStats.txt"

private String rqcStatsName2="filterStats2.txt"

private String kmerStatsName1="kmerStats1.txt"

private String kmerStatsName2="kmerStats2.txt"

private String scaffoldStatsName1="scaffoldStats1.txt"

private String scaffoldStatsName2="scaffoldStats2.txt"

private String scaffoldStatsNameSpikein="scaffoldStatsSpikein.txt"

private String refStatsName="refStats.txt"

private String microbeStatsFile="commonMicrobes.txt"

private String microbeStats2File="otherMicrobes.txt"

private String adaptersOutFile="adaptersDetected.fa"

private String microbesUsed="microbesUsed.txt"

private String chloroStatsFile="chloroStats.txt"

private String sipStatsFile="sipSpikeinStats.txt"

private String sipScafStats="sipScafStats.txt"

private String nexteraStats="nexteraStats.txt"

private String ihistName="ihist_merge.txt"

private String khistName="khist.txt"

private String peaksName="peaks.txt"

private String phistName="phist.txt"

private String qhistName="qhist.txt"

private String bhistName="bhist.txt"

private String gchistName="gchist.txt"

private String sketchName="sketch.txt"

private String cardinalityName="cardinality.txt"

*ktrim phase rqc stats file
private String rqcStatsName_kt

*ktrim phase stats file
private String kmerStatsName_kt

*ktrim phase scaffold stats file
private String scaffoldStatsName_kt

private String doneFile="RQCFilter_finished.txt"

private String RQCFilterData=getRQCPath()

private String shortArtifactFile="RQCFILTER_PATH/short.fa.gz"

private String mainArtifactFile="RQCFILTER_PATH/Illumina.artifacts.fa.gz"

private String polyAFile="RQCFILTER_PATH/polyA.fa.gz"

private String nexteraLinkerFile="RQCFILTER_PATH/nextera_LMP_linker.fa.gz"

private String phixRef="RQCFILTER_PATH/phix2.fa.gz"

private String lambdaRef="RQCFILTER_PATH/lambda.fa.gz"

private String lfpeLinker="RQCFILTER_PATH/lfpe.linker.fa.gz"

private String clrsLinker="RQCFILTER_PATH/crelox.fa.gz"

private String clipLinker=clipLinkerDefault

private String pjetRef="RQCFILTER_PATH/pJET1.2.fa.gz"

private String riboKmers="RQCFILTER_PATH/riboKmers20fused.fa.gz"

private String fragAdapter="RQCFILTER_PATH/adapters2.fa.gz"

private String rnaAdapter="RQCFILTER_PATH/truseq_rna.fa.gz"

private String mtstRef="RQCFILTER_PATH/mtst.fa.gz"

private String kapaRef="RQCFILTER_PATH/kapatags.L40.fa.gz"

private String humanPath="RQCFILTER_PATH/human_genome/"

private String catPath="RQCFILTER_PATH/cat_genome/"

private String dogPath="RQCFILTER_PATH/dog_genome/"

private String mousePath="RQCFILTER_PATH/mouse_genome/"

private String mouseCatDogHumanPath="RQCFILTER_PATH/mousecatdoghuman/"

private String humanRef=null

private String chloroplastRef="RQCFILTER_PATH/plastid.fa.gz"

private String mitoRef="RQCFILTER_PATH/mitochondrion.fa.gz"

private String chloroMitoRef="RQCFILTER_PATH/chloro_mito.fa.gz"

private String chloroMitoRiboRef="RQCFILTER_PATH/chloro_mito_ribo.fa.gz"

private String mitoRiboRef="RQCFILTER_PATH/mito_ribo.fa.gz"

private String chloroRiboRef="RQCFILTER_PATH/chloro_ribo.fa.gz"

private String riboRef="RQCFILTER_PATH/SSU_LSU_sorted.fa.gz"

private String commonMicrobesPath="RQCFILTER_PATH/commonMicrobes/"

private String commonMicrobesRef="RQCFILTER_PATH/commonMicrobes/fusedERPBBmasked2.fa.gz"

private int commonMicrobesBuild=1

private String otherMicrobesPath="RQCFILTER_PATH/otherMicrobes/"

private String otherMicrobesRef="RQCFILTER_PATH/otherMicrobes/fusedEmasked.fa.gz"

private int otherMicrobesBuild=1

private String taxTreeFile="RQCFILTER_PATH/tree.taxtree.gz"

private String giTable=null

private boolean pairedToSingle=false

*Library type codes
private static final int FRAG=0

*Library type codes
private static final int LFPE=1

*Library type codes
private static final int CLIP=2

*Library type codes
private static final int CLRS=3

private static final String clipLinkerDefault="CATG"


#Methods
*Program entrance from command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
RQCFilter2(String[] args)

private String appendOutDir(String s)

private String removeOutDir(String s)

*Primary method to fully execute the program.
public void process()

private boolean discoverAdapters(String in1, String in2, String outa)

*Runs Clumpify for compression.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void clumpify(String in1, String in2, String out1, String out2, String inPrefix, String outPrefix, int stepNum)

*Runs CalcTrueQuality to generate recalibration matrices from a sam file.
*@param sam Path to a sam file
private void calcTrueQuality(String sam)

*Runs BBDuk to recalibrate quality scores.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void recalibrate(String in1, String in2, String out1, String out2, String inPrefix, String outPrefix, int stepNum)

*Runs FilterByTile to remove reads from low-quality areas of the flowcell.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param tiledump Dump from full-lane FilterByTile run (optional)
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void filterByTile(String in1, String in2, String out1, String out2, String outbad, String tiledump, String inPrefix, String outPrefix, int stepNum)

*Runs BBDuk to perform:
*Kmer trimming, short read removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void ktrim(String in1, String in2, String out1, String out2, String inPrefix, String outPrefix, int stepNum)

*Runs PolyFilter to remove poly-G reads.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void polyfilter(String in1, String in2, String out1, String out2, String inPrefix, String outPrefix, String polymers, int stepNum)

*Runs Seal to perform:
*Spike-in removal and quantification.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void filterSpikein(String in1, String in2, String out1, String out2, String outbad, String inPrefix, String outPrefix, int stepNum)

*Runs BBDuk to perform:
*Quality filtering, quality trimming, n removal, short read removal, artifact removal (via kmer filtering), phiX removal, lambda removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void filter1(String in1, String in2, String out1, String out2, String outbad, String inPrefix, String outPrefix, int stepNum)

*Runs BBDuk to perform:
*Short contaminant removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void filter2(String in1, String in2, String out1, String out2, String outbad, String inPrefix, String outPrefix, int stepNum)

*Runs BBDuk to perform:
*Ribosomal read removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param outRibo Output for ribosomal reads
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void filterRibo(String in1, String in2, String out1, String out2, String outRibo, String inPrefix, String outPrefix, int stepNum)

private static String toPercent(long numerator, long denominator)

private static String format(String prefix, long rin, long rout, long bin, long bout)

*Runs SplitNexteraLMP.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void splitNextera(String in1, String in2, String inPrefix, String outPrefix, int stepNum)

*Runs BBMap to perform:
*Human contaminant removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void dehumanize(String in1, String in2, String out1, String out2, String outbad, String inPrefix, String outPrefix, int stepNum, boolean mouseCatDogHuman, boolean aggressive, long lastReadsObserved)

*Fasta only
public static boolean printFileTaxonomy(String in, String results, String taxTreeFile, boolean ow, boolean app, boolean bestEffort)

*Runs FilterByTaxa to remove sequences from a reference.
private String taxFilter(String in, String out, String results, String level, boolean include, boolean bestEffort, boolean log, boolean ow, boolean app)

*Runs FilterByTaxa to remove sequences from a reference.
private String taxFilterList(ArrayList<String> in, String out, boolean include, boolean bestEffort, String initialLevel)

private void detectCommonMicrobes(String in1, String in2, String scafstats, String inPrefix, String ref, boolean aggressive, int build, String cmRef, String cmPath)

*Runs BBMap to perform:
*Microbial contaminant removal.
private void removeCommonMicrobes(String in1, String in2, String out1, String out2, String outbad, String scafstats, String inPrefix, String outPrefix, String ref, int stepNum, boolean aggressive)

*Runs BBMap to perform:
*Arbitrary contaminant removal.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param out1 Primary output reads file (required)
*@param out2 Secondary output reads file
*@param inPrefix Append this prefix to input filenames
*@param outPrefix Append this prefix to output filenames
private void decontamByMapping(String in1, String in2, String out1, String out2, String outbad, String scafstats, String inPrefix, String outPrefix, String ref, int stepNum, boolean addToOtherStats, ArrayList<String> otherArgs)

private boolean runSketch(String in1, String outFname, String outPrefix)

private boolean runSketch_inner(String in, String fname, String db, boolean append)

*Runs BBMerge to generate an insert size histogram.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param prefix Append this prefix to input filenames
private void merge(String in1, String in2, String prefix)

*Runs BBNorm or KmerCountExact to generate a kmer frequency histogram.
*@param in1 Primary input reads file (required)
*@param in2 Secondary input reads file
*@param prefix Append this prefix to input filenames
private void khist(String in1, String in2, String prefix)

private static long kmerCapacity(int bytesPerKmer, boolean prealloc)

*Note - Seung-jin needs to be notified when new calls are added.
private void log(String message, boolean append)

*Log a message in the log file
*@param message Message to log
*@param append True to append, false to overwrite
private void log(String message, boolean append, boolean printTime)

*Delete all non-null filenames.
*@param prefix Append this prefix to filenames before attempting to delete them
*@param names Filenames to delete
private void delete(String prefix, String names)

*@return String of symbols indicating which processes were applied to the input reads
private String abbreviation()

*TODO: Some machines are set to UTC rather than PST
*@return Timestamp in RQC's format
public static String timeString()

public static String stripDirs(String fname)

*Set permissions on these files to 777
*@param names List of filenames
private static void setPermissions(String names)

*Writes a single command to the reproduce file
*@param fname Filename to write, including path
*@param command Command to add to file
*@param args Arguments to the command
private static void writeReproduceFile(String fname, String command, String[] args)

*Writes the header for the reproduce file
*@param fname Filename to write, including path
*@param command Command to add to file
*@param args Arguments to the command
*@param overwrite Permission to overwrite
private static void writeReproduceHeader(String fname, String[] args, boolean overwrite)

*@param s String representation of library type
*@return Numeric code for library type
private static int toLibType(String s)

private void fixReferencePaths()

private String fixPath(String s)

private static String getRQCPath()

</class RQCFilter2>
<class RQCFilterStats>
public class RQCFilterStats

#Fields
long readsIn

long basesIn

long readsOut

long basesOut

long readsDuplicate

long basesDuplicate

long readsLowQuality

long basesLowQuality

*These are already counted under low quality
long readsPolyG

long basesPolyG

*These are already counted under low quality
long readsN

long basesN

long readsArtifact

long basesArtifact

long readsFTrimmed

long basesFTrimmed

long readsAdapter

long basesAdapter

long readsSpikin

long basesSpikin

long readsRiboMap

long basesRiboMap

long readsChloroMap

long basesChloroMap

long readsMitoMap

long basesMitoMap

long readsSipMap

long basesSipMap

long readsRiboKmer

long basesRiboKmer

long readsMouse

long basesMouse

long readsCat

long basesCat

long readsDog

long basesDog

long readsHuman

long basesHuman

long readsMicrobe

long basesMicrobe

long readsOther

long basesOther

double gcPolymerRatio


#Methods
long totalReadsRemoved()

long totalBasesRemoved()

@Override public String toString()

public String toString(boolean skipAssertion)

StringBuilder format(String name, long reads, long bases, long rtot, long btot)

StringBuilder format(String name, long reads, long bases, long rtot, long btot, String suffix)

private static String toPercent(long numerator, long denominator, int decimals)

void parseHuman(String fname)

long[] parseStatsLine(String line)

void parseChloro(String fname)

void parseSip(String fname)

</class RQCFilterStats>
<class SamToEst>
*Processes a sam file of mapped ESTs.
*These ESTs may have been broken into smaller pieces for mapping,
*and if so, are reassembled.
*Produces a mapping statistics file.
*@author Brian Bushnell
*@date Sep 27, 2013
public class SamToEst

#Fields
public final float fractionForAll

public final String in

public final String stats

public final String ref

public final String estFile

public long refBases=0

public long estBases=0

public long estBasesMapped=0

public long refCount=0

public long estCount=0

public long partCount=0

public long partCountMapped=0

public long good=0

public long best=0

public long miss=0

public long zero=0

public long multiScaffold=0

public long multiScaffoldB=0

public long allPartsMapped=0

public long mostPartsMapped=0

public long somePartsMapped=0

public long noPartsMapped=0

public long allBasesMapped=0

public long mostBasesMapped=0

public long someBasesMapped=0

public long noBasesMapped=0

public long allBasesMappedB=0

public long mostBasesMappedB=0

public long someBasesMappedB=0

public long noBasesMappedB=0

public long[] msdicnOverall=new long[6]

public LongList introns=new LongList(1)

public int initialSize=4096

public boolean ADD_FROM_REF=true

public boolean USE_SECONDARY=false

public static int minIntron=10

public static boolean overwrite=true

public static boolean append=false

static PrintStream outstream=System.err


#Methods
public SamToEst(String in_, String stats_, String ref_, String est_, float fractionForAll_)

public void process()

private void addEst(EST est)

</class SamToEst>
<class SamToEst.EST>
public static class SamToEst.EST

#Fields
final String name

int length=0

int mappedLength=0

int parts=0

int mappedParts=0

HashSet<String> scafnames=new HashSet<String>(4)

int[] msdicn=KillSwitch.allocInt1D(6)


#Methods
public EST(String name_)

public void add(SamLine sl)

public int match()

@Override public String toString()

</class SamToEst.EST>
<class Seal>
*SEAL: Sequence Expression AnaLyzer
*Derived from BBDuk.
*Allows multiple values stored per kmer.
*Intended for RNA-seq, coverage, and other reads-per-sequence quantification.
*Also performs binning.
*@author Brian Bushnell
*@date November 10, 2014
public class Seal

#Fields
*For calculating kmer cardinality
final CardinalityTracker loglog

final CardinalityTracker loglogOut

*Has this class encountered errors while processing?
public boolean errorState=false

*Fraction of available memory preallocated to arrays
private double preallocFraction=0.5

*Initial size of data structures
private int initialSize=-1

*Default initial size of data structures
private static final int initialSizeDefault=128000

*Hold kmers. A kmer X such that X%WAYS=Y will be stored in keySets[Y]
private final AbstractKmerTable[] keySets

*A scaffold's name is stored at scaffoldNames.get(id).
*scaffoldNames[0] is reserved, so the first id is 1.
private final ArrayList<String> scaffoldNames=new ArrayList<String>()

*Names of reference files (refNames[0] is valid).
private final ArrayList<String> refNames=new ArrayList<String>()

*Number of scaffolds per reference.
private final int[] refScafCounts

*scaffoldCounts[id] stores the number of reads with kmer matches to that scaffold
private AtomicLongArray scaffoldReadCounts

*scaffoldFragCounts[id] stores the number of fragments (reads or pairs) with kmer matches to that scaffold
private AtomicLongArray scaffoldFragCounts

*scaffoldBaseCounts[id] stores the number of bases with kmer matches to that scaffold
private AtomicLongArray scaffoldBaseCounts

*scaffoldAmbigReadCounts[id] stores the number of reads ambiguously matching that scaffold
private AtomicLongArray scaffoldAmbigReadCounts

*Set to false to force threads to share atomic counter arrays.
private boolean ALLOW_LOCAL_ARRAYS=true

*scaffoldLengths[id] stores the length of that scaffold
private IntList scaffoldLengths=new IntList()

*scaffoldLengths[id] stores the number of kmers in that scaffold (excluding mutants)
private IntList scaffoldKmers=new IntList()

*scaffolds[id] stores the number of kmers in that scaffold
private ArrayList<byte[]> scaffolds=new ArrayList<byte[]>()

*Array of reference files from which to load kmers
private ArrayList<String> ref=new ArrayList<String>()

*Array of literal strings from which to load kmers
private String[] literal=null

*Taxonomic tree
private TaxTree tree

*Input reads
private String in1=null

*Input reads
private String in2=null

*Input qual files
private String qfin1=null

*Input qual files
private String qfin2=null

*Output reads (matched and at least minlen)
private String outm1=null

*Output reads (matched and at least minlen)
private String outm2=null

*Output reads (unmatched or shorter than minlen)
private String outu1=null

*Output reads (unmatched or shorter than minlen)
private String outu2=null

*Per-sequence or per-reference output pattern
private String outpattern=null

*Statistics output files
private String outstats=null

*Statistics output files
private String outrpkm=null

*Statistics output files
private String outrefstats=null

*Statistics output files
private String outtax=null

*Barcode output files
private String outbarcodes=null

*NCBI file mapping gi numbers to taxa IDs (gi_taxid_nucl.dmp)
private String giTableFile=null

*NCBI file of taxonomy names (names.dmp)
private String taxNameFile=null

*NCBI file of taxonomic tree (nodes.dmp)
private String taxNodeFile=null

*File containing a serialized TaxTree
private String taxTreeFile

*Store reference sequences
private boolean storeRefBases=false

*Only look for fully-contained reference sequences
private boolean processContainedRef=false

*Dump kmers here.
private String dump=null

*Maximum input reads (or pairs) to process. Does not apply to references. -1 means unlimited.
private long maxReads=-1

*Process this fraction of input reads.
private float samplerate=1f

*Set samplerate seed to this value.
private long sampleseed=-1

*Output reads in input order. May reduce speed.
private final boolean ordered

*Make the middle base in a kmer a wildcard to improve sensitivity
private boolean maskMiddle=true

private int midMaskLen=0

*Store reference kmers with up to this many substitutions
private int hammingDistance=0

*Search for query kmers with up to this many substitutions
private int qHammingDistance=0

*Store reference kmers with up to this many edits (including indels)
private int editDistance=0

*Always skip this many kmers between used kmers when hashing reference.
private int refSkip=0

private long taxNodeCountLimit=1

private int taxNodeNumberLimit=-1

private int taxNodeMinLevel=0

private int taxNodeMaxLevel=TaxTree.parseLevel("domain")

private boolean trackBarcodes=false

private BarcodeMappingStats barcodeData=null

long readsIn=0

long fragsIn=0

long basesIn=0

long readsMatched=0

long basesMatched=0

long readsUnmatched=0

long basesUnmatched=0

long readsAmbig=0

long readsQTrimmed=0

long basesQTrimmed=0

long readsFTrimmed=0

long basesFTrimmed=0

long readsQFiltered=0

long basesQFiltered=0

long refReads=0

long refBases=0

long refKmers=0

long correctReads=0

long incorrectReads=0

long storedKmers=0

*Correct errors via read overlap
private final boolean ecc

*Look for reverse-complements as well as forward kmers. Default: true
private final boolean rcomp

*Don't allow a read 'N' to match a reference 'A'.
*Reduces sensitivity when hdist>0 or edist>0. Default: false.
private final boolean forbidNs

*AND bitmask with 0's at the middle base
private final long middleMask

*Data structure to use. Default: ARRAYHF
private final int tableType

*Normal kmer length
private final int k

*k-1; used in some expressions
private final int k2

*A read must share at least this many kmers to be considered a match. Default: 1
private final int minKmerHits

*A read must share at least this fraction of its kmers to be considered a match. Default: 0
private final float minKmerFraction

*Determines how to handle ambiguously-mapping reads
private final int ambigMode

*Determines when to early-exit kmer matching
private final int matchMode

*First and second must differ by more than this to be unambiguous.
private final int clearzone

*First and second must differ by more than this fraction of read kmers to be unambiguous.
private final float clearzoneFraction

*Calculate accuracy rate by parsing headers of synthetic reads
private final boolean parsecustom

*Quality-trim the left side
private final boolean qtrimLeft

*Quality-trim the right side
private final boolean qtrimRight

*Trim bases at this quality or below. Default: 4
private final float trimq

*Error rate for trimming (derived from trimq)
private final float trimE

*Throw away reads below this average quality after trimming. Default: 0
private final float minAvgQuality

*If positive, calculate average quality from the first X bases only. Default: 0
private final int minAvgQualityBases

*Throw away reads failing chastity filter (:Y: in read header)
private final boolean chastityFilter

*Throw away reads containing more than this many Ns. Default: -1 (disabled)
private final int maxNs

*Throw away reads containing without at least this many consecutive called bases.
private int minConsecutiveBases=0

*Throw away reads shorter than this after trimming. Default: 10
private final int minReadLength

*Throw away reads longer than this after trimming. Default: Integer.MAX_VALUE
private final int maxReadLength

*Toss reads shorter than this fraction of initial length, after trimming
private final float minLenFraction

*Filter reads by whether or not they have matching kmers
private final boolean kfilter

*Trim left bases of the read to this position (exclusive, 0-based)
private final int forceTrimLeft

*Trim right bases of the read after this position (exclusive, 0-based)
private final int forceTrimRight

*Trim this many rightmost bases of the read
private final int forceTrimRight2

*Trim right bases of the read modulo this value.
*e.g. forceTrimModulo=50 would trim the last 3bp from a 153bp read.
private final int forceTrimModulo

*If positive, only look for kmer matches in the leftmost X bases
private int restrictLeft

*If positive, only look for kmer matches the rightmost X bases
private int restrictRight

*Skip this many initial input reads
private final long skipreads

*Pairs go to outbad if either of them is bad, as opposed to requiring both to be bad.
*Default: true.
private final boolean removePairsIfEitherBad

*Print only statistics for scaffolds that matched at least one read
*Default: true.
private final boolean printNonZeroOnly

*Rename reads to indicate what they matched.
*Default: false.
private final boolean rename

*Use names of reference files instead of scaffolds.
*Default: false.
private final boolean useRefNames

*Include the count when adding names
private boolean addCount=true

*Only use the top hit when adding names
private boolean topHitOnly=false

*Add 'unknown' to unmapped or ambiguous reads in rename mode
private boolean addUnknown=false

*Fraction of kmers to skip, 0 to 15 out of 16
private final int speed

*Skip this many kmers when examining the read. Default 1.
*1 means every kmer is used, 2 means every other, etc.
private final int qSkip

*True if speed and qSkip are disabled.
private final boolean noAccel

*Pick a single scaffold per read pair, rather than per read
private final boolean keepPairsTogether

*Store match IDs in an IntList rather than int array
private final boolean USE_COUNTVECTOR

*Gather taxonomic information
private final boolean USE_TAXTREE

private ConcurrentHashMap<String,StringCount> setMap

*Number of tables (and threads, during loading)
private static final int WAYS=9

*Verbose messages
public static final boolean verbose=false

*Number of reads output in the last run
public static long lastReadsOut

*Print messages to this stream
private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Print speed statistics upon completion
public static boolean showSpeed=true

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

*Number of ProcessThreads
public static int THREADS=Shared.threads()

*Indicates end of input stream
private static final ArrayList<Read> POISON=new ArrayList<Read>(0)

*Number of columns for statistics output, 3 or 5
public static int STATS_COLUMNS=5

*Release memory used by kmer storage after processing reads
public static boolean RELEASE_TABLES=true

*Max value of hitCount array
public static final int HITCOUNT_LEN=1000

*Make unambiguous copies of ref sequences with ambiguous bases
public static boolean REPLICATE_AMBIGUOUS=false

*Write refstats in similar style to BBSplit
public static boolean BBSPLIT_STYLE=false

*Rename duplicate scaffold names instead of crashing.
public static boolean RENAME_DUPLICATES=true

*Create sets of amiguously-mapping gene targets on the fly
public static boolean MAKE_GENE_SETS=false

*x&clearMasks[i] will clear base i
private static final long[] clearMasks

*x|setMasks[i][j] will set base i to j
private static final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
private static final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
private static final long[] rightMasks

*x|kMasks[i] will set the bit to the left of the leftmost base
private static final long[] lengthMasks

private static final int qhdistSizeLimit=10

public static HashMap<String,String> RQC_MAP=null

public static final int AMBIG_ALL=1

public static final int AMBIG_FIRST=2

public static final int AMBIG_TOSS=3

public static final int AMBIG_RANDOM=4

public static final int MATCH_ALL=1

public static final int MATCH_FIRST=2

public static final int MATCH_UNIQUE=3


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public Seal(String[] args)

*Primary driver function of class.
public void process()

public void process2(long startTime)

private static String toPercent(long numerator, long denominator)

*Clear stored kmers.
public void unloadKmers()

*Clear stored sequence data.
public void unloadScaffolds()

private void addToRqcMap()

*Write statistics about how many reads matched each reference scaffold.
private void writeStats()

private void writeBarcodeStats()

private void writeRPKM()

*Write RPKM statistics.
public void writeRPKM(String out, String in1, String in2, long readsIn, boolean printNonZeroOnly, ArrayList<String> scaffoldNames, IntList scaffoldLengths, AtomicLongArray scaffoldReadCounts, AtomicLongArray scaffoldFragCounts, AtomicLongArray scaffoldBaseCounts, AtomicLongArray scaffoldAmbigReadCounts)

*Write statistics on a per-reference basis.
private void writeRefStats()

*Write statistics on a per-reference basis.
private void writeRefStats_BBSplitStyle(long totalReads)

*Write taxonomic information.
private void writeTaxonomy()

private static int numKmers(Read r1, Read r2, int k)

private void loadGiToTaxid()

private void addToTree()

*Fills tables with kmers from references, using multiple LoadThread.
*@return Number of kmers stored.
private long spawnLoadThreads()

*Match reads against reference kmers, using multiple ProcessThread.
*@param t
private void spawnProcessThreads(Timer t)

*Current available memory
private static final long freeMemory()

*Transforms a kmer into a canonical value stored in the table. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param lengthMask Bitmask with single '1' set to left of kmer
*@return Canonical value
private final long toValue(long kmer, long rkmer, long lengthMask)

final long rcomp(long kmer, int len)

final boolean passesSpeed(long key)

final boolean failsSpeed(long key)

</class Seal>
<class SealRefInfo>
*Handles duties related to tracking Seal's reference set and scaffolds.
*@author BBushnell
public class SealRefInfo

#Fields
final ArrayList<String> refs

final String[] literals

*A scaffold's name is stored at scaffoldNames.get(id).
*scaffoldNames[0] is reserved, so the first id is 1.
final ArrayList<String> scaffoldNames=new ArrayList<String>()

*Names of reference files (refNames[0] is valid).
final ArrayList<String> refNames=new ArrayList<String>()

*Number of scaffolds per reference.
final int[] refScafCounts

*scaffoldCounts[id] stores the number of reads with kmer matches to that scaffold
AtomicLongArray scaffoldReadCounts

*scaffoldFragCounts[id] stores the number of fragments (reads or pairs) with kmer matches to that scaffold
AtomicLongArray scaffoldFragCounts

*scaffoldBaseCounts[id] stores the number of bases with kmer matches to that scaffold
AtomicLongArray scaffoldBaseCounts

*scaffoldLengths[id] stores the length of that scaffold
IntList scaffoldLengths=new IntList()

*scaffoldLengths[id] stores the number of kmers in that scaffold (excluding mutants)
IntList scaffoldKmers=new IntList()

*scaffolds[id] stores the number of kmers in that scaffold
ArrayList<byte[]> scaffolds=new ArrayList<byte[]>()


#Methods
*@param outstream Typically stderr
public SealRefInfo(ArrayList<String> refs_, String[] literals_, PrintStream outstream)

boolean isEmpty()

int numScaffolds()

*Clear stored sequence data.
public void unloadScaffolds()

*Write statistics on a per-reference basis.
void writeRefStats(String fname, boolean ow, boolean useRefNames, boolean printNonZeroOnly, String in1, String in2, long readsIn)

*Write statistics on a per-reference basis.
void writeRefStats_BBSplitStyle(String fname, boolean ow, boolean useRefNames, boolean printNonZeroOnly, long totalReads)

</class SealRefInfo>
<class SmallKmerFrequency>
*@author Brian Bushnell
*@date Feb 19, 2015
public class SmallKmerFrequency

#Fields
private static final NumComparator numComparator=new NumComparator()

private static final CountComparator countComparator=new CountComparator()

private int k

private int display

private boolean addNumbers

private final int maxKmer

private final int[] kmerIndex

private final int[] counts

private final StringBuilder sb=new StringBuilder()

private final Kmer[] kmers


#Methods
*Code entrance from the command line.
*Must be overridden; the commented body is an example.
*@param args Command line arguments
public static void main(String[] args)

@Override protected void setDefaults()

*@param args
public SmallKmerFrequency(String[] args)

@Override public boolean parseArgument(String arg, String a, String b)

@Override protected boolean processReadPair(Read r1, Read r2)

*Makes a kmer (e.g., tetramer) profile of a cluster
private final int[] makeKmerProfile(byte[] bases, int[] array_, boolean clear)

@Override protected void startupSubclass()

@Override protected void shutdownSubclass()

@Override protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

public static final int[] makeKmerIndex(int n)

@Override protected final boolean useSharedHeader()

</class SmallKmerFrequency>
<class SplitNexteraLMP>
*@author Brian Bushnell
*@date Mar 2, 2015
public class SplitNexteraLMP

#Fields
private String[] literals=new String[]{"CTGTCTCTTATACACATCTAGATGTGTATAAGAGACAG"}

private final AbstractKmerTable[] tables

private int k=19

private int mink=11

private int hdist=1

private int hdist2=0

private int edist=0

private boolean rcomp=true

private boolean maskMiddle=false

private String dump=null

private TableReader reader

protected String outStats="stderr"

protected String outFrag1

protected String outFrag2

protected String outUnk1

protected String outUnk2

protected String outSingle

protected FileFormat ffoutFrag1

protected FileFormat ffoutFrag2

protected FileFormat ffoutUnk1

protected FileFormat ffoutUnk2

protected FileFormat ffoutSingle

protected ConcurrentReadOutputStream rosFrag

protected ConcurrentReadOutputStream rosUnk

protected ConcurrentReadOutputStream rosSingle

private int minReadLength

private boolean mask

private boolean merge

private double testmerge

private long readsLmp=0

private long basesLmp=0

private long readsFrag=0

private long basesFrag=0

private long readsUnk=0

private long basesUnk=0

private long readsSingle=0

private long basesSingle=0

private long mergedReadCount=0

private long mergedBaseCount=0

private long junctionsSought=0

private long junctionsDetected=0

private boolean pairedInput

private byte symbol

private boolean useInnerLMP

private boolean RENAME


#Methods
public static void main(String[] args)

@Override protected void setDefaults()

*@param args
public SplitNexteraLMP(String[] args)

@Override public boolean parseArgument(String arg, String a, String b)

@Override protected void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream rosLmp)

@Override protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

@Override protected boolean processReadPair(Read r1, Read r2)

boolean processReadPair(Read r1, Read r2, ArrayList<Read> outLmp, ArrayList<Read> outFrag, ArrayList<Read> outUnk, ArrayList<Read> outSingle)

boolean processMergedRead(Read merged, Read r1, Read r2, ArrayList<Read> outLmp, ArrayList<Read> outFrag, ArrayList<Read> outUnk, ArrayList<Read> outSingle)

@Override protected void shutdownSubclass()

@Override protected final boolean useSharedHeader()

public long readsLmp()

public long basesLmp()

public long readsFrag()

public long basesFrag()

public long readsUnk()

public long basesUnk()

public long readsSingle()

public long basesSingle()

</class SplitNexteraLMP>
<class SplitPairsAndSingles>
*@author Brian Bushnell
*@date Sep 4, 2013
public final class SplitPairsAndSingles

#Fields
private String in1=null

private String in2=null

private String out1=null

private String out2=null

private String outsingle=null

private long maxReads=-1

public boolean errorState=false

long readsIn=0

long basesIn=0

long readsOut=0

long basesOut=0

long pairsOut=0

long pairBasesOut=0

long singlesOut=0

long singleBasesOut=0

long readsTrimmed=0

long basesTrimmed=0

private final LinkedHashMap<String,Read> pairMap

private float trimq=6

*Error rate for trimming (derived from trimq)
private final float trimE

private int minReadLength=20

private final boolean qtrimLeft

private final boolean qtrimRight

private final boolean fixInterleaving

private final boolean allowIdenticalPairNames

private final boolean repair

private boolean addslash=false

private boolean addcolon=false

private static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

public static boolean showSpeed=true

public static boolean verbose=false

private static final String slash1=" /1"

private static final String slash2=" /2"

private static final String colon1=" 1:"

private static final String colon2=" 2:"


#Methods
public SplitPairsAndSingles(String[] args)

public void process()

private void process2()

private void process3(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

private void process3_fixInterleaving(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

private void process3_repair(DualCris cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

private void process3_repair(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosb)

private int processPair(Read r1, Read r2, ArrayList<Read> pairs, ArrayList<Read> singles)

private Read repair(Read r)

</class SplitPairsAndSingles>
<class SplitSam4Way>
*@author Brian Bushnell
*@date Jul 23, 2013
public class SplitSam4Way

#Fields
private PrintStream outstream=System.err


#Methods
private void printOptions()

public SplitSam4Way(String[] args)

</class SplitSam4Way>
<class SplitSam6Way>
*@author Brian Bushnell
*@date Jun 15, 2017
public class SplitSam6Way

#Fields
private PrintStream outstream=System.err


#Methods
public static void main(String[] args)

private void printOptions()

public SplitSam6Way(String[] args)

</class SplitSam6Way>
<class SplitSamFile>
public class SplitSamFile

#Fields
private static boolean includeHeader=false

</class SplitSamFile>
<class TestFilesystem>
public class TestFilesystem

#Fields
private static int iteration

private static String in="foo#.txt"

private static String out="bar.txt"

private static String log="log.txt"

private static int ways=40

private static int filesToCreate=1000

private static String[] fnames

private static long size=5000000000L

private static long interval_seconds=3600

private static long millis=interval_seconds * 1000

private static final String waiter="waiter"

private static final byte[] buffer=new byte[65536]

private static final ByteBuilder poison=new ByteBuilder()

private static ArrayBlockingQueue<ByteBuilder> readQueue=new ArrayBlockingQueue<ByteBuilder>(4)


#Methods
public static void main(String[] args)

private static void runLoop()

private static void testMetadata()

private static int testLs()

private static void copy(String from0, String to, int iter)

private static int fillBuffer(InputStream is)

private static ByteBuilder readFetch()

private static String header()

private static void log(long time, long copyTime, long metaTime, long lsTime)

private static void printLine(String line)

private static void waitUntil(long time)

private static void put(ByteBuilder bb, ArrayBlockingQueue<ByteBuilder> q)

</class TestFilesystem>
<class TestFormat>
*@author Brian Bushnell
*@date Jan 6, 2018
public class TestFormat

#Fields
private ArrayList<String> in=new ArrayList<String>()

private long variantsProcessed=0

private long headerLinesProcessed=0

private long readsProcessed=0

private long pairsProcessed=0

private long basesProcessed=0

private long mergeAttempts=0

private long acidsNotBasesProcessed=0

private long junkProcessed=0

private long chastityFail=0

private long badPairs=0

private long adapterBases=0

private long adapterReads=0

private long[] ACGTUNIGO=new long[9]

private long[] AXEGO=new long[5]

private long[] lowerUpperSymbol=new long[3]

private long[] qhist=new long[256]

private long[] ihist=new long[1000]

private long[] trimhist=new long[51]

private int minLen=Integer.MAX_VALUE

private int maxLen=0

private int qMinUncalled=999

private int qMaxUncalled=-999

private int qMinCalled=999

private int qMaxCalled=-999

private final int lengthLimit=100000

private SuperLongList sll=new SuperLongList(lengthLimit)

private IntHashMapBinary zmwMap=new IntHashMapBinary(2048)

private boolean parseZmw=true

private ArrayList<String> invalidHeaders=new ArrayList<String>()

private final SketchTool tool

private final SketchMakerMini smm

private Sketch sketch=null

private final byte initialQin

private final boolean initialDetectQuality

private int barcodesPerRead

private byte barcodeDelimiter

private BarcodeStats barcodeStats

private AdapterTracker aTrack=new AdapterTracker()

int ploidy=-1

double pairingRate=-1

double mapqAvg=-1

double totalQualityAvg=-1

double readLengthAvg=-1

private int format=FileFormat.UNKNOWN

private int compression=FileFormat.UNKNOWN

private boolean amino=false

private boolean differs=false

private boolean interleaved=false

private int offset=33

private boolean makeSketch=true

private boolean doMerge=true

private boolean doTrim=true

private int sketchSize=40000

private long maxReads=-1

private boolean full=true

private boolean fast=true

private boolean printSpeed=false

private boolean errorState=false

private boolean printBarcodes=false

private boolean printQhist=false

private boolean printIhist=false

private boolean printJunk=false

private boolean makeBhist

private int maxBhistLen=10000

private final boolean makeLhist

private final boolean makeGChist

private String qhistFile="qhist.txt"

private String ihistFile="ihist.txt"

private String khistFile="khist.txt"

private String bhistFile="bhist.txt"

private String lhistFile="lhist.txt"

private String gchistFile="gchist.txt"

private String zmwhistFile="zmwhist.txt"

private String adapterFile="adapters.fa"

private String firstHeader=null

private String barcodeFile="barcode#.txt"

private String junkFile="junk.txt"

private String expectedCodeFile=null

private static final int qOffset=128

private static final byte[] toNum=makeToNum()

private static final byte[] toLUS=makeToLUS()

private static final byte[] toAmino=makeToAmino()

private static final byte[] aminoOnly=makeAminoOnly()

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public TestFormat(String[] args)

void process(Timer t)

void printVariantResults()

void printSequenceResults()

void printAminoTop()

void printNucleotideTop()

void printQhist()

static String qhistToRangeString(long[] qhist)

static ArrayList<Range> qhistToRanges(long[] qhist)

void printIhist()

void printBarcodes()

void printJunk()

void println(Object o)

private FileFormat test(String fname)

void processReads(FileFormat ff)

void loadVars(FileFormat ff)

void loadVcf(FileFormat ff)

private static final byte[] makeToNum()

private static final byte[] makeToAmino()

private static final byte[] makeAminoOnly()

private static final byte[] makeToLUS()

private static byte toNum(byte b)

private static byte toLUS(byte b)

*Spawn process threads
private void spawnThreads(FileFormat ff, ConcurrentReadInputStream cris)

private void printToFile(long[] hist, boolean nzo, String header, String fname)

private void printToFileOffset(long[] hist, boolean nzo, String header, String fname, int offset)

private static void add(long[] dest, long[] source)

</class TestFormat>
<class TetramerFrequencies>
*@author syao
*@contributor Brian Bushnell
*Last updated : 01102018
public class TetramerFrequencies

#Fields
final Line POISON_LINE=new Line(null,null,-1,-1,-1)

private final ArrayBlockingQueue<Line> inq

private final int threads

private long nextID=0

private String in1=null

private String out1=null

private ByteStreamWriter bsw=null

private final FileFormat ffin1

private java.io.PrintStream outstream=System.err

private long maxReads=-1

int step=500

private int winSize=2000

private boolean keepShort=false

private boolean printGC=false

private boolean printFloats=false

private boolean gcCompensate=false

private final int k

private final int[] remap

private final int[] gcmap

private final int canonicalKmers

private static final int windowsPerLine=8

public static boolean verbose=false


#Methods
public TetramerFrequencies(String[] args)

void process(Timer t)

private void windowedTetramerProfile(byte[] bases, String header)

void append(Line line, int[] counts, float gc, ByteBuilder bb)

public int[] countKmers(byte[] bases, int startidx, int endidx, int[] counts, float[] gc)

public ByteBuilder header()

public static void printHelp()

final Line takeLine()

final void putLine(Line line)

*Spawn process threads
private ArrayList<PrintThread> spawnThreads()

private void waitForFinish(ArrayList<PrintThread> alpt)

</class TetramerFrequencies>
<class TetramerFrequencies_old>
*@author syao
*Last updated : 01102018
public class TetramerFrequencies_old

#Fields
final Line POISON_LINE=new Line(null,null,-1,-1,-1)

private final ArrayBlockingQueue<Line> inq

private final int threads

private long nextID=0

private String out1=null

private ByteStreamWriter bsw=null

private final FileFormat ffin1

private java.io.PrintStream outstream=System.err

private long maxReads=-1

int step=500

private int winSize=2000

private final int k

private boolean keepShort=false

private boolean printGC=false

private static final int windowsPerLine=8

public static boolean verbose=false


#Methods
public TetramerFrequencies_old(String[] args)

void process(Timer t)

private void windowedTetramerProfileOpt(byte[] bases, String header)

private void windowedTetramerProfile(byte[] bases, String header)

void append(Line line, int[] counts, StringBuilder sb)

void append(Line line, int[] counts, float gc, ByteBuilder bb)

public int[] tetramerCounter(byte[] bases, int startidx, int endidx, int[] counts, float[] gc)

private int tmerIndex(int tmer)

public List<String> tetramerGen(List<String> tlist)

public List<String> tetramerGen2(List<String> tlist)

public void printTetramerFromCode(long code)

public static void printHelp()

final Line takeLine()

final void putLine(Line line)

*Spawn process threads
private ArrayList<PrintThread> spawnThreads()

private void waitForFinish(ArrayList<PrintThread> alpt)

</class TetramerFrequencies_old>
<class TranslateSixFrames>
*@author Brian Bushnell
*@date Sep 11, 2012
public class TranslateSixFrames

#Fields
private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

*Add /1 and /2 to paired reads
private boolean addslash=false

private boolean skipquality=false

private boolean NT_IN=true

private boolean NT_OUT=false

private long maxReads=-1

private float samplerate=1f

private long sampleseed=-1

private final int FRAMES

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private static final String[] frametag=new String[]{" fr1"," fr2"," fr3"," fr4"," fr5"," fr6"}

private static final byte[][] QNULL=new byte[6][]

private boolean addTag=true

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean useSharedHeader


#Methods
public TranslateSixFrames(String[] args)

void process(Timer t)

public static final ArrayList<Read> toFrames(Read r1, boolean skipquality, boolean addTag, int frames)

public static final ArrayList<Read> toFrames(Read r1, boolean skipquality, boolean addTag, int frames, ArrayList<Read> listOut)

</class TranslateSixFrames>
<class TrimContigs>
*Trims contigs to eliminate uncovered areas.
*@author Brian Bushnell
*@date September 28, 2024
public class TrimContigs

#Fields
private String in1=null

private String covRanges=null

private String name=null

private String qfin1=null

private String outclean=null

private String outdirty=null

private String qfoutclean=null

private String qfoutdirty=null

private String extin=null

private String extout=null

private String gffIn=null

private String gffOut=null

private ArrayList<GffLine> gffLinesIn

private HashMap<String,ArrayList<GffLine>> gffMap

private ArrayList<GffLine> gffLinesOut

*Scaffolds shorter than this will be discarded.
private int minLength=1

*Scaffolds with lower average coverage will be discarded.
private double minCoverage=1

*Scaffolds with a lower percent of covered bases will be discarded.
private double minCoveredPercent=0

*Trim this much from sequence ends, minimum
private int trimEndsMin=0

*Trim this much from sequence ends, maximum
private int trimEndsMax=2000000000

*Trim this far into covered areas
private int trimEndsExtra=5

*Uncovered areas longer than this will trigger trimming
private int maxUncoveredLength=3

*Permission to break apart contigs at uncovered areas
boolean breakContigs=true

boolean skipPolyN=true

String breakListFile

private final FileFormat ffRange

private final FileFormat ffoutclean

private final FileFormat ffoutdirty

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean logappend=false

private String logfile=null

private boolean logheader=true

private static boolean PRINT_SHORT_CONTIG_RESULTS=false


#Methods
public TrimContigs(String[] args)

void process(Timer t)

private Read processSeq(Read seq, Range r, int partnum, int parts)

private static void processGff(ArrayList<Range> ranges, ArrayList<GffLine> gffLines, ArrayList<GffLine> gffLinesOut)

private static Range toMaximalRange(Collection<Range> ranges)

*Fuses adjacent ranges separated by fewer than
*maxUncoveredLength uncovered defined bases.
private int fixPolyN(Read seq, ArrayList<Range> ranges)

private void loadGff(String s)

</class TrimContigs>
<class UnicodeToAscii>
*@author Brian Bushnell
*@date Apr 21, 2015
public class UnicodeToAscii

#Fields
private PrintStream outstream=System.err

private String in1

private String in2

private String out1

private String out2

private boolean verbose=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public UnicodeToAscii(String[] args)

private void process(Timer t)

private void process(String infile, String outfile)

</class UnicodeToAscii>
<class Unzip>
*@author Brian Bushnell
*@date May 9, 2016
public class Unzip

#Fields
private String in1=null

private String out1=null

private String outInvalid=null

private long bytesProcessed=0

private long maxLines=Long.MAX_VALUE

private final FileFormat ffin1

private final FileFormat ffout1

private final FileFormat ffoutInvalid

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

public boolean showSpeed=false

private boolean overwrite=true

private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public Unzip(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private void processInner(InputStream is, ByteStreamWriter bsw)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class Unzip>
