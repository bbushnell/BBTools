#version 1
#package template
#generated 2025-09-06T20:39:18

<interface Accumulator>
*Interface for accumulating statistics captured by threads.
*@author Brian Bushnell
*@date November 19, 2015
*@param
public interface Accumulator

#Methods
*Accumulate personal variables from finished threads
public void accumulate(T t)

*A shared lock preventing premature accumulation
public ReadWriteLock rwlock()

*True if it finished successfully
public boolean success()

</interface Accumulator>
<class A_Sample>
*This class does nothing.
*It is designed to be easily modified into a program
*that processes reads in a single thread.
*@author Brian Bushnell
*@date June 20, 2014
public class A_Sample

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*This flag has no effect on singlethreaded programs
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_Sample(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Iterate through the reads
void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a list of Reads.
*@param ln The list.
*@param cris Read Input Stream
*@param ros Read Output Stream for reads that will be retained
void processList(ListNum<Read> ln, ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

</class A_Sample>
<class A_Sample2>
*@author Brian Bushnell
*@date Oct 6, 2014
public class A_Sample2

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private long maxReads=-1

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public A_Sample2(String[] args)

void process(Timer t)

</class A_Sample2>
<class A_SampleBasic>
*Reads a text file.
*Prints it to another text file.
*@author Brian Bushnell
*@date April 9, 2020
public class A_SampleBasic

#Fields
private String in=null

private String out=null

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private final FileFormat ffin

private final FileFormat ffout

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_SampleBasic(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private void processInner(ByteFile bf, ByteStreamWriter bsw)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class A_SampleBasic>
<class A_SampleBasic2>
*Reads a text file.
*Does something.
*@author Brian Bushnell
*@date April 9, 2020
public class A_SampleBasic2

#Fields
private String out=null

private long maxCycles=100

private long linesOut=0

private long bytesOut=0

private final FileFormat ffout

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public A_SampleBasic2(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private void processInner(ByteStreamWriter bsw)

private static ByteStreamWriter makeBSW(FileFormat ff)

private boolean doSomething(ByteStreamWriter bsw, ByteBuilder bb, long cycle)

</class A_SampleBasic2>
<class A_SampleByteFile>
*Reads a text file.
*Prints it to another text file.
*Filters out invalid lines and prints them to an optional third file.
*@author Brian Bushnell
*@date May 9, 2016
public class A_SampleByteFile

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Junk output file path
private String outInvalid=null

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Output File
private final FileFormat ffout1

*Optional Output File for Junk
private final FileFormat ffoutInvalid

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_SampleByteFile(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create streams and process all data
void process(Timer t)

private void processInner(ByteFile bf, ByteStreamWriter bsw, ByteStreamWriter bswInvalid)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class A_SampleByteFile>
<class A_SampleByteFileMT>
*This class models loading a text file,
*then spawning threads that each read a second text file.
*@author Brian Bushnell
*@date February 6, 2023
public class A_SampleByteFileMT

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary output file path
private String out1=null

*Junk output file path
private String outInvalid=null

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private static long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Secondary Input File
private final FileFormat ffin2

*Output File
private final FileFormat ffout1

*Optional Output File for Junk
private final FileFormat ffoutInvalid

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_SampleByteFileMT(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

*Spawn process threads
private void spawnThreads(FileFormat ffin)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

private void processFF1(FileFormat ff)

private static ByteStreamWriter makeBSW(FileFormat ff)

@Override public final ReadWriteLock rwlock()

</class A_SampleByteFileMT>
<class A_SampleByteFileMT.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
static class A_SampleByteFileMT.ProcessThread

#Fields
*Number of reads processed by this thread
protected long linesProcessedT=0

*Number of bases processed by this thread
protected long bytesProcessedT=0

*Number of reads retained by this thread
protected long linesOutT=0

*Number of bases retained by this thread
protected long bytesOutT=0

protected boolean errorStateT=false

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final FileFormat ffin

*Thread ID
final int tid


#Methods
ProcessThread(FileFormat ffin_, int tid_)

@Override public void run()

*Iterate through the lines
void processInner()

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processLine(byte[] line)

</class A_SampleByteFileMT.ProcessThread>
<class A_SampleD>
*@author Brian Bushnell
*@date Oct 6, 2014
public class A_SampleD

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private long maxReads=-1

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public A_SampleD(String[] args)

void process(Timer t)

</class A_SampleD>
<class A_SampleMT>
*This class does nothing.
*It is designed to be easily modified into a program
*that processes reads in multiple threads, by
*filling in the processReadPair method.
*@author Brian Bushnell
*@date November 19, 2015
public class A_SampleMT

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_SampleMT(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class A_SampleMT>
<class A_SampleMT.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
static class A_SampleMT.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

</class A_SampleMT.ProcessThread>
<class A_SampleMultipleInput>
*Accepts multiple input files.
*Reads them each sequentially, and outputs everything to a single output file.
*Generically, it can be used to concatenate files while recompressing them
*and avoiding the use of stdio.
*@author Brian Bushnell
*@date May 10, 2024
public class A_SampleMultipleInput

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out1=null

private final FileFormat ffout1

private long maxReads=-1

private long readsProcessed=0

private long basesProcessed=0

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public A_SampleMultipleInput(String[] args)

void process(Timer t)

void processInner(String fname, ConcurrentReadOutputStream ros)

</class A_SampleMultipleInput>
<class A_SampleSamStreamer>
*This class does nothing.
*It is designed to be easily modified into a program
*that processes reads in multiple threads, by
*filling in the processRead method.
*@author Brian Bushnell
*@date September 6, 2019
public class A_SampleSamStreamer

#Fields
*Primary input file path
private String in=null

*Secondary input file path
private String ref=null

*Primary output file path
private String out=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Threads dedicated to reading the sam file
private int streamerThreads=SamStreamer.DEFAULT_THREADS

private boolean loadedRef=false

private boolean realign=false

private int ploidy=1

public ScafMap scafMap

public final SamFilter samFilter=new SamFilter()

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Primary input file
private final FileFormat ffin

*Secondary input file
private final FileFormat ffref

*Primary output file
private final FileFormat ffout

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public A_SampleSamStreamer(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private void loadScafMapFromReference()

private void loadReferenceCustom()

private ConcurrentReadInputStream makeRefCris()

private SamStreamer makeStreamer(FileFormat ff)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(SamStreamer ss, ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class A_SampleSamStreamer>
<class A_SampleSamStreamer.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class A_SampleSamStreamer.ProcessThread

#Fields
*Shared input stream
private final SamStreamer ss

*For realigning reads
final Realigner realigner


#Methods
ProcessThread(SamStreamer ss_, ConcurrentReadOutputStream ros_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processRead(Read r)

</class A_SampleSamStreamer.ProcessThread>
<class A_SampleSummary>
*@author Brian Bushnell
*@date Oct 6, 2014
public class A_SampleSummary

#Fields
private String in1=null

private String out1=null

private final FileFormat ffin1

private final FileFormat ffout1

private long maxReads=-1

private boolean errorState=false

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public A_SampleSummary(String[] args)

private void outputResults()

</class A_SampleSummary>
<class A_Sample_Generator>
*This class does nothing.
*It serves as a template for generating reads,
*potentially based on some input sequence.
*@author Brian Bushnell
*@date June 8, 2019
public class A_Sample_Generator

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

private String qfout1=null

private String qfout2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after generating this many OUTPUT reads
private long maxReads=-1

*Input read storage, if needed
private ArrayList<Read> data=new ArrayList<Read>()

private AtomicLong nextReadID=new AtomicLong(0)

*Primary input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public A_Sample_Generator(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

*Create a Read Input Stream
private ConcurrentReadInputStream makeCris()

*Create a Read Output Stream
private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Wait until all worker threads are finished, then return
private void waitForThreads(ArrayList<ProcessThread> alpt)

private ArrayList<Read> loadData(ConcurrentReadInputStream cris)

</class A_Sample_Generator>
<class A_Sample_Unpaired>
*@author Brian Bushnell
*@date Oct 17, 2014
public class A_Sample_Unpaired

#Fields
private String in1=null

private String qfin1=null

private String out1=null

private String qfout1=null

private String extin=null

private String extout=null

private long maxReads=-1

private final FileFormat ffin1

private final FileFormat ffout1

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public A_Sample_Unpaired(String[] args)

void process(Timer t)

private boolean process(Read r)

</class A_Sample_Unpaired>
<class BBTool_ST>
*@author Brian Bushnell
*@date Jan 12, 2015
public abstract class BBTool_ST

#Fields
protected String in1=null

protected String in2=null

protected String qfin1=null

protected String qfin2=null

protected String out1=null

protected String out2=null

protected String qfout1=null

protected String qfout2=null

protected String extin=null

protected String extout=null

private ConcurrentReadInputStream cris_primary

private ConcurrentReadOutputStream ros_primary

protected long readsProcessed=0

protected long basesProcessed=0

private long maxReads=-1

protected final FileFormat ffin1

protected final FileFormat ffin2

protected FileFormat ffout1

protected FileFormat ffout2

protected PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

protected boolean overwrite=true

protected boolean append=false


#Methods
*Code entrance from the command line.
*Must be overridden; the commented body is an example.
*@param args Command line arguments
public static void main(String[] args)

*Constructor. Parses argument list and sets relevant fields.
*Must be called by subclass.
*@param args Command line arguments
public BBTool_ST(String[] args)

*Must be overridden if variables are defined at bottom of class file.
protected void setDefaults()

protected void reparse(String[] args)

*Must be overridden; this body is just for example.
*Parses an argument from the command line.
*Assumed to be in "key=value" form, but this is not required.
*@param arg The full original argument.
*@param a Left hand side, to lower case.
*@param b Right hand side, unaltered.
*@return true if a matched some keyword.
public boolean parseArgument(String arg, String a, String b)

*And example of how to override parseArgument.
private boolean parseArgument_EXAMPLE(String arg, String a, String b)

public void process()

*Create read streams and process all data
protected void process(Timer t)

*Create read streams
protected void startup()

*Called before startup().
*Implement if necessary
protected void startupSubclass()

protected final void shutdown(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Called before shutdown().
*Implement if necessary
protected void shutdownSubclass()

protected void showStats(Timer t)

*Called AFTER showStats().
*Implement if necessary
protected void showStatsSubclass(Timer t, long readsIn, long basesIn)

*Iterate through the reads.
*This may optionally be overridden.
protected void processInner(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

*Process a single read pair. Must be overidden.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
protected boolean processReadPair(Read r1, Read r2)

*For sam format
protected boolean useSharedHeader()

</class BBTool_ST>
<interface DoWorker>
public interface DoWorker

#Methods
public void doWork()

</interface DoWorker>
<class ThreadPoolJob>
*@author Brian Bushnell
*@date August 26, 2019
public class ThreadPoolJob

#Fields
public final X x

final ArrayBlockingQueue<X> dest

public Y result


#Methods
public ThreadPoolJob(X x_, ArrayBlockingQueue<X> dest_)

*Process a job
final void doJob()

*Do whatever specific work needs to be done for this job
public Y doWork()

*Retire the job to the destination queue
final void cleanup()

final boolean isPoison()

</class ThreadPoolJob>
<class ThreadWaiter>
public class ThreadWaiter

#Methods
*Wait for all threads to start running
public static final boolean waitForThreadsToStart(Iterable<T> iter)

*Wait for completion of all threads
public static final boolean waitForThreadsToFinish(Iterable<T> iter)

public static final void startThreads(Iterable<T> iter)

*@param iter List of Threads.
*@return success
public static final boolean startAndWait(Iterable<T> iter)

*@param iter List of Threads.
*@return success
public static final boolean startAndWait(Iterable<T> iter, Accumulator<T> acc)

*Wait for completion of all threads, and accumulate results
public static final boolean waitForThreadsToFinish(Iterable<T> iter, Accumulator<T> acc)

*Accumulate results from all threads
private static final boolean accumulate(Iterable<T> iter, Accumulator<T> acc)

</class ThreadWaiter>
