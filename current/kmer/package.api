#version 1
#package kmer
#generated 2025-09-06T20:37:37

<class AbstractKmerTable>
*@author Brian Bushnell
*@date Oct 23, 2013
public abstract class AbstractKmerTable

#Fields
public static boolean FASTA_DUMP=true

public static boolean NUMERIC_DUMP=false

public static boolean TWO_PASS_RESIZE=false

public static final boolean verbose=false

public static final boolean TESTMODE=false

public static final int UNKNOWN=0

public static final int ARRAY1D=1

public static final int FOREST1D=2

public static final int TABLE=3

public static final int NODE1D=4

public static final int ARRAY2D=5

public static final int FOREST2D=6

public static final int TABLE2D=7

public static final int NODE2D=8

public static final int ARRAYH=9

public static final int ARRAYHF=10

public static final int NOT_PRESENT=-1

public static final int HASH_COLLISION=-2

public static final int NO_OWNER=-1

private static final String killMessage=new String("\nThis program ran out of memory.  Try increasing the -Xmx flag and setting prealloc.")


#Methods
*Returns count
public int increment(long kmer, int incr)

*Returns number of entries created. Incr must be positive.
public int incrementAndReturnNumCreated(long kmer, int incr)

public int set(long kmer, int value)

*This is for IntList3 support with HashArrayHybridFast
public int set(long kmer, int[] vals, int vlen)

*Returns number of kmers added
public int setIfNotPresent(long kmer, int value)

*Fetch the value associated with a kmer.
*@param kmer
*@return A value. -1 means the kmer was not present.
public int getValue(long kmer)

*Fetch the values associated with a kmer.
*@param kmer
*@param singleton A blank array of length 1.
*@return An array filled with values. Values of -1 are invalid.
public int[] getValues(long kmer, int[] singleton)

public boolean contains(long kmer)

public final boolean contains(long kmer, int v)

public final boolean contains(long kmer, int[] vals)

public void rebalance()

public long size()

public int arrayLength()

public boolean canRebalance()

public boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

public boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

public boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

public void fillHistogram(long[] ca, int max)

public void fillHistogram(SuperLongList sll)

public void countGC(long[] gcCounts, int max)

public static final int gc(long kmer)

Object get(long kmer)

void resize()

boolean canResize()

*Removes entries with a value of the limit or less.
*Rehashes the remainder.
*@return Number removed.
long regenerate(int limit)

final void lock()

final void unlock()

final boolean tryLock()

Lock getLock()

static final AtomicIntegerArray allocAtomicInt(int len)

static final long[] allocLong1D(int len)

static final long[][] allocLong2D(int mult, int len)

static final int[] allocInt1D(int len)

static final int[][] allocInt2D(int len)

static final KmerNode[] allocKmerNodeArray(int len)

*Set the thread owning this kmer. Return the new owner.
*Will only change the owner if newOwner is greater than current owner.
public int setOwner(long kmer, int newOwner)

*Reset owner to -1 if this is the current owner.
public boolean clearOwner(long kmer, int owner)

*Return the thread ID owning this kmer, or -1.
public int getOwner(long kmer)

*Create data structures needed for ownership representation
public void initializeOwnership()

*Eliminate ownership data structures or set them to -1.
public void clearOwnership()

public static final StringBuilder toText(long kmer, int k)

static final StringBuilder toText(long kmer, int count, int k)

static final ByteBuilder toBytes(long kmer, int count, int k)

static final StringBuilder toText(long kmer, int[] values, int k)

static final ByteBuilder toBytes(long kmer, int[] values, int k)

static final StringBuilder toText(long kmer, int count, int k, StringBuilder sb)

static final StringBuilder toText(long kmer, int[] values, int k, StringBuilder sb)

public static final ByteBuilder toBytes(long kmer, long count, int k, ByteBuilder bb)

public static final ByteBuilder toBytes(long kmer, int[] values, int k, ByteBuilder bb)

static void appendKmerText(long kmer, int count, int k, ByteBuilder bb)

*For buffered tables.
long flush()

*This allocates the data structures in multiple threads. Unfortunately, it does not lead to any speedup, at least for ARRAY type.
*@param ways
*@param tableType
*@param schedule
*@param mask
*@return The preallocated table
public static final AbstractKmerTable[] preallocate(int ways, int tableType, int[] schedule, long mask)

public static final long makeMiddleMask(int k, boolean amino)

public Walker walk()

</class AbstractKmerTable>
<class AbstractKmerTableSet>
*Loads and holds kmers for Tadpole
*@author Brian Bushnell
*@date Jun 22, 2015
public abstract class AbstractKmerTableSet

#Fields
public boolean showStats=true

*Has this class encountered errors while processing?
public boolean errorState=false

*Use a count-min prefilter for low-depth kmers
public boolean prefilter=false

*Fill the prefilter at the same time as the main table
public boolean onePass=false

public boolean amino=false

*Number of hashes used by prefilter
public int prehashes=2

*Fraction of memory used by prefilter
public double prefilterFraction=0.2

*Initial size of data structures
public int initialSize=-1

*Fraction of available memory preallocated to arrays
public double preallocFraction=1.0

public KCountArray prefilterArray=null

public boolean minProbPrefilter=true

public boolean minProbMain=true

*Input reads for kmers
public ArrayList<String> in1=new ArrayList<String>()

*Input reads for kmers
public ArrayList<String> in2=new ArrayList<String>()

*Extra files for use as kmers
public ArrayList<String> extra=new ArrayList<String>()

*Maximum input reads (or pairs) to process. Does not apply to references. -1 means unlimited.
public long maxReads=-1

public int buflen=1000

*Filter kmers up to this level; don't store them in primary data structure
protected int filterMax=0

protected int filterMax2=0

public long readsIn=0

public long basesIn=0

public long lowqReads=0

public long lowqBases=0

public long readsTrimmed=0

public long basesTrimmed=0

public long kmersIn=0

public long kmersLoaded=0

private int currentPass=0

protected int prepasses=1

protected boolean allocated=false

*Print messages to this stream
public static PrintStream outstream=System.err

*Permission to overwrite existing files
public static boolean overwrite=true

*Permission to append to existing files
public static boolean append=false

*Print speed statistics upon completion
public static boolean showSpeed=true

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

*Display kmer loading information
public static boolean DISPLAY_STATS=true

*Verbose messages
public static boolean verbose=false

*Debugging verbose messages
public static boolean verbose2=false

*Number of ProcessThreads
public static int THREADS=Shared.threads()

public static int maxNs=Integer.MAX_VALUE

public static int minLen=0

*Increment owner by this much to indicate claim is final.
public static final int CLAIM_OFFSET=100000

*Default initial table size
public static final int initialSizeDefault=128000

public static final float[] PROB_CORRECT=Arrays.copyOf(align2.QualityTools.PROB_CORRECT,127)

public static final float[] PROB_CORRECT_INVERSE=Arrays.copyOf(align2.QualityTools.PROB_CORRECT_INVERSE,127)

public static boolean IGNORE_UNKNOWN_ARGS=true

public static final int NOT_PRESENT=AbstractKmerTable.NOT_PRESENT

public static final int HASH_COLLISION=AbstractKmerTable.HASH_COLLISION

public static final int NO_OWNER=AbstractKmerTable.NO_OWNER

public static double defaultMinprob=0

*IIRC this has to do with allowing 32-mers
public static boolean MASK_CORE=false

public static boolean MASK_MIDDLE=false

public static boolean FAST_FILL=true


#Methods
public static final boolean isValidArgument(String a)

public final void process(Timer t)

public void clear()

public final long processInput()

public final KCountArray makePrefilter(KCountArray[] filter, Timer ht)

public final void showStats(Timer t, long added)

private final long loadKmers()

*Load reads into tables, using multiple LoadThread.
public long loadKmers(String fname1, String fname2)

public long regenerate(int limit)

public Object getTable(int tnum)

public long[] fillHistogram(int histMax)

public void countGC(long[] gcCounts, int max)

public final long[] fillGcCounts(int histMax)

public final float[] makeGcHistogram(long[] counts, long[] gcCounts)

public void initializeOwnership()

public void clearOwnership()

public int ways()

public final int fillCounts(byte[] bases, IntList counts, Kmer kmer)

public int fillSpecificCounts(byte[] bases, IntList counts, BitSet positions, Kmer kmer)

public int regenerateCounts(byte[] bases, IntList counts, Kmer kmer, BitSet changed)

public boolean dumpKmersAsBytes(String fname, int mincount, int maxcount, boolean printTime, AtomicLong remaining)

public boolean dumpKmersAsBytes_MT(String fname, int mincount, int maxcount, boolean printTime, AtomicLong remaining)

public final long[][] makeKhist(String fname, int cols, int max, boolean printHeader, boolean printZeros, boolean printTime, boolean smooth, boolean calcGC, boolean doLogScale, double logWidth, int logPasses, int smoothRadius)

public int kbig()

public long filterMemory(int pass)

public long tableMemory()

public long estimatedKmerCapacity()

public boolean ecco()

public boolean qtrimLeft()

public boolean qtrimRight()

public float minAvgQuality()

public final int filterMax()

public boolean rcomp()

protected void allocateTables()

</class AbstractKmerTableSet>
<class DumpThread>
*@author Brian Bushnell
*@date Nov 16, 2015
public class DumpThread

#Fields
final int k

final int mincount

final int maxcount

final AtomicLong remaining

final AtomicInteger nextTable

final AbstractKmerTable[] tables

final ByteStreamWriter bsw

boolean success=false

public static int NUM_THREADS=-1


#Methods
public static boolean dump(int k, int mincount, int maxcount, AbstractKmerTable[] tables, ByteStreamWriter bsw, AtomicLong remaining)

public DumpThread(int k_, int mincount_, int maxcount_, AtomicInteger nextTable_, AbstractKmerTable[] tables_, ByteStreamWriter bsw_, AtomicLong toDump_)

@Override public void run()

</class DumpThread>
<class HashArray>
*Stores kmers in a long[] and values in an int[][], with a victim cache.
*@author Brian Bushnell
*@date Nov 7, 2014
public abstract class HashArray

#Fields
AtomicIntegerArray owners

long[] array

int prime

long size=0

long sizeLimit

final HashForest victims

final boolean autoResize

public final boolean twoD

private final Lock lock=new ReentrantLock()

private final long coreMask

private final long coreMask2

protected final int[] schedule

private int schedulePos=0

static final int victimRatio=16

static final int extra=60

static final int maxPrime=Primes.primeAtMost(Integer.MAX_VALUE - extra - 20)

static final float resizeMult=2f

static final float minLoadFactor=0.58f

static final float maxLoadFactor=0.88f

static final float maxLoadFactorFinal=0.95f

static final float minLoadMult=1 / minLoadFactor

static final float maxLoadMult=1 / maxLoadFactor


#Methods
HashArray(int[] schedule_, long coreMask_, boolean twod_)

HashArray(int initialSize, long coreMask_, boolean autoResize_, boolean twod_)

public final int kmerToCell(long kmer)

@Override public final int set(long kmer, int[] v, int vlen)

@Override public final int set(long kmer, int v)

@Override public final int setIfNotPresent(long kmer, int value)

@Override public final int getValue(long kmer)

public final int getValue(long kmer, int startCell)

@Override public final int[] getValues(long kmer, int[] singleton)

@Override public final boolean contains(long kmer)

public final long getKmer(int cell)

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

public final int setOwner(long kmer, int newOwner, int cell)

@Override public final boolean clearOwner(long kmer, int owner)

public final boolean clearOwner(long kmer, int owner, int cell)

@Override public final int getOwner(long kmer)

public final int getCellOwner(int cell)

protected void insertValue(long kmer, int v, int cell)

*This is for IntList3 support with HashArrayHybridFast
protected void insertValue(long kmer, int[] vals, int cell, int vlen)

protected int readCellValue(int cell)

protected int[] readCellValues(int cell, int[] singleton)

@Override final Object get(long kmer)

final int findKmer(long kmer)

final int findKmer(long kmer, int startCell)

final int findKmerOrEmpty(long kmer)

@Override final boolean canResize()

@Override public final long size()

@Override public final int arrayLength()

@Override protected void resize()

@Override public final boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

@Override public final boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final void fillHistogram(long[] ca, int max)

@Override public void fillHistogram(SuperLongList sll)

@Override public final void countGC(long[] gcCounts, int max)

public HashForest victims()

protected int nextScheduleSize()

protected boolean atMaxSize()

public long[] array()

public AtomicIntegerArray owners()

@Override final Lock getLock()

</class HashArray>
<class HashArray1D>
*Stores kmers in a long[] and counts in an int[], with a victim cache.
*@author Brian Bushnell
*@date Oct 25, 2013
public final class HashArray1D

#Fields
private int[] values

private static final int NOT_XPRESENT=0


#Methods
public HashArray1D(int[] schedule_, long coreMask_)

public HashArray1D(int initialSize, long coreMask, boolean autoResize_)

@Override public final int increment(long kmer, int incr)

@Override public final int incrementAndReturnNumCreated(long kmer, int incr)

@Override public void fillHistogram(SuperLongList sll)

@Override public final int readCellValue(int cell)

@Override protected final int[] readCellValues(int cell, int[] singleton)

@Override protected final void insertValue(long kmer, int v, int cell)

@Override protected final void insertValue(long kmer, int[] vals, int cell, int vlen)

@Override public final boolean canRebalance()

@Override protected void resize()

@Deprecated @Override public void rebalance()

@Override public long regenerate(int limit)

@Override public String toString()

public Walker walk()

public int[] values()

public long calcMem()

</class HashArray1D>
<class HashArray1D.Walker1D>
public class HashArray1D.Walker1D

#Fields
*Hash map over which this is walking
private HashArray1D ha

*Victim list of the hash map
private ArrayList<KmerNode> victims

private long kmer

private int value

*Potential next kmer cell; may point to an empty cell
private int i=0

*Next victim in list
private int i2=0


#Methods
Walker1D()

*Fills this object with the next key and value.
*@return True if successful.
public boolean next()

public long kmer()

public int value()

</class HashArray1D.Walker1D>
<class HashArray2D>
*Stores kmers in a long[] and values in an int[][], with a victim cache.
*@author Brian Bushnell
*@date Nov 7, 2014
public final class HashArray2D

#Fields
private int[][] values


#Methods
public HashArray2D(int[] schedule_, long coreMask_)

@Deprecated @Override public int increment(long kmer, int incr)

@Deprecated @Override public int incrementAndReturnNumCreated(long kmer, int incr)

@Override protected final int readCellValue(int cell)

@Override protected final int[] readCellValues(int cell, int[] singleton)

*Returns number of values added
@Override protected final void insertValue(long kmer, int v, int cell)

*Returns number of values added
@Override protected final void insertValue(long kmer, int[] vals, int cell, int vlen)

@Override public final boolean canRebalance()

@Override protected void resize()

@Deprecated @Override public void rebalance()

@Deprecated @Override public long regenerate(int limit)

</class HashArray2D>
<class HashArrayHybrid>
*Stores kmers in a long[] and counts in an int[], with a victim cache.
*@author Brian Bushnell
*@date Oct 25, 2013
public final class HashArrayHybrid

#Fields
private int[] values

private IntList2 setList


#Methods
public HashArrayHybrid(int[] schedule_, long coreMask_)

@Override public final int increment(long kmer, int incr)

@Override public final int incrementAndReturnNumCreated(long kmer, int incr)

@Override protected final int readCellValue(int cell)

@Override protected final int[] readCellValues(int cell, int[] singleton)

@Override protected final void insertValue(long kmer, int[] vals, int cell, int vlen)

@Override protected final void insertValue(long kmer, int v, int cell)

@Deprecated private final int insertIntoListOld(int v, int loc)

private final int insertIntoList(int v, int loc)

@Override public final boolean canRebalance()

@Override protected void resize()

@Deprecated @Override public void rebalance()

@Deprecated @Override public long regenerate(int limit)

</class HashArrayHybrid>
<class HashArrayHybridFast>
*Stores kmers in a long[] and counts in an int[], with a victim cache.
*@author Brian Bushnell
*@date Oct 25, 2013
public final class HashArrayHybridFast

#Fields
private int[] values

private IntList3 setList


#Methods
public HashArrayHybridFast(int[] schedule_, long coreMask_)

@Override public final int increment(long kmer, int incr)

@Override public final int incrementAndReturnNumCreated(long kmer, int incr)

@Override protected final int readCellValue(int cell)

@Override protected final int[] readCellValues(int cell, int[] singleton)

@Override protected final void insertValue(long kmer, int[] vals, int cell, int vlen)

@Override protected final void insertValue(long kmer, int v, int cell)

private final int insertIntoList(int v, int loc)

@Override public final boolean canRebalance()

@Override protected void resize()

@Deprecated @Override public void rebalance()

@Deprecated @Override public long regenerate(int limit)

</class HashArrayHybridFast>
<class HashBuffer>
*@author Brian Bushnell
*@date Nov 22, 2013
public class HashBuffer

#Fields
private final AbstractKmerTable[] tables

private final int buflen

private final int halflen

private final int ways

private final boolean useValues

private final KmerBuffer[] buffers

private final long coreMask

private final long middleMask

private final long cmMask

public long uniqueAdded=0

private static final int SIZEMASK=15

private final boolean setIfNotPresent

public static boolean SORT_BUFFERS=false


#Methods
public HashBuffer(AbstractKmerTable[] tables_, int buflen_, int k_, boolean initValues, boolean setIfNotPresent_)

public final int kmerToWay(long kmer)

@Override public int incrementAndReturnNumCreated(long kmer, int incr)

@Override public final long flush()

@Override public int set(long kmer, int value)

@Override public int set(long kmer, int[] vals, int vlen)

@Override public int setIfNotPresent(long kmer, int value)

@Override public int getValue(long kmer)

@Override public int[] getValues(long kmer, int[] singleton)

@Override public boolean contains(long kmer)

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

@Override public final boolean clearOwner(long kmer, int owner)

@Override public final int getOwner(long kmer)

@Override Object get(long kmer)

private int dumpBuffer(int way, boolean force)

private int dumpBuffer_inner(int way)

@Override final boolean canResize()

@Override public final boolean canRebalance()

@Deprecated @Override public long size()

@Deprecated @Override public int arrayLength()

@Deprecated @Override void resize()

@Deprecated @Override public void rebalance()

@Override public long regenerate(int limit)

@Override public boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

@Override public boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override @Deprecated public boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override @Deprecated public void fillHistogram(long[] ca, int max)

@Override @Deprecated public void fillHistogram(SuperLongList sll)

@Override public void countGC(long[] gcCounts, int max)

@Override public int increment(long kmer, int incr)

</class HashBuffer>
<class HashForest>
*@author Brian Bushnell
*@date Oct 23, 2013
public final class HashForest

#Fields
KmerNode[] array

int prime

long size=0

long sizeLimit

final boolean autoResize

final boolean TWOD

private final Lock lock=new ReentrantLock()

static final int maxPrime=(int)Primes.primeAtMost(Integer.MAX_VALUE)

static final float resizeMult=2.5f

static final float minLoadFactor=0.75f

static final float maxLoadFactor=2.5f

static final float minLoadMult=1 / minLoadFactor

static final float maxLoadMult=1 / maxLoadFactor


#Methods
public HashForest(int initialSize, boolean autoResize_)

public HashForest(int initialSize, boolean autoResize_, boolean twod_)

private KmerNode makeNode(long kmer, int val)

private KmerNode makeNode(long kmer, int[] vals, int vlen)

@Override public int increment(long kmer, int incr)

@Override public int incrementAndReturnNumCreated(long kmer, int incr)

@Override public int set(long kmer, int value)

@Override public int set(long kmer, int[] vals, int vlen)

@Override public int setIfNotPresent(long kmer, int value)

@Override public final int getValue(long kmer)

@Override public int[] getValues(long kmer, int[] singleton)

@Override public boolean contains(long kmer)

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

@Override public final boolean clearOwner(long kmer, int owner)

@Override public final int getOwner(long kmer)

@Override final KmerNode get(long kmer)

public final KmerNode getNode(int cell)

boolean insert(KmerNode n)

@Override boolean canResize()

@Override public boolean canRebalance()

@Override public long size()

@Override public int arrayLength()

@Override void resize()

@Override public void rebalance()

public void clear()

@Override long regenerate(int limit)

@Override public boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

@Override public boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public void fillHistogram(long[] ca, int max)

@Override public final void fillHistogram(SuperLongList sll)

@Override public void countGC(long[] gcCounts, int max)

@Override public Iterator<KmerNode> iterator()

public ArrayList<KmerNode> toList()

public KmerNode[] array()

@Override final Lock getLock()

</class HashForest>
<class HistogramMaker>
public final class HistogramMaker

#Methods
public static long[] fillHistogram(AbstractKmerTable[] tables, int histMax)

private static long[] fillHistogram_ST(AbstractKmerTable[] tables, int histMax)

private static long[] fillHistogram_MT(AbstractKmerTable[] tables, int histMax)

</class HistogramMaker>
<class KmerBuffer>
*@author Brian Bushnell
*@date Jul 30, 2015
public class KmerBuffer

#Fields
private final int k

final LongList kmers

final IntList values


#Methods
public KmerBuffer(int buflen, int k_, boolean initValues)

public int add(long kmer)

public int addMulti(long kmer, int times)

public int add(long kmer, int value)

public void clear()

final int size()

@Override public String toString()

</class KmerBuffer>
<class KmerLink>
*@author Brian Bushnell
*@date Oct 22, 2013
public class KmerLink

#Fields
long pivot

int value

int owner=-1

KmerLink next


#Methods
public KmerLink(long pivot_)

public KmerLink(long pivot_, int value_)

@Override public final int incrementAndReturnNumCreated(long kmer, int incr)

@Override public int increment(long kmer, int incr)

*Returns number of nodes added
@Override public int set(long kmer, int value_)

*Returns number of nodes added
@Override public int setIfNotPresent(long kmer, int value_)

@Override KmerLink get(long kmer)

boolean insert(KmerLink n)

@Override public boolean contains(long kmer)

void traversePrefix(ArrayList<KmerLink> list)

void traverseInfix(ArrayList<KmerLink> list)

@Override boolean canResize()

@Override public boolean canRebalance()

@Deprecated @Override public int arrayLength()

@Deprecated @Override void resize()

@Deprecated @Override public void rebalance()

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

@Override public final boolean clearOwner(long kmer, int owner)

@Override public final int getOwner(long kmer)

@Override public int set(long kmer, int[] vals, int vlen)

@Override public final int getValue(long kmer)

@Override public final int[] getValues(long kmer, int[] singleton)

@Override public final long size()

@Override public final boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

private final StringBuilder dumpKmersAsText(StringBuilder sb, int k, int mincount, int maxcount)

@Override public final void fillHistogram(long[] ca, int max)

@Override public final void fillHistogram(SuperLongList sll)

@Override public void countGC(long[] gcCounts, int max)

KmerLink rebalance(ArrayList<KmerLink> list)

private static KmerLink rebalance(ArrayList<KmerLink> list, int a, int b)

@Deprecated @Override public long regenerate(int limit)

</class KmerLink>
<class KmerNode>
*@author Brian Bushnell
*@date Oct 22, 2013
public abstract class KmerNode

#Fields
long pivot

int owner=-1

KmerNode left

KmerNode right


#Methods
protected KmerNode(long pivot_)

public KmerNode makeNode(long pivot_, int value_)

public KmerNode makeNode(long pivot_, int[] values_, int vlen_)

@Override public final int increment(long kmer, int incr)

@Override public final int incrementAndReturnNumCreated(long kmer, int incr)

*Returns number of nodes added
@Override public final int set(long kmer, int value)

*Returns number of nodes added
@Override public final int setIfNotPresent(long kmer, int value)

@Override public final int getValue(long kmer)

@Override public final int[] getValues(long kmer, int[] singleton)

@Override public final boolean contains(long kmer)

public KmerNode left()

public KmerNode right()

public long pivot()

public int owner()

public int count()

protected int value()

protected int[] values(int[] singleton)

*Returns new value
public int set(int value_)

protected int set(int[] values_, int vlen)

@Override final KmerNode get(long kmer)

final KmerNode getNodeOrParent(long kmer)

final boolean insert(KmerNode n)

final void traversePrefix(ArrayList<KmerNode> list)

final void traverseInfix(ArrayList<KmerNode> list)

@Override public final long size()

final KmerNode rebalance(ArrayList<KmerNode> list)

private static final KmerNode rebalance(ArrayList<KmerNode> list, int a, int b)

@Override public long regenerate(int limit)

@Override public final boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

protected StringBuilder dumpKmersAsText(StringBuilder sb, int k, int mincount, int maxcount)

protected ByteBuilder dumpKmersAsText(ByteBuilder bb, int k, int mincount, int maxcount)

@Override public final void fillHistogram(long[] ca, int max)

@Override public final void fillHistogram(SuperLongList sll)

boolean TWOD()

int numValues()

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

@Override public final boolean clearOwner(long kmer, int owner)

@Override public final int getOwner(long kmer)

public long calcMem()

</class KmerNode>
<class KmerNode1D>
*@author Brian Bushnell
*@date Oct 22, 2013
public class KmerNode1D

#Fields
int value


#Methods
public KmerNode1D(long pivot_)

public KmerNode1D(long pivot_, int value_)

@Override public final KmerNode makeNode(long pivot_, int value_)

@Override public final KmerNode makeNode(long pivot_, int[] values_, int vlen)

@Override public final int set(long kmer, int[] vals, int vlen)

@Override public int value()

@Override protected int[] values(int[] singleton)

@Override public int set(int value_)

@Override protected int set(int[] values_, int vlen)

@Override int numValues()

@Override boolean canResize()

@Override public boolean canRebalance()

@Deprecated @Override public int arrayLength()

@Deprecated @Override void resize()

@Deprecated @Override public void rebalance()

@Override public final boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override protected final StringBuilder dumpKmersAsText(StringBuilder sb, int k, int mincount, int maxcount)

@Override protected final ByteBuilder dumpKmersAsText(ByteBuilder bb, int k, int mincount, int maxcount)

@Override final boolean TWOD()

</class KmerNode1D>
<class KmerNode2D>
*Allows multiple values per kmer.
*@author Brian Bushnell
*@date Nov 7, 2014
public class KmerNode2D

#Fields
int[] values

private int numValues

private static final int slowAddLimit=4


#Methods
public KmerNode2D(long pivot_)

public KmerNode2D(long pivot_, int value_)

public KmerNode2D(long pivot_, int[] vals_, int vlen)

@Override public final KmerNode makeNode(long pivot_, int value_)

@Override public final KmerNode makeNode(long pivot_, int[] values_, int vlen)

*Returns number of nodes added
@Override public int set(long kmer, int vals, int vlen)

@Override protected int value()

@Override protected int[] values(int[] singleton)

@Override public int set(int value_)

@Override protected int set(int[] values_, int vlen)

@Override int numValues()

*Returns number of values added
private int insertValue(int v)

*Returns number of values added
private int insertValue(int[] vals, int vlen)

private final int countValues(int[] vals)

private final int insertIntoList(int v)

@Override boolean canResize()

@Override public boolean canRebalance()

@Deprecated @Override public int arrayLength()

@Deprecated @Override void resize()

@Deprecated @Override public void rebalance()

@Override public final boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Override public final boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Override protected final StringBuilder dumpKmersAsText(StringBuilder sb, int k, int mincount, int maxcount)

@Override protected final ByteBuilder dumpKmersAsText(ByteBuilder bb, int k, int mincount, int maxcount)

@Override final boolean TWOD()

</class KmerNode2D>
<class KmerTable>
*@author Brian Bushnell
*@date Oct 23, 2013
public final class KmerTable

#Fields
KmerLink[] array

int prime

long size=0

long sizeLimit

final boolean autoResize

private final Lock lock=new ReentrantLock()

static final int maxPrime=(int)Primes.primeAtMost(Integer.MAX_VALUE)

static final float resizeMult=2f

static final float minLoadFactor=0.5f

static final float maxLoadFactor=0.98f

static final float minLoadMult=1 / minLoadFactor

static final float maxLoadMult=1 / maxLoadFactor


#Methods
public KmerTable(int initialSize, boolean autoResize_)

@Override public int incrementAndReturnNumCreated(long kmer, int incr)

@Override public int set(long kmer, int value)

@Override public int set(long kmer, int[] vals, int vlen)

@Override public int setIfNotPresent(long kmer, int value)

@Override public int getValue(long kmer)

@Override public int[] getValues(long kmer, int[] singleton)

@Override public boolean contains(long kmer)

@Override public final void initializeOwnership()

@Override public final void clearOwnership()

@Override public final int setOwner(long kmer, int newOwner)

@Override public final boolean clearOwner(long kmer, int owner)

@Override public final int getOwner(long kmer)

@Override KmerLink get(long kmer)

boolean insert(KmerLink n)

@Override boolean canResize()

@Override public boolean canRebalance()

@Override public long size()

@Override public int arrayLength()

@Override void resize()

@Override public void rebalance()

@Deprecated @Override public boolean dumpKmersAsText(TextStreamWriter tsw, int k, int mincount, int maxcount)

@Override public boolean dumpKmersAsBytes_MT(ByteStreamWriter bsw, ByteBuilder bb, int k, int mincount, int maxcount, AtomicLong remaining)

@Deprecated @Override public boolean dumpKmersAsBytes(ByteStreamWriter bsw, int k, int mincount, int maxcount, AtomicLong remaining)

@Deprecated @Override public void fillHistogram(long[] ca, int max)

@Deprecated @Override public void fillHistogram(SuperLongList sll)

@Deprecated @Override public void countGC(long[] gcCounts, int max)

@Deprecated @Override public long regenerate(int limit)

@Override final Lock getLock()

</class KmerTable>
<class KmerTableSet>
*Loads and holds kmers for Tadpole
*@author Brian Bushnell
*@date Jun 22, 2015
public class KmerTableSet

#Fields
*Hold kmers. A kmer X such that X%WAYS=Y will be stored in tables[Y]
private AbstractKmerTable[] tables

public long filterMemoryOverride=0

public final int tableType

private final int bytesPerKmer

private final long usableMemory

private final long filterMemory0

private final long filterMemory1

private final long tableMemory

private final long estimatedKmerCapacity

*Number of tables (and threads, during loading)
private final boolean prealloc

*Number of tables (and threads, during loading)
public final int ways

*Normal kmer length
public final int k

*k-1; used in some expressions
public final int k2

public final long coreMask

public final long middleMask

public final long cmMask

*Look for reverse-complements as well as forward kmers. Default: true
private final boolean rcomp

*Quality-trim the left side
public final boolean qtrimLeft

*Quality-trim the right side
public final boolean qtrimRight

*Trim bases at this quality or below. Default: 4
public final float trimq

*Error rate for trimming (derived from trimq)
private final float trimE

*Throw away reads below this average quality after trimming. Default: 0
public final float minAvgQuality

*If positive, calculate average quality from the first X bases only. Default: 0
public final int minAvgQualityBases

*Ignore kmers with probability of correctness less than this
public final float minProb

*Correct via overlap
private final boolean ecco

*Attempt to merge via overlap prior to counting kmers
private final boolean merge


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
private KmerTableSet(String[] args)

*Constructor.
*@param args Command line arguments
public KmerTableSet(String[] args, int bytesPerKmer_)

@Override public void clear()

@Override public void allocateTables()

*Load reads into tables, using multiple LoadThread.
@Override public long loadKmers(String fname1, String fname2)

public void regenerateKmers(byte[] bases, LongList kmers, IntList counts, int a)

@Override public int regenerateCounts(byte[] bases, IntList counts, Kmer dummy, BitSet changed)

@Override public int fillSpecificCounts(byte[] bases, IntList counts, BitSet positions, Kmer dummy)

public int regenerateCounts(byte[] bases, IntList counts, int ca)

*Returns number of valid kmers
public int fillKmers(byte[] bases, LongList kmers)

public void fillCounts(LongList kmers, IntList counts)

@Override public long regenerate(int limit)

public HashArray1D getTableForKey(long key)

@Override public HashArray1D getTable(int tnum)

@Override public long[] fillHistogram(int histMax)

@Override public void countGC(long[] gcCounts, int max)

@Override public void initializeOwnership()

@Override public void clearOwnership()

public long rightmostKmer(ByteBuilder bb)

public long rightmostKmer(byte[] bases, int blen)

public long leftmostKmer(ByteBuilder bb)

public long leftmostKmer(byte[] bases, int blen)

public boolean doubleClaim(ByteBuilder bb, int id)

*Ensures there can be only one owner.
public boolean doubleClaim(byte[] bases, int blength, int id)

public boolean claim(ByteBuilder bb, int id, boolean exitEarly)

public float calcCoverage(byte[] bases, int blength)

public float calcCoverage(Contig contig)

public boolean claim(byte[] bases, int blength, int id, boolean exitEarly)

public boolean claim(long kmer, long rkmer, int id)

public void release(ByteBuilder bb, int id)

public void release(byte[] bases, int blength, int id)

public boolean release(long kmer, long rkmer, int id)

public boolean release(long key, int id)

public int findOwner(ByteBuilder bb, int id)

public int findOwner(byte[] bases, int blength, int id)

public int findOwner(long kmer)

public int findOwner(long kmer, long rkmer)

public int getCount(long kmer, long rkmer)

public int getCount(long key)

public int fillRightCounts(long kmer, long rkmer, int[] counts, long mask, int shift2)

public int fillRightCounts_fast(long kmer0, long rkmer0, int[] counts, long mask, int shift2)

public int fillRightCounts_safe(long kmer, long rkmer, int[] counts, long mask, int shift2)

*For KmerCompressor.
public int fillRightCountsRcompOnly(long kmer, long rkmer, int[] counts, long mask, int shift2)

public int fillLeftCounts(long kmer, long rkmer, int[] counts, long mask, int shift2)

public int fillLeftCounts_fast(long kmer0, long rkmer0, int[] counts, long mask, int shift2)

public int fillLeftCounts_safe(long kmer0, long rkmer0, int[] counts, long mask, int shift2)

@Override public boolean dumpKmersAsBytes(String fname, int mincount, int maxcount, boolean printTime, AtomicLong remaining)

@Override public boolean dumpKmersAsBytes_MT(String fname, int mincount, int maxcount, boolean printTime, AtomicLong remaining)

private final long rcomp(long kmer)

private final StringBuilder toText(long kmer)

*Transforms a kmer into a canonical value stored in the table. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@return Canonical value
public final long toValue(long kmer, long rkmer)

@Override public int kbig()

@Override public long filterMemory(int pass)

@Override public boolean ecco()

@Override public boolean qtrimLeft()

@Override public boolean qtrimRight()

@Override public float minAvgQuality()

@Override public long tableMemory()

@Override public long estimatedKmerCapacity()

@Override public int ways()

@Override public boolean rcomp()

public final int kmerToWay(long kmer)

public AbstractKmerTable[] tables()

public Walker walk()

</class KmerTableSet>
<class KmerTableSet.WalkerKST>
public class KmerTableSet.WalkerKST

#Fields
private Walker w=null

*current table number
private int tnum=0


#Methods
WalkerKST()

*Fills this object with the next key and value.
*@return True if successful.
public boolean next()

public long kmer()

public int value()

</class KmerTableSet.WalkerKST>
<class OwnershipThread>
public class OwnershipThread

#Fields
private final AbstractKmerTable[] tables

private final AtomicInteger next

private final int mode

public static final int INITIALIZE=0

public static final int CLEAR=1


#Methods
public static void clear(AbstractKmerTable[] tables)

public static void initialize(AbstractKmerTable[] tables)

private static void process(AbstractKmerTable[] tables, int mode)

public OwnershipThread(AbstractKmerTable[] tables_, int mode_, AtomicInteger next_)

@Override public void run()

</class OwnershipThread>
<class ScheduleMaker>
public class ScheduleMaker

#Fields
final double resizeMult=5.0

final double resizeMult2=3.0

final double invResizeMult=1 / resizeMult

final double invResizeMult2=1 / resizeMult2

final double lastSizeFraction

final long memory=Runtime.getRuntime().maxMemory()

final double xmsRatio=Shared.xmsRatio()

final long usableMemory=(long)Tools.max(((memory - 96000000) * (xmsRatio > 0.97 ? 0.82 : 0.72)),memory * 0.45)

final long filterMemoryOverride=0

final long filterMemory0

final long filterMemory1

final long tableMemory

final double prefilterFraction

final int prepasses

final boolean prefilter

final int bytesPerKmer

public final long estimatedKmerCapacity

public final int ways

final int initialSize

final int maxSize

final boolean prealloc

final float memRatio

static final int initialSizeDefault=128000

static final int maxPrime=(int)Primes.primeAtMost(Integer.MAX_VALUE - 100 - 20)


#Methods
public ScheduleMaker(int ways_, int bytesPerKmer_, boolean prealloc_, double memRatio_)

public ScheduleMaker(int ways_, int bytesPerKmer_, boolean prealloc_, double memRatio_, int initialSize_)

public ScheduleMaker(int ways_, int bytesPerKmer_, boolean prealloc_, double memRatio_, int initialSize_, int prepasses_, double prefilterFraction_, long filterMemoryOverride_)

public int[] makeSchedule()

</class ScheduleMaker>
<class SimpleKmerTable>
public class SimpleKmerTable

#Methods
public SimpleKmerTable(int initialSize)

</class SimpleKmerTable>
<class TableLoaderLockFree>
*@author Brian Bushnell
*@date Mar 4, 2015
public class TableLoaderLockFree

#Fields
ScheduleMaker scheduleMaker=new ScheduleMaker(WAYS,12,false,0.8)

int[] schedule=scheduleMaker.makeSchedule()

*Has this class encountered errors while processing?
public boolean errorState=false

*How to associate values with kmers
private int storeMode=SET_IF_NOT_PRESENT

*Hold kmers. A kmer X such that X%WAYS=Y will be stored in keySets[Y]
public AbstractKmerTable[] tables

*A scaffold's name is stored at scaffoldNames.get(id).
*scaffoldNames[0] is reserved, so the first id is 1.
public ArrayList<String> scaffoldNames

*Names of reference files (refNames[0] is valid).
public ArrayList<String> refNames

*Number of scaffolds per reference.
public int[] refScafCounts

*scaffoldLengths[id] stores the length of that scaffold
public IntList scaffoldLengths=new IntList()

*Make the middle base in a kmer a wildcard to improve sensitivity
public final boolean maskMiddle=false

*Correct errors via read overlap
public boolean ecc=false

*Store reference kmers with up to this many substitutions
public final int hammingDistance

*Store reference kmers with up to this many edits (including indels)
public final int editDistance

*Store short reference kmers with up to this many substitutions
public int hammingDistance2=-1

*Store short reference kmers with up to this many edits (including indels)
public int editDistance2=-1

*Always skip at least this many consecutive kmers when hashing reference.
*1 means every kmer is used, 2 means every other, etc.
private int minRefSkip=0

*Never skip more than this many consecutive kmers when hashing reference.
private int maxRefSkip=0

private boolean variableRefSkip=false

long refReads=0

long refBases=0

long refKmers=0

long storedKmers=0

*Look for reverse-complements as well as forward kmers. Default: true
private final boolean rcomp

*AND bitmask with 0's at the middle base
private final long middleMask

*Normal kmer length
private final int k

*k-1; used in some expressions
private final int k2

*Shortest kmer to use for trimming
private final int mink

*Attempt to match kmers shorter than normal k on read ends when doing kTrimming.
private final boolean useShortKmers

*Fraction of kmers to skip, 0 to 16 out of 17
private final int speed

*Default initial size of data structures
private static final int initialSizeDefault=128000

*Number of tables (and threads, during loading)
private static final int WAYS=7

*Verbose messages
public static final boolean verbose=false

*Print messages to this stream
private static PrintStream outstream=System.err

*Display progress messages such as memory usage
public static boolean DISPLAY_PROGRESS=true

*Indicates end of input stream
private static final ArrayList<Read> POISON=new ArrayList<Read>(0)

*Make unambiguous copies of ref sequences with ambiguous bases
public static boolean REPLICATE_AMBIGUOUS=false

*x&clearMasks[i] will clear base i
private static final long[] clearMasks

*x|setMasks[i][j] will set base i to j
private static final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
private static final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
private static final long[] rightMasks

*x|kMasks[i] will set the bit to the left of the leftmost base
private static final long[] kMasks

public static final int SET_IF_NOT_PRESENT=1

public static final int SET_ALWAYS=2

public static final int INCREMENT=3


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

public TableLoaderLockFree(AbstractKmerTable[] tables_, int k_)

public TableLoaderLockFree(AbstractKmerTable[] tables_, int k_, int mink_, int speed_, int hdist_, int edist_, boolean rcomp_, boolean maskMiddle_)

public static AbstractKmerTable[] makeTables(int tableType, int bytesPerKmer, long coreMask, boolean prealloc, double memRatio)

public long processData(String[] ref, String[] literal, boolean keepNames, boolean useRefNames, boolean ecc_)

public void setRefSkip(int x)

public void setRefSkip(int min, int max)

public void storeMode(int x)

*Fills tables with kmers from references, using multiple LoadThread.
*@return Number of kmers stored.
private long spawnLoadThreads(String[] ref, String[] literal)

*Fills the scaffold names array with reference names.
public void toRefNames()

*Transforms a kmer into a canonical value stored in the table. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param lengthMask Bitmask with single '1' set to left of kmer
*@return Canonical value
private final long toValue(long kmer, long rkmer, long lengthMask)

final boolean passesSpeed(long key)

final boolean failsSpeed(long key)

</class TableLoaderLockFree>
<class TableReader>
*@author Brian Bushnell
*@date Mar 5, 2015
public class TableReader

#Fields
*Has this class encountered errors while processing?
public boolean errorState=false

*Make the middle base in a kmer a wildcard to improve sensitivity
public final boolean maskMiddle=false

*Search for query kmers with up to this many substitutions
private final int qHammingDistance

*Search for short query kmers with up to this many substitutions
public int qHammingDistance2=-1

*Trim this much extra around matched kmers
public int trimPad=0

*If positive, only look for kmer matches in the leftmost X bases
public int restrictLeft=0

*If positive, only look for kmer matches the rightmost X bases
public int restrictRight=0

*Don't allow a read 'N' to match a reference 'A'.
*Reduces sensitivity when hdist>0 or edist>0. Default: false.
public boolean forbidNs=false

*Replace bases covered by matched kmers with this symbol
public byte trimSymbol='N'

*Convert masked bases to lowercase
public boolean kmaskLowercase=false

*Don't look for kmers in read 1
public boolean skipR1=false

*Don't look for kmers in read 2
public boolean skipR2=false

*A read must contain at least this many kmer hits before being considered a match. Default: 1
public int minHits=1

public int[] countArray

private final IntList idList=new IntList()

private final IntList countList=new IntList()

*Look for reverse-complements as well as forward kmers. Default: true
private final boolean rcomp

*AND bitmask with 0's at the middle base
private final long middleMask

*Normal kmer length
private final int k

*k-1; used in some expressions
private final int k2

*Shortest kmer to use for trimming
private final int mink

*Attempt to match kmers shorter than normal k on read ends when doing kTrimming.
private final boolean useShortKmers

*Fraction of kmers to skip, 0 to 15 out of 16
private final int speed

*Skip this many kmers when examining the read. Default 1.
*1 means every kmer is used, 2 means every other, etc.
private final int qSkip

*noAccel is true if speed and qSkip are disabled, accel is the opposite.
private final boolean noAccel

*noAccel is true if speed and qSkip are disabled, accel is the opposite.
private final boolean accel

*Number of tables (and threads, during loading)
private static final int WAYS=7

*Verbose messages
public static final boolean verbose=false

*Print messages to this stream
private static PrintStream outstream=System.err

*x&clearMasks[i] will clear base i
private static final long[] clearMasks

*x|setMasks[i][j] will set base i to j
private static final long[][] setMasks

*x&leftMasks[i] will clear all bases to the right of i (exclusive)
private static final long[] leftMasks

*x&rightMasks[i] will clear all bases to the left of i (inclusive)
private static final long[] rightMasks

*x|kMasks[i] will set the bit to the left of the leftmost base
private static final long[] lengthMasks


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

public TableReader(int k_)

public TableReader(int k_, int mink_, int speed_, int qskip_, int qhdist_, boolean rcomp_, boolean maskMiddle_)

*Mask a read to cover matching kmers.
*@param r Read to process
*@param sets Kmer tables
*@return Number of bases masked
public final int kMask(Read r, AbstractKmerTable[] sets)

*Counts the number of kmer hits for a read.
*@param r Read to process
*@param sets Kmer tables
*@return Number of hits
public final int countKmerHits(Read r, AbstractKmerTable[] sets)

*Returns the id of the sequence with the most kmer matches to this read, or -1 if none are at least minHits.
*@param r Read to process
*@param sets Kmer tables
*@return id of best match
public final int findBestMatch(Read r, AbstractKmerTable[] sets)

*Mask a read to cover matching kmers.
*@param r Read to process
*@param sets Kmer tables
*@return Number of bases masked
public final BitSet markBits(Read r, AbstractKmerTable[] sets)

*Transforms a kmer into all canonical values for a given Hamming distance.
*Returns the related id stored in the tables.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len kmer length
*@param qHDist Hamming distance
*@param qPos Position of kmer in query
*@param sets Kmer hash tables
*@return Value stored in table, or -1
public final int getValue(long kmer, long rkmer, int len, int qHDist, int qPos, AbstractKmerTable[] sets)

*Transforms a kmer into all canonical values for a given Hamming distance.
*Returns the related id stored in the tables.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len kmer length
*@param qHDist Hamming distance
*@param sets Kmer hash tables
*@return Value stored in table, or -1
public final int getValue(long kmer, long rkmer, int len, int qHDist, AbstractKmerTable[] sets)

*Transforms a kmer into a canonical value stored in the table and search.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param len kmer length
*@param sets Kmer hash tables
*@return Value stored in table
public final int getValue(long kmer, long rkmer, int len, AbstractKmerTable[] sets)

*Transforms a kmer into a canonical value stored in the table and search.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param lengthMask Bitmask with single '1' set to left of kmer
*@param sets Kmer hash tables
*@return Value stored in table
public final int getValueWithMask(long kmer, long rkmer, long lengthMask, AbstractKmerTable[] sets)

*Transforms a kmer into a canonical value stored in the table. Expected to be inlined.
*@param kmer Forward kmer
*@param rkmer Reverse kmer
*@param lengthMask Bitmask with single '1' set to left of kmer
*@return Canonical value
private final long toValue(long kmer, long rkmer, long lengthMask)

*Pack a list of counts from an array to an IntList.
*@param loose Counter array
*@param packed Unique values
*@param counts Counts of values
*@return Highest observed count
public static int condenseLoose(int[] loose, IntList packed, IntList counts)

public final int kmerToWay(long kmer)

</class TableReader>
<class Walker>
public abstract class Walker

#Methods
*Allows iteration through a hash map.
*Concurrent modification is not recommended.
public boolean next()

*Current object kmer (key) for kmer package
public long kmer()

*Current value
public int value()

</class Walker>
