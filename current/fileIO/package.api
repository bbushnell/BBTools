#version 1
#package fileIO
#generated 2025-09-06T20:36:32

<class ArrayFile>
public class ArrayFile

#Methods
public static void main(String[] args)

public ArrayFile(String name)

@Override public String nextLine()

public float[] nextArray()

</class ArrayFile>
<class ByteFile>
public abstract class ByteFile

#Fields
public final FileFormat ff

*Force usage of ByteFile1
public static boolean FORCE_MODE_BF1=false

*Force usage of ByteFile2
public static boolean FORCE_MODE_BF2=false

*Unused
public static boolean FORCE_MODE_BF3=false

protected static final byte slashr='\r'

protected static final byte slashn='\n'

protected static final byte carrot='>'

protected static final byte plus='+'

protected static final byte at='@'

private long nextID=0


#Methods
public static final ByteFile makeByteFile1(String fname, boolean allowSubprocess)

public static final ByteFile makeByteFile(String fname, boolean allowSubprocess)

public static final ByteFile makeByteFile(FileFormat ff)

public static final ByteFile makeByteFile(FileFormat ff, int type)

protected ByteFile(FileFormat ff_)

public final ArrayList<byte[]> toByteLines()

public static final ArrayList<byte[]> toLines(FileFormat ff)

public static final ArrayList<byte[]> toLines(String fname)

public final long countLines()

public void reset()

final void superReset()

public final ListNum<byte[]> nextList()

public final boolean exists()

public InputStream is()

public long lineNum()

*Returns true if there was an error
public boolean close()

public byte[] nextLine()

public void pushBack(byte[] line)

public boolean isOpen()

public final String name()

public final boolean allowSubprocess()

</class ByteFile>
<class ByteFile1>
*@author Brian Bushnell
public final class ByteFile1

#Fields
final byte[] dummy=new byte[100]

private boolean open=false

private byte[] buffer=new byte[bufferlen]

private static final byte[] blankLine=new byte[0]

private int bstart=0

private int bstop=0

public InputStream is

public long lineNum=-1

public static boolean verbose=false

public static boolean BUFFERED=false

public static int bufferlen=16384

private boolean errorState=false


#Methods
public static void main(String[] args)

private static void speedtest(ByteFile1 tf, long first, long last, boolean reprint)

public ByteFile1(String fname, boolean allowSubprocess_)

public ByteFile1(FileFormat ff)

@Override public final void reset()

@Override public final boolean close()

@Override public final byte[] nextLine()

private static final String printNL(byte[] b)

private final void printBuffer()

private int fillBuffer()

@Override public void pushBack(byte[] line)

private final InputStream open()

@Override public boolean isOpen()

@Override public final InputStream is()

@Override public final long lineNum()

</class ByteFile1>
<class ByteFile2>
*Runs a ByteFile1 in a separate thread. Can speed up disk reading, particularly of compressed files, at cost of slightly more work done.
*Drop-in compatible with ByteFile1.
*@author Brian Bushnell
*@date Sep 23, 2013
public final class ByteFile2

#Fields
long cntr

private BF1Thread thread=null

private byte[][] currentList=null

private int currentLoc=0

private byte[] pushBack=null

static final byte[][] poison=new byte[0][]

public static boolean verbose=false

private static final boolean verbose2=false

private static final int bufflen=1000

private static final int buffs=4

private static final int buffcapacity=256000

private boolean errorState=false


#Methods
public static void main(String[] args)

private static void speedtest(ByteFile2 tf, long first, long last, boolean reprint)

public ByteFile2(String fname, boolean allowSubprocess_)

public ByteFile2(FileFormat ff)

@Override public final void reset()

@Override public final boolean close()

@Override public final byte[] nextLine()

private boolean getBuffer()

private final BF1Thread open()

@Override public boolean isOpen()

@Override public final void pushBack(byte[] line)

*For debugging
private static String toString(byte[][] x)

@Override public final InputStream is()

@Override public final long lineNum()

</class ByteFile2>
<class ByteStreamWriter>
*@author Brian Bushnell
*@date Oct 21, 2014
public class ByteStreamWriter

#Fields
private ByteBuilder buffer

public int initialLen=36000

public int maxLen=32768

public final boolean overwrite

public final boolean append

public final boolean allowSubprocess

public final String fname

public final boolean ordered

private final OutputStream outstream

private final ArrayBlockingQueue<ByteBuilder> queue

*For ordered output
private final HashMap<Long,ByteBuilder> map

private long nextJobID=0

private long maxJobID=-1

private boolean open=true

private boolean started=false

*TODO
public boolean errorState=false

private final boolean BAM

private final boolean SAM

private final boolean FASTQ

private final boolean FASTA

private final boolean BREAD

private final boolean SITES

private final boolean INFO

private final boolean OTHER

private final int FASTA_WRAP=Shared.FASTA_WRAP

private static final ByteBuilder POISON2=new ByteBuilder(1)

public static boolean verbose=false

*Number of lists held before the stream blocks
private final int MAX_CAPACITY=256

private final int ADD_LIMIT=MAX_CAPACITY / 2

private final int HALF_LIMIT=ADD_LIMIT / 4


#Methods
public static void main(String[] args)

*@See primary constructor
public ByteStreamWriter(String fname_, boolean overwrite_, boolean append_, boolean allowSubprocess_)

*@See primary constructor
public ByteStreamWriter(String fname_, boolean overwrite_, boolean append_, boolean allowSubprocess_, int format)

*Create a ByteStreamWriter for this FileFormat.
*@param ff Contains information about the file name, output format, etc.
public ByteStreamWriter(FileFormat ff)

*Creates and starts a ByteStreamWriter unless fname is null
public static ByteStreamWriter makeBSW(String fname, boolean ow, boolean append, boolean allowSub)

*Creates and starts a ByteStreamWriter unless ff is null
public static ByteStreamWriter makeBSW(FileFormat ff)

@Override public void run()

public void processJobs()

@Override public void start()

public void poison()

*Wait for this object's thread to terminate.
*Should be poisoned first.
public void waitForFinish()

*Poison the thread, and wait for it to terminate.
*@return true if there was an error, false otherwise
public boolean poisonAndWait()

public void addJob(ByteBuilder bb)

public final void forceFlushBuffer()

*Called after every write to the buffer
public final void flushBuffer(boolean force)

public void add(ByteBuilder job, long jobID)

private void addOrdered(ByteBuilder job, long jobID)

private void addDisordered(ByteBuilder job)

*Skip the buffers and print directly.
*Mainly for headers with ordered streams.
*@param s String to print.
public void forcePrint(String s)

*Skip the buffers and print directly.
*Mainly for headers with ordered streams.
*@param b Data to print.
public void forcePrint(byte[] b)

public ByteBuilder getBuffer()

*Avoid using this if possible.
public ByteStreamWriter print(CharSequence x)

@Deprecated public ByteStreamWriter print(StringBuilder x)

*Avoid using this if possible.
public ByteStreamWriter print(String x)

*Avoid using this if possible.
public ByteStreamWriter printt(String x)

public ByteStreamWriter tab()

public ByteStreamWriter nl()

public ByteStreamWriter print(boolean x)

public ByteStreamWriter print(int x)

public ByteStreamWriter printt(int x)

public ByteStreamWriter print(long x)

public ByteStreamWriter printt(long x)

public ByteStreamWriter print(float x, int decimals)

public ByteStreamWriter printt(float x, int decimals)

public ByteStreamWriter print(double x, int decimals)

public ByteStreamWriter printt(double x, int decimals)

public ByteStreamWriter print(byte x)

public ByteStreamWriter print(char x)

public ByteStreamWriter print(byte[] x)

public ByteStreamWriter println(byte[] x)

public ByteStreamWriter print(byte[] x, int len)

public ByteStreamWriter print(char[] x)

public ByteStreamWriter print(ByteBuilder x)

public ByteStreamWriter print(ByteBuilder x, boolean destroy)

public ByteStreamWriter print(Read r)

public ByteStreamWriter print(Contig c)

public ByteStreamWriter printKmer(long kmer, long count, int k)

public ByteStreamWriter printKmer(long kmer, int[] values, int k)

public ByteStreamWriter printKmer(long[] array, long count, int k)

public ByteStreamWriter printKmer(long[] array, int[] values, int k)

public ByteStreamWriter println()

public ByteStreamWriter println(CharSequence x)

public ByteStreamWriter println(String x)

public ByteStreamWriter println(StringBuilder x)

public ByteStreamWriter println(int x)

public ByteStreamWriter println(long x)

public ByteStreamWriter println(float x, int d)

public ByteStreamWriter println(double x, int d)

public ByteStreamWriter println(byte x)

public ByteStreamWriter println(char x)

public ByteStreamWriter println(char[] x)

public ByteStreamWriter println(ByteBuilder x)

public ByteStreamWriter println(ByteBuilder x, boolean destroy)

public ByteStreamWriter printlnKmer(long kmer, int count, int k)

public ByteStreamWriter printlnKmer(long kmer, int[] values, int k)

public ByteStreamWriter printlnKmer(long[] array, int count, int k)

public ByteStreamWriter printlnKmer(long[] array, int[] values, int k)

public ByteStreamWriter println(Read r)

public ByteStreamWriter println(Contig c)

public ByteStreamWriter printlnKmer(long kmer, long count, int k)

public ByteStreamWriter printlnKmer(long[] array, long count, int k)

public ByteStreamWriter println(Read r, boolean paired)

@Override public String toString()

</class ByteStreamWriter>
<class ChainBlock>
*For loading UCSC .chain files that convert one genome build to another.
public class ChainBlock

#Fields
public long score

public String tName

public int tChrom

public int tSize

public byte tStrand

public int tStart

public int tStop

public String qName

public int qChrom

public int qSize

public byte qStrand

public int qStart

public int qStop

public int chainID

public int[][] chunks


#Methods
public static void main(String args)

public ChainBlock(List<String[]> list)

private static int toChromosome(String s)

public ChainLine[] toLines()

public static ChainLine[][] loadChainLines(String fname)

public static ArrayList<ChainBlock> loadChainBlocks(String fname)

public static ChainBlock[][] splitChain(ArrayList<ChainBlock> list)

@Override public int compareTo(ChainBlock other)

</class ChainBlock>
<class ChainLine>
public class ChainLine

#Fields
public int tChrom

public byte tStrand

public int tStart

public int tStop

public int qChrom

public byte qStrand

public int qStart

public int qStop


#Methods
public static void main(String[] args)

public ChainLine(int chromT, byte strandT, int startT, int stopT, int chromQ, byte strandQ, int startQ, int stopQ)

@Override public String toString()

public static int binarySearch(int loc, ChainLine[] array)

public static int binarySearch(int loc, ChainLine[] array, int first, int last)

*Returns {chrom, strand, loc}
public static int[] translate(int loc, ChainLine[] array)

public int[] translate(int loc)

public boolean contains(int a, int b)

public boolean contains(int a)

@Override public int compareTo(ChainLine other)

</class ChainLine>
<class CompressFiles>
public class CompressFiles

#Fields
public static boolean zip=true

public static boolean gzip=!zip

public static boolean PRINT_7Z_BATCH=true


#Methods
public static void main(String[] args)

public static void compressFiles(String path)

public static void compressFiles(File path)

public static void compress(File in)

</class CompressFiles>
<class Concatenate>
*Accepts multiple input files.
*Reads them each sequentially, and outputs everything to a single output file.
*Generically, it can be used to concatenate files while recompressing them
*and avoiding the use of stdio.
*@author Brian Bushnell
*@date January 21, 2025
public class Concatenate

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out1="stdout.txt"

private final FileFormat ffout1

private long maxReads=-1

private long linesProcessed=0

private long bytesProcessed=0

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public Concatenate(String[] args)

void process(Timer t)

void processInner(String fname, ByteStreamWriter bsw)

</class Concatenate>
<class CopyFile>
*Unlike ReadWrite's version, this one forces compression and decompression even with same extensions.
*Mainly for benchmarking.
*@author Brian Bushnell
*@date Jan 23, 2013
public class CopyFile

#Methods
public static void main(String[] args)

public static void copyFile(String source, String dest, boolean createPathIfNeeded, boolean overwrite)

</class CopyFile>
<class CopyFiles>
public class CopyFiles

#Methods
public static void renameFiles(String path)

public static void renameFiles(File path)

public static void rename(File in)

</class CopyFiles>
<class CopyFiles2>
public class CopyFiles2

#Fields
public static String[] inRoots={"F:\\UTSW_second_set\\"}

public static String outRoot="C:\\Data\\OCT_8\\"

public static final String[] dirNames={"\\CNV\\","\\SV\\"}

public static final String[] fileNamesAbsolute={".*\\\\gene-GS.+-ASM.*\\.tsv.*",".*\\\\geneVarSummary-GS.+-ASM.*\\.tsv.*",".*\\\\summary-GS.+-ASM.*\\.tsv.*",".*\\\\var-GS.+-ASM.*\\.tsv.*",".*\\\\manifest\\.all",".*\\\\README\\..*",".*\\\\version"}

public static final String[] fileNames={"gene-GS.+-ASM.*\\.tsv.*","geneVarSummary-GS.+-ASM.*\\.tsv.*","summary-GS.+-ASM.*\\.tsv.*","var-GS.+-ASM.*\\.tsv.*","manifest\\.all","README\\..*","version"}

public static final String[] badNames={".*AppleDouble.*",".*DS_Store.*",".*EVIDENCE.*"}


#Methods
public static void main(String[] args)

public static void copyFiles(String in, String out)

public static void copyFiles(File in, File out)

public static void copyFile(File in, File out)

</class CopyFiles2>
<class FileFormat>
*This class contains metadata about a file
*@author Brian Bushnell
*@date Dec 19, 2012
public final class FileFormat

#Fields
private final String name

private final String simpleName

private final int format

private final int asciiOffset

private final int compression

private final int type

private final int mode

private final int interleaving

private final int length

private final boolean input

private final boolean amino

private final int numBarcodes

private final int barcodeDelimiter

private final int barcodeLength1

private final int barcodeLength2

private final boolean overwrite

private final boolean append

private final boolean allowSubprocess

private final boolean ordered

public boolean preferShreds=false

public static boolean verbose=false

public static boolean PRINT_WARNING=true

public static final int UNKNOWN=0

public static final int FA=1

public static final int FASTA=1

public static final int FQ=2

public static final int FASTQ=2

public static final int BREAD=3

public static final int SAM=4

public static final int CSFASTA=5

public static final int QUAL=6

public static final int SEQUENTIAL=7

public static final int RANDOM=8

public static final int SITES=9

public static final int ATTACHMENT=10

public static final int BAM=11

public static final int SCARF=12

public static final int TEXT=13

public static final int TXT=13

public static final int PHYLIP=14

public static final int HEADER=15

public static final int INT1D=16

public static final int LONG1D=17

public static final int BITSET=18

public static final int SKETCH=19

public static final int ONELINE=20

public static final int FR=21

public static final int FASTR=21

public static final int VCF=22

public static final int VAR=23

public static final int GFF=24

public static final int BED=25

public static final int PGM=26

public static final int PKM=26

public static final int EMBL=27

public static final int GBK=28

public static final int GBFF=29

public static final int ALM=30

public static final int BBNET=31

public static final int BBVEC=32

public static final int CLADE=33

public static final String[] FORMAT_ARRAY=new String[]{"unknown","fasta","fastq","bread","sam","csfasta","qual","sequential","random","sites","attachment","bam","scarf","text","phylip","header","int1d","long1d","bitset","sketch","oneline","fastr","vcf","var","gff","bed","pgm","embl","gbk","gbff","alm","bbnet","bbvec","vec","clade","spectra"}

public static final String[] EXTENSION_LIST=new String[]{"fq","fastq","fa","fasta","fas","fna","ffn","frn","seq","fsa","faa","bread","sam","csfasta","qual","bam","scarf","phylip","txt","gz","gzip","bz2","zip","xz","dsrc","header","headers","int1d","long1d","bitset","sketch","oneline","flat","fqz","gff","gff3","var","vcf","bed","pgm","embl","gbk","gbff","alm","bbnet","bbvec","vec","clade","spectra","7z","zst"}

public static final int RAW=1

public static final int GZ=2

public static final int GZIP=2

public static final int ZIP=3

public static final int BZ2=4

public static final int XZ=5

public static final int c4=6

public static final int SEVENZ=7

public static final int DSRC=8

public static final int FQZ=9

public static final int LZ=10

public static final int AC=11

public static final int ZSTD=12

public static final String[] COMPRESSION_ARRAY=new String[]{"unknown","raw","gz","zip","bz2","xz","c4","7z","dsrc","fqz","lz","ac","zst"}

public static final int FILE=1

public static final int STDIO=2

public static final int STDIN=2

public static final int STDOUT=2

public static final int DEVNULL=3

private static final String[] TYPE_ARRAY=new String[]{"unknown","file","stdio","devnull"}

public static final int READ=1

public static final int WRITE=2

private static final String[] MODE_ARRAY=new String[]{"unknown","read","write"}

public static final int SINGLE=1

public static final int INTERLEAVED=2

private static final String[] INTERLEAVING_ARRAY=new String[]{"unknown","single-ended","interleaved"}


#Methods
public static void main(String[] args)

private static void test(String fname, boolean forceFileRead)

public static FileFormat testInput(String fname, String overrideExtension, boolean allowSubprocess)

public static FileFormat[] testInputList(List<String> fname, int defaultFormat, String overrideExtension, boolean allowSubprocess, boolean allowFileRead)

public static FileFormat[] testInput(String fnames, int defaultFormat, String overrideExtension, boolean allowSubprocess, boolean allowFileRead)

public static FileFormat testInput(String fname, int defaultFormat, String overrideExtension, boolean allowSubprocess, boolean allowFileRead)

public static FileFormat testInput(String fname, int defaultFormat, String overrideExtension, boolean allowSubprocess, boolean allowFileRead, boolean forceFileRead)

*Create an input FileFormat object for this filename.
*@param fname Filename (path).
*@param defaultFormat Use this format if the name is unclear and the format is not autodetected.
*@param overrideFormat If specified, ignore the file extension and autodetection and input using this format.
*@param overrideCompression If specified, ignore the file extension and input using this compression protocol.
*@param allowSubprocess Permission to spawn a subprocess like bgzip.
*@param allowFileRead Permission to read the file while constructing this FileFormat, for the purpose of format detection.
*@param forceFileRead Force reading the file while constructing this FileFormat, for the purpose of format detection.
*@return A FileFormat, or null if the filename is null.
public static FileFormat testInput(String fname, int defaultFormat, int overrideFormat, int overrideCompression, boolean allowSubprocess, boolean allowFileRead, boolean forceFileRead)

*Create an output FileFormat object for this filename.
*@param fname Filename (path).
*@param defaultFormat Use this format if the name is unclear.
*@param overrideExtension If specified, ignore the file extension and output in this format.
*@param allowSubprocess Permission to spawn a subprocess like bgzip.
*@param overwrite Permission to overwrite existing files.
*@param append Permission to append to existing files.
*@param ordered True if the input order should be maintained (for multithreaded read processing).
*@return A FileFormat, or null if the filename is null.
public static FileFormat testOutput(String fname, int defaultFormat, String overrideExtension, boolean allowSubprocess, boolean overwrite, boolean append, boolean ordered)

public static FileFormat testOutput(String fname, int defaultFormat, int overrideFormat, int overrideCompression, boolean allowSubprocess, boolean overwrite, boolean append, boolean ordered)

private FileFormat(String fname, int mode_, int defaultFormat, int overrideFormat, int overrideCompression, boolean allowSubprocess_, boolean allowFileRead, boolean forceFileRead, boolean overwrite_, boolean append_, boolean ordered_, boolean input_)

@Override public String toString()

public static String toString(int[] vector)

*Returns an int array: {format, compression, type, interleaved,
*quality, length, numBarcodes, barcodeDelimiter, bcLength1, bcLength2}
public static final int[] testFormat(String fname, boolean allowFileRead, boolean forceFileRead)

public static boolean hasGffExtension(String fname)

public static boolean hasVcfExtension(String fname)

public static boolean hasFastaExtension(String fname)

public static boolean hasFastqExtension(String fname)

public static boolean hasFastqOrFastqExtension(String fname)

public static boolean hasTextExtension(String fname)

public static boolean hasSamOrBamExtension(String fname)

*@param fname File to read
*@return {quality, interleaved, length, format, numBarcodes, barcodeDelimiter,
*bcLen1, bcLen2}
public static int[] testInterleavedAndQuality(String fname, boolean forceFastq)

public static ArrayList<String> getFirstOctet(String fname)

*@param oct First 8 lines of file
*@param fname File to read
*@return {quality, interleaved, length, format, numBarcodes, barcodeDelimiter}
public static int[] testInterleavedAndQuality(ArrayList<String> oct, String fname, boolean forceFastq)

public static byte barcodeDelimiter(String barcode)

private static int countLetters(String s)

public static boolean isFastaExt(String ext)

public static boolean isFastaFile(String fname)

public static boolean isPgmFile(String fname)

public static boolean isAminoExt(String ext)

public static boolean isStdin(String s)

public static boolean isStdout(String s)

public static boolean isStderr(String s)

public static boolean isStdio(String s)

public static boolean isFastqExt(String ext)

public static boolean isPgmExt(String ext)

public static boolean isFastqFile(String fname)

public static boolean isSamOrBamExt(String ext)

public static boolean isGffExt(String ext)

public static boolean isSamOrBamFile(String fname)

public static boolean isBamExt(String ext)

public static boolean isVcfExt(String ext)

public static boolean isBamFile(String fname)

public static boolean isVcfFile(String fname)

public void deleteIfPresent()

public int barcodeDelimiter()

public int barcodesPerRead()

public int barcodeLength(int barcodeNum)

public boolean extensionEquals(String ext)

public String rawExtension()

public int rawExtensionCode()

private int rawExtensionCode(String ext, String comp)

public final String name()

public final String simpleName()

public final int format()

public final int compression()

public final int type()

public final int mode()

public final boolean amino()

public final boolean hasName()

public final int asciiOffset()

public final int length()

public final boolean canWrite()

public final boolean canRead()

public final boolean unknownField()

public final boolean unknownFormat()

public final boolean fasta()

public final boolean fastq()

public final boolean fastr()

public final boolean bread()

public final boolean sam()

public final boolean samOrBam()

public final boolean csfasta()

public final boolean qual()

public final boolean sequential()

public final boolean random()

public final boolean sites()

public final boolean attachment()

public final boolean header()

public final boolean bam()

public final boolean scarf()

public final boolean text()

public final boolean int1d()

public final boolean long1d()

public final boolean bitset()

public final boolean sketch()

public final boolean oneline()

public final boolean var()

public final boolean vcf()

public final boolean gff()

public final boolean bed()

public final boolean pgm()

public final boolean embl()

public final boolean gbk()

public final boolean gbff()

public final boolean alm()

public final boolean bbnet()

public final boolean bbvec()

public final boolean clade()

public final boolean preferShreds()

public boolean isSequence()

public final boolean unknownCompression()

public final boolean raw()

public final boolean gzip()

public final boolean zstd()

public final boolean zip()

public final boolean bz2()

public final boolean fqz()

public final boolean lz()

public final boolean xz()

public final boolean sevenz()

public final boolean dsrc()

public final boolean compressed()

public final boolean unknownType()

public final boolean file()

public final boolean stdio()

public final boolean stdin()

public final boolean stdout()

public final boolean devnull()

public final boolean unknownMode()

public final boolean read()

public final boolean write()

public final boolean overwrite()

public final boolean append()

public final boolean allowSubprocess()

public final boolean ordered()

public boolean interleaved()

public final boolean exists()

</class FileFormat>
<class FindFiles>
public class FindFiles

#Fields
public ArrayList<String> results=new ArrayList<String>()

public String prefix

public String suffix

public String middle

public static final char slash=System.getProperty("file.separator").charAt(0)


#Methods
public FindFiles(String pre, String suf, String mid)

public static ArrayList<String> findFiles(String root, String prefix, String suffix)

public static ArrayList<String> findFiles(String root, String prefix, String suffix, String mid)

public ArrayList<String> findFiles(String path)

public ArrayList<String> findFiles(File path)

public void consider(File in)

</class FindFiles>
<class GenericTextFile>
public class GenericTextFile

#Methods
public GenericTextFile(String name)

public String[] toLines()

@Override public String nextLine()

</class GenericTextFile>
<class LoadThread>
*@author Brian Bushnell
*@date Jan 2, 2013
public class LoadThread

#Fields
*{active, waiting, running}
*Active means running or waiting.
public static int[] activeThreads={0,0,0}

private final String fname

private final Class<X> c

public X output=null

private static final int[] RUNNING=new int[1]

public static int LIMIT=Tools.min(12,Tools.max(Shared.threads(),1))


#Methods
public static LoadThread<Y> load(String fname, Class<Y> c)

private LoadThread(String fname_, Class<X> c_)

@Override public void run()

private static final int addThread(int x)

private static final int addRunningThread(int x)

public static final int countActiveThreads()

public static final void waitForReadingToFinish()

public final void waitForThisToFinish()

</class LoadThread>
<class MatrixFile>
public class MatrixFile

#Methods
public static void main(String[] args)

public MatrixFile(String name)

@Override public String nextLine()

public Matrix nextMatrix()

</class MatrixFile>
<class OpenFile>
public class OpenFile
</class OpenFile>
<class PipeThread>
*Listens to an output stream and copies it to an input stream.
*For example, redirects the error stream of some process to stderr.
*@author Brian Bushnell
*@date Jan 22, 2013
public class PipeThread

#Fields
public final InputStream is

public final OutputStream os

private boolean finished=false


#Methods
public PipeThread(InputStream is_, OutputStream os_)

@Override public void run()

public boolean finished()

public void terminate()

</class PipeThread>
<class QuickFile>
*Written for testing a NERSC slowdown in multithreaded file reading.
*The problem was sometimes sidestepped by eliminating "if(pushBack!=null){" and reimplementing pushback.
*However, that does not address the cause, so is not an overall solution; the cause remains a mystery.
*This class may safely be deleted.
*@author Brian Bushnell
public class QuickFile

#Fields
final byte[] dummy=new byte[100]

public final FileFormat ff

public static boolean FORCE_MODE_BF1=false

public static boolean FORCE_MODE_BF2=false

public static boolean FORCE_MODE_BF3=false

protected static final byte slashr='\r'

protected static final byte slashn='\n'

protected static final byte carrot='>'

protected static final byte plus='+'

protected static final byte at='@'

long a=1

long b=2

long c=3

long d=4

byte[] p0=null

byte[] p1=null

byte[] p2=null

byte[] p3=null

private byte[] pushBack=null

private long nextID=0

private boolean open=false

private byte[] buffer=new byte[bufferlen]

private static final byte[] blankLine=new byte[0]

private int bstart=0

private int bstop=0

public InputStream is

public long lineNum=-1

public static boolean verbose=false

public static boolean BUFFERED=false

public static int bufferlen=16384

private boolean errorState=false


#Methods
private static void speedtest(QuickFile tf, long first, long last, boolean reprint)

public QuickFile(String fname, boolean allowSubprocess_)

public QuickFile(FileFormat ff_)

public final void reset()

public final boolean close()

public byte[] nextLine()

private int fillBuffer()

private final InputStream open()

public final ArrayList<byte[]> toByteLines()

public final long countLines()

public final ListNum<byte[]> nextList()

public final boolean exists()

public final void pushBack(byte[] line)

public final String name()

public final boolean allowSubprocess()

</class QuickFile>
<class ReadWrite>
public class ReadWrite

#Fields
*{active, waiting, running}
*Active means running or waiting.
public static int[] activeThreads={0,0,0}

public static int maxWriteThreads=Shared.threads()

public static boolean verbose=false

public static boolean RAWMODE=false

public static boolean FORCE_KILL=false

public static boolean USE_GZIP=false

public static boolean USE_BGZIP=true

public static boolean USE_PIGZ=true

public static boolean USE_GUNZIP=false

public static boolean USE_UNBGZIP=true

public static boolean USE_UNPIGZ=true

public static boolean FORCE_PIGZ=false

public static boolean FORCE_BGZIP=false

public static boolean PREFER_BGZIP=true

public static boolean PREFER_UNBGZIP=true

public static boolean USE_BZIP2=true

public static boolean USE_PBZIP2=true

public static boolean USE_LBZIP2=true

public static boolean USE_DSRC=true

public static boolean USE_FQZ=true

public static boolean USE_ALAPY=true

public static boolean USE_SAMBAMBA=true

public static int SAMTOOLS_IGNORE_FLAG=0

public static final int SAM_UNMAPPED=0x4

public static final int SAM_DUPLICATE=0x400

public static final int SAM_SUPPLIMENTARY=0x800

public static final int SAM_SECONDARY=0x100

public static final int SAM_QFAIL=0x200

public static boolean PROCESS_BZ2=true

public static final boolean PROCESS_XZ=false

public static final int INBUF=16384

public static final int OUTBUF=16384

*Gzip compression level
public static int ZIPLEVEL=4

*Bzip2 compression level
public static int BZIPLEVEL=9

private static int MAX_ZIP_THREADS=96

public static int MAX_SAMTOOLS_THREADS=64

public static int PIGZ_BLOCKSIZE=128

public static int PIGZ_ITERATIONS=-1

public static boolean SET_ZIP_THREAD_MULT=false

public static boolean SET_ZIP_THREADS=false

private static float ZIP_THREAD_MULT=1f

public static boolean ALLOW_ZIPLEVEL_CHANGE=true

public static final String FILESEP=System.getProperty("file.separator")

private static final String diskSync=new String("DISKSYNC")

public static final HashSet<String> loadedFiles=new HashSet<String>()

private static final String[] compressedExtensions=new String[]{".gz",".gzip",".zip",".bz2",".xz",".dsrc",".fqz",".ac",".7z",".zst"}

private static final String[] compressedExtensionMap=new String[]{"gz","gz","zip","bz2","xz","dsrc","fqz","ac","7z","zst"}

private static HashMap<String,Process> processMap=new HashMap<String,Process>(8)

private static HashMap<String,ArrayList<PipeThread>> pipeThreadMap=new HashMap<String,ArrayList<PipeThread>>(8)


#Methods
public static void main(String[] args)

public static void writeStringInThread(CharSequence x, String fname)

public static void writeStringInThread(CharSequence x, String fname, boolean append)

public static void writeObjectInThread(Object x, String fname, boolean allowSubprocess)

public static boolean setPermissions(String fname, boolean read, boolean write, boolean execute, boolean ownerOnly)

public static void writeString(CharSequence x, String fname)

public static void writeString(CharSequence x, String fname, boolean append)

public static void writeString(CharSequence x, String fname, boolean overwrite, boolean append)

public static void writeStringAsync(CharSequence x, String fname)

public static void writeStringAsync(CharSequence x, String fname, boolean append)

public static void write(X x, String fname, boolean allowSubprocess)

public static void writeAsync(X x, String fname, boolean allowSubprocess)

public static final boolean finishReading(InputStream is, String fname, boolean killProcess, Reader ra)

public static final boolean finishReading(InputStream is, String fname, boolean killProcess)

public static final boolean finishWriting(PrintWriter writer, OutputStream outStream, String fname, boolean killProcess)

public static final boolean close(OutputStream os, String fname)

public static final boolean close(OutputStream os)

public static OutputStream getOutputStream(FileFormat ff, boolean buffered)

public static OutputStream getOutputStream(String fname, boolean append, boolean buffered, boolean allowSubprocess)

public static OutputStream getRawOutputStream(String fname, boolean append, boolean buffered)

public static OutputStream getXZOutputStream(String fname, boolean buffered, boolean allowSubprocess)

public static OutputStream getBZipOutputStream(String fname, boolean buffered, boolean append, boolean allowSubprocess)

public static OutputStream getDsrcOutputStream(String fname, boolean buffered, boolean append)

public static OutputStream getZipOutputStream(String fname, boolean buffered, boolean allowSubprocess)

public static OutputStream getGZipOutputStream(String fname, boolean append, boolean allowSubprocess)

public static OutputStream getPigzStream(String fname, boolean append)

public static OutputStream getFqzStream(String fname)

public static OutputStream getAlapyStream(String fname)

public static OutputStream getGzipStream(String fname, boolean append)

public static OutputStream getBgzipStream(String fname, boolean append)

public static OutputStream getZstdStream(String fname, boolean append)

public static OutputStream getBzip2Stream(String fname, boolean append)

public static OutputStream getPbzip2Stream(String fname, boolean append)

public static OutputStream getLbzip2Stream(String fname, boolean append)

public static OutputStream getDsrcOutputStream2(String fname, boolean append)

public static OutputStream getOutputStreamFromProcess(String fname, String command, boolean sh, boolean append, boolean useProcessBuilder, boolean useFname)

public static String readString(String fname)

public static Object readObject(String fname, boolean allowSubprocess)

public static InputStream getInputStream(String fname, boolean buffer, boolean allowSubprocess)

public static InputStream getRawInputStream(String fname, boolean buffer)

public static InputStream getZipInputStream(String fname)

public static InputStream getZipInputStream(String fname, boolean buffer)

public static InputStream getGZipInputStream(String fname, boolean allowSubprocess, boolean buffer)

public static InputStream getGunzipStream(String fname)

public static InputStream getUnpigzStream(String fname)

public static InputStream getUnbgzipStream(String fname)

public static InputStream getUnzstdStream(String fname)

public static InputStream getUnpbzip2Stream(String fname)

public static InputStream getUnlbzip2Stream(String fname)

public static InputStream getUnbzip2Stream(String fname)

public static InputStream getUnDsrcStream(String fname)

public static InputStream getInputStreamFromProcess(String fname, String command, boolean cat, boolean appendFname, boolean useProcessBuilder)

public static InputStream getBZipInputStream(String fname, boolean allowSubprocess)

private static InputStream getBZipInputStream2(String fname, boolean allowSubprocess)

public static InputStream getDsrcInputStream(String fname)

private static InputStream getDsrcInputStream2(String fname)

public static InputStream getXZInputStream(String fname)

public static byte[] readRaw(String fname)

public static X read(Class<X> cx, String fname, boolean allowSubprocess)

public static X[] readArray(Class<X> cx, String fname, boolean allowSubprocess)

public static X[][] readArray2(Class<X> cx, String fname, boolean allowSubprocess)

public static X[][][] readArray3(Class<X> cx, String fname, boolean allowSubprocess)

public static String basename(String fname)

public static String rawName(String fname)

*Returns the path without the file extension.
*Only strips known extensions.
public static String stripExtension(String fname)

*Returns the whole extension, include compression and raw type
public static String getExtension(String fname)

public static String stripToCore(String fname)

*Strips the directories, leaving only a filename
*@param fname
*@return File name without directories
public static String stripPath(String fname)

public static String getPath(String fname)

public static String compressionType(String fname)

public static boolean isCompressed(String fname)

public static boolean isSam(String fname)

*Returns extension, lower-case, without a period
public static String rawExtension(String fname)

public static String parseRoot(String path)

*This one does not throw an exception for non-existing paths
public static String parseRoot2(String path)

public static String findFileExtension(String fname)

*Delete a file.
public static boolean delete(String path, boolean verbose)

public static void copyFile(String source, String dest)

public static void copyFile(String source, String dest, boolean createPathIfNeeded)

public static void copyDirectoryContents(String from, String to)

static final int addThread(int x)

static final int addRunningThread(int x)

public static final int countActiveThreads()

public static final void waitForWritingToFinish()

public static final boolean closeStream(ConcurrentReadStreamInterface cris)

public static final boolean closeStream(ConcurrentReadOutputStream ross)

public static final boolean closeOutputStreams(ConcurrentReadOutputStream ross)

public static final boolean closeStreams(MultiCros mc)

*Close these streams and wait for them to finish.
*@param cris An input stream. May be null.
*@param ross Zero or more output streams.
*@return True if an error was encountered.
public static final boolean closeStreams(ConcurrentReadStreamInterface cris, ConcurrentReadOutputStream ross)

public static boolean killProcess(String fname)

private static void addProcess(String fname, Process p)

private static void addPipeThread(String fname, PipeThread pt)

*Note:
*Magic number of bgzip files is (first 4 bytes):
*1f 8b 08 04
*31 139 8 4
*= 529205252
*gzip/pigz:
*1f 8b 08 00
*31 139 8 0
*= 529205248
*od --format=x1 --read-bytes=16 names.txt_gzip.gz
public static int getMagicNumber(String fname)

public static boolean SAMBAMBA()

public static int MAX_ZIP_THREADS()

public static void setZipThreads(int x)

public static float ZIP_THREAD_MULT()

public static void setZipThreadMult(float x)

</class ReadWrite>
<class SummaryFile>
*Tests to see if a summary file matches a reference fasta file, based on date, size, and name
*@author Brian Bushnell
*@date Mar 11, 2013
public class SummaryFile

#Fields
public final String summaryFname

public int chroms

public long contigs

public long scaffolds

public int interpad

public long bases

public long definedBases

public long undefinedBases

public String name

public String source

public int version

public long bytes

public long modified

public boolean scafprefixes


#Methods
public static void main(String[] args)

public boolean compare(String refName)

public static boolean compare(String summaryName, String refName)

public static String getName()

public static String getName(int build)

public SummaryFile(String path)

</class SummaryFile>
<class TextFile>
public class TextFile

#Fields
private boolean open=false

public boolean errorState=false

public final String name

public File file

private final boolean allowSubprocess

public InputStream is

public InputStreamReader isr

public BufferedReader br

public long lineNum=-1

public static boolean verbose=false


#Methods
public static void main(String[] args)

private static void speedtest(TextFile tf, long first, long last, boolean reprint)

public TextFile(String name)

public TextFile(FileFormat ff)

public TextFile(String fname, boolean allowSubprocess_)

public static final String[] toStringLines(FileFormat ff)

public static final String[] toStringLines(String fname)

*Generate an array of the lines in this TextFile
public final String[] toStringLines()

public final long countLines()

public static String[][] doublesplitTab(String[] lines, boolean trim)

public static String[][] doublesplitWhitespace(String[] lines, boolean trim)

public final void reset()

public boolean exists()

public final boolean close()

public String nextLine()

public final String readLine()

public final String readLine(boolean skipBlank)

private final BufferedReader open()

public boolean isOpen()

</class TextFile>
<class TextStreamWriter>
*@author Brian Bushnell
*@date Aug 23, 2010
public class TextStreamWriter

#Fields
private ArrayList<CharSequence> buffer

public int buffersize=100

public int maxBufferLen=60000

private int bufferLen=0

public final boolean overwrite

public final boolean append

public final boolean allowSubprocess

public final String fname

private final OutputStream myOutstream

private final PrintWriter myWriter

private final ArrayBlockingQueue<ArrayList<CharSequence>> queue

private boolean open=true

private boolean started=false

*TODO
public boolean errorState=false

private HashMap<Long,CharSequence> map=new HashMap<Long,CharSequence>()

private long nextKey=0

private final boolean BAM

private final boolean SAM

private final boolean FASTQ

private final boolean FASTA

private final boolean BREAD

private final boolean SITES

private final boolean INFO

private final boolean OTHER

private final int FASTA_WRAP=Shared.FASTA_WRAP

private static final String POISON=new String("POISON_TextStreamWriter")

private static final ArrayList<CharSequence> POISON2=new ArrayList<CharSequence>(1)

public static boolean verbose=false


#Methods
public TextStreamWriter(String fname_, boolean overwrite_, boolean append_, boolean allowSubprocess_)

public TextStreamWriter(String fname_, boolean overwrite_, boolean append_, boolean allowSubprocess_, int format)

public TextStreamWriter(FileFormat ff)

@Override public void run()

@Override public void start()

public void poison()

public void waitForFinish()

*@return true if there was an error, false otherwise
public boolean poisonAndWait()

public void addJob(ArrayList<CharSequence> j)

public void print(CharSequence cs)

public void print(long number)

public void print(Read r)

public void writeOrdered(CharSequence cs, long key)

public void println()

public void println(CharSequence cs)

public void println(Read r)

</class TextStreamWriter>
