#version 1
#package gff
#generated 2025-09-06T20:36:44

<class CompareGff>
*Compares gff files for the purpose of grading gene-calling.
*@author Brian Bushnell
*@date October 3, 2018
public class CompareGff

#Fields
private String in=null

private String ref=null

private HashMap<StringNum,GffLine> lineMap

private HashMap<StringNum,Integer> startCountMap

private HashMap<StringNum,Integer> stopCountMap

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

private long falsePositiveStart=0

private long falsePositiveStop=0

private long truePositiveStart=0

private long truePositiveStop=0

private long falseNegativeStart=0

private long falseNegativeStop=0

private long falsePositiveStart2=0

private long falsePositiveStop2=0

private long truePositiveStart2=0

private long truePositiveStop2=0

private long refCount=0

private long queryCount=0

private final FileFormat ffin

private final FileFormat ffref

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CompareGff(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

@SuppressWarnings private void processInner(ByteFile bf)

private void processLine(GffLine gline)

</class CompareGff>
<class CompareGff_old>
*Compares gff files for the purpose of grading gene-calling.
*@author Brian Bushnell
*@date October 3, 2018
public class CompareGff_old

#Fields
private String in=null

private String ref=null

private HashMap<Integer,ArrayList<GffLine>> map

private HashSet<Integer> stopSet

private HashSet<Integer> startSet

private HashSet<Integer> stopSetM

private HashSet<Integer> startSetM

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

private long falsePositiveStart=0

private long falsePositiveStop=0

private long truePositiveStart=0

private long truePositiveStop=0

private long falseNegativeStart=0

private long falseNegativeStop=0

private long falsePositiveStart2=0

private long falsePositiveStop2=0

private long truePositiveStart2=0

private long truePositiveStop2=0

private long refCount=0

private long queryCount=0

private final FileFormat ffin

private final FileFormat ffref

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Constructor.
*@param args Command line arguments
public CompareGff_old(String[] args)

*This currently ignores sequence names.
private void processLine(GffLine gline)

</class CompareGff_old>
<class CutGff>
public class CutGff

#Fields
private ArrayList<String> fnaList=new ArrayList<String>()

private ArrayList<String> gffList=new ArrayList<String>()

private String out=null

private String types="CDS"

private boolean invert=false

private boolean banPartial=true

private int minLen=1

private int maxLen=Integer.MAX_VALUE

private String[] requiredAttributes

private String[] bannedAttributes

private long bytesOut=0

private boolean renameByTaxID=false

private int taxMode=ACCESSION_MODE

private boolean requirePresent=false

private boolean alignRibo=false

private boolean adjustEndpoints=false

private boolean onePerFile=false

private boolean pickBest=false

private int ssuSlop=999

private int lsuSlop=999

private float ID_MULT=0.96f

private int maxNs=-1

private double maxNFraction=-1

private static int ACCESSION_MODE=0

private static int GI_MODE=1

private static int HEADER_MODE=2

private static int TAXID_MODE=3

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

protected AtomicLong flipped=new AtomicLong(0)

protected AtomicLong failed=new AtomicLong(0)

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private final FileFormat ffout

private final ArrayList<Read> dummy=new ArrayList<Read>()

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

public boolean ordered=true

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CutGff(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

public void process(Timer t)

public void processST(Timer t)

public void processMT(Timer t)

private boolean hasAttributes(GffLine gline)

private static boolean hasAttributes(GffLine gline, String[] attributes)

private void processFileST(String fna, String gff, String types, ByteStreamWriter bsw)

private ArrayList<Read> processFile(String fna, String gff, String types)

private void renameByTaxID(ArrayList<Read> list)

private int[] parseTaxIds(ArrayList<Read> list)

private String parseAccession(String id)

private String parseGi(String id)

private ArrayList<Read> processLines(ArrayList<GffLine> lines, HashMap<String,Read> map, boolean invertSelection)

private Float align(GffLine gline, byte[] scaf, int type)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class CutGff>
<class CutGff.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class CutGff.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Shared output stream
private final ConcurrentReadOutputStream ros

*Thread ID
final int tid

*Next file ID
final AtomicInteger atom


#Methods
ProcessThread(AtomicInteger atom_, ConcurrentReadOutputStream ros_, int tid_)

@Override public void run()

private ArrayList<Read> processFileT(String fna, String gff, String types)

</class CutGff.ProcessThread>
<class CutGff_ST>
public class CutGff_ST

#Fields
private ArrayList<String> fnaList=new ArrayList<String>()

private ArrayList<String> gffList=new ArrayList<String>()

private String out=null

private String types="CDS"

private boolean invert=false

private boolean banPartial=true

private int minLen=1

private int maxLen=Integer.MAX_VALUE

private String[] requiredAttributes

private String[] bannedAttributes

private long bytesOut=0

private final FileFormat ffout

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CutGff_ST(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

public void process(Timer t)

private void processFile(String fna, String gff, String types, ByteStreamWriter bsw)

private boolean hasAttributes(GffLine gline)

private boolean hasAttributes(GffLine gline, String[] attributes)

private void processStrand(ArrayList<GffLine> lines, HashMap<String,Read> map, int strand, ByteStreamWriter bsw, boolean invert)

</class CutGff_ST>
<class GbffFeature>
public class GbffFeature

#Fields
public int type=-1

public int subtype=-1

public String product

public String locus_tag

public int start

public int stop

public byte strand=Shared.PLUS

public String accession

public boolean pseudo=false

public boolean error=false

public static final String[] typeStrings={"gene","CDS","rRNA","tRNA","ncRNA","repeat_region","5'UTR","3'UTR","intron","exon","5S","16S","23S"}

public static final String[] typeStringsGff={"gene","CDS","rRNA","tRNA","ncRNA","repeat_region","five_prime_UTR","three_prime_UTR","intron","exon","5S","16S","23S"}

public static final int GENE=0

public static final int CDS=1

public static final int rRNA=2

public static final int tRNA=3

public static final int ncRNA=4

public static final int repeat_region=5

public static final int UTR5=6

public static final int UTR3=7

public static final int intron=8

public static final int exon=9

public static final int r5S=10

public static final int r16S=11

public static final int r23S=12


#Methods
public GbffFeature(ArrayList<byte[]> lines0, String typeString, String accessionString)

private void parseSlow(ArrayList<byte[]> lines0)

ArrayList<byte[]> fixLines(ArrayList<byte[]> lines)

void append(ByteBuilder bb, byte[] line)

void setType(String typeString)

void parseStartStop(byte[] line0)

String parseLine(byte[] line)

void setSubtype()

public void toGff(ByteStreamWriter bsw)

public ByteBuilder appendGff(ByteBuilder bb)

@Override public String toString()

</class GbffFeature>
<class GbffFile>
public class GbffFile

#Fields
private final FileFormat ff

private ByteFile bf

private byte[] line=null


#Methods
public static void main(String[] args)

public void toGff(ByteStreamWriter bsw, boolean printHeader)

public GbffFile(FileFormat ff_)

public void reset()

public GbffLocus nextLocus()

</class GbffFile>
<class GbffLocus>
public class GbffLocus

#Fields
*Line number
int num=0

boolean printGene=false

boolean printRepeat=false

public static String[] featureTypes=GbffFeature.typeStrings

private static final byte[] seqRegB="##sequence-region ".getBytes()

String accession

String organism

String species

int start

int stop

ArrayList<GbffFeature> features=new ArrayList<GbffFeature>()


#Methods
public GbffLocus(ArrayList<byte[]> lines)

int parseBlock(ArrayList<byte[]> lines)

private byte[] nextLine(ArrayList<byte[]> lines)

private byte[] getLine(ArrayList<byte[]> lines)

*Move pointer to next block start
private int advanceBlock(ArrayList<byte[]> lines)

*Move pointer to next block start
private int advanceFeature(ArrayList<byte[]> lines)

private String trimBlockName(byte[] line)

private String toFeatureType(byte[] line)

private int parseLocus(ArrayList<byte[]> lines)

private int parseDefinition(ArrayList<byte[]> lines)

private int parseAccession(ArrayList<byte[]> lines)

private int parseVersion(ArrayList<byte[]> lines)

private int parseDBLink(ArrayList<byte[]> lines)

private int parseKeywords(ArrayList<byte[]> lines)

private int parseSource(ArrayList<byte[]> lines)

private int parseReference(ArrayList<byte[]> lines)

private int parseComment(ArrayList<byte[]> lines)

private int parseFeatures(ArrayList<byte[]> lines)

*Move pointer to next block start
private int parseFeature(ArrayList<byte[]> lines, String type)

private int parseContig(ArrayList<byte[]> lines)

private int parseOrigin(ArrayList<byte[]> lines)

private int parsePrimary(ArrayList<byte[]> lines)

public void toGff(ByteStreamWriter bsw)

</class GbffLocus>
<class GffLine>
*Parses and represents GFF3 format annotation lines.
*Supports constructors from multiple input formats including GTF, VCF, Var objects, and ORF predictions.
*Implements Feature interface for genomic coordinate operations.
*Provides batch loading with type filtering and prokaryotic feature classification.
*@author Brian Bushnell
*@date Sep 12, 2018
public class GffLine

#Fields
*Sequence/scaffold identifier
public String seqid

*Feature source (program/database)
public String source

*Feature type (CDS, rRNA, gene, etc)
public String type

*1-based start coordinate
public int start

*1-based end coordinate (inclusive)
public int stop

*Feature score (-1 if missing)
public float score

*Strand (0=+, 1=-, 2=?, 3=.)
public int strand

*Coding phase (0, 1, 2, or -1 if missing)
public int phase

*Semicolon-separated attribute string
public String attributes

*Strand character array for byte lookup
private static final byte[] STRANDS=new byte[]{'+','-','?','.'}

*Strand constants: PLUS=0, MINUS=1, QMARK=2, DOT=3
public static final int PLUS=0

*Strand constants: PLUS=0, MINUS=1, QMARK=2, DOT=3
public static final int MINUS=1

*Strand constants: PLUS=0, MINUS=1, QMARK=2, DOT=3
public static final int QMARK=2

*Strand constants: PLUS=0, MINUS=1, QMARK=2, DOT=3
public static final int DOT=3

*Constant for missing field placeholder
public static final String DOTS="."

*Controls whether to parse and intern sequence IDs
public static boolean parseSeqid=true

*Controls whether to parse and intern source field (typo in variable name)
public static boolean paseSource=false

*Controls whether to parse and intern feature types
public static boolean parseType=true

*Controls whether to parse score field (unused)
public static boolean parseScore=false

*Controls whether to parse attributes field
public static boolean parseAttributes=true


#Methods
*Parses tab-delimited GFF line into 9 standard fields.
*@param line GFF format line bytes
public GffLine(byte[] line)

*Creates GffLine from GTF format, converting attribute format.
public GffLine(GtfLine gtf)

*Creates sequence_variant_obs GffLine from VCF variant call.
public GffLine(VCFLine vcf)

*Creates sequence_variant_obs GffLine from Var with calculated score.
public GffLine(Var v, double properPairRate, double totalQualityAvg, double totalMapqAvg, double readLengthAvg, double rarity, int ploidy, ScafMap map, CellNet net)

*Creates sequence_variant_obs GffLine from Var without quality scoring.
public GffLine(Var v)

@Override public GffLine clone()

*Creates GffLine from prokaryotic ORF prediction with feature type and scoring.
public GffLine(Orf o)

*Loads GFF file filtering by feature types.
*@param fname File path
*@param types Comma-separated feature types (null for all)
*@param banUnprocessed Skip unprocessed prokaryotic types
*@return List of matching GffLine objects
public static ArrayList<GffLine> loadGffFile(String fname, String types, boolean banUnprocessed)

*Loads GFF file into separate arrays by feature type.
*@param gff File path
*@param types Comma-separated feature types
*@param banUnprocessed Skip unprocessed prokaryotic types
*@return Array of lists, one per feature type
public static ArrayList<GffLine>[] loadGffFileByType(String gff, String types, boolean banUnprocessed)

public static ArrayList<GffLine>[] loadGffFileByType(FileFormat ff, String types, boolean banUnprocessed)

public static ArrayList<GffLine> loadGffFile(FileFormat ff, String types, boolean banUnprocessed)

*Appends GFF representation of variant to ByteBuilder.
*@param bb Output buffer
*@param v Variant object
*@param properPairRate Fraction of properly paired reads
*@param totalQualityAvg Average base quality
*@param totalMapqAvg Average mapping quality
*@param readLengthAvg Average read length
*@param rarity Variant rarity score
*@param ploidy Expected ploidy
*@param map Scaffold mapping
*@param net Neural network for scoring
public static void toText(ByteBuilder bb, Var v, double properPairRate, double totalQualityAvg, double totalMapqAvg, double readLengthAvg, double rarity, int ploidy, ScafMap map, CellNet net)

*Creates GFF header with variant calling statistics.
*@param properPairRate Fraction of properly paired reads
*@param totalQualityAvg Average base quality
*@param mapqAvg Average mapping quality
*@param rarity Variant rarity threshold
*@param minAlleleFraction Minimum allele fraction for variant calls
*@param ploidy Expected ploidy
*@param reads Total read count
*@param pairs Paired read count
*@param properPairs Properly paired read count
*@param bases Total base count
*@param ref Reference genome name
*@return GFF header string with metadata
public static String toHeader(double properPairRate, double totalQualityAvg, double mapqAvg, double rarity, double minAlleleFraction, int ploidy, long reads, long pairs, long properPairs, long bases, String ref)

@Override public String toString()

public ByteBuilder appendTo(ByteBuilder bb)

*Returns feature length in bases.
public int length()

private static int find(byte a, byte[] array)

private static String intern(String s)

@Override public int hashCode()

@Override public boolean equals(Object o)

@Override public int compareTo(GffLine g)

@Override public int start()

@Override public int stop()

@Override public int strand()

@Override public String name()

@Override public String seqid()

*Creates Range map from GFF lines grouped by sequence ID.
*@param gffLines List of GFF features
*@return Map of sequence ID to Range arrays for overlap queries
public static HashMap<String,Range[]> makeRangeMap(ArrayList<GffLine> gffLines)

public static Range[] makeRangesOneSequence(ArrayList<GffLine> listForOneSequence)

*Returns 5' coordinate considering strand orientation.
public int trueStart()

*Returns 3' coordinate considering strand orientation.
public int trueStop()

*Returns prokaryotic feature type constant.
*Classifies rRNA by subunit (16S, 23S, 18S, 5S) based on attributes.
*@return ProkObject type constant or -1 if unrecognized
public final int prokType()

*Returns true if feature has partial=true attribute.
public final boolean partial()

*Returns true if feature coordinates are within scaffold bounds.
public final boolean inbounds(int scaflen)

</class GffLine>
<class GtfLine>
public class GtfLine

#Fields
String seqname

String source

String feature

int start

int end

float score

byte strand

int frame

String attribute


#Methods
public static void main(String[] args)

public GtfLine(byte[] line)

</class GtfLine>
<class ParseCrispr>
*@author Brian Bushnell
*@date Nov 3, 2023
public class ParseCrispr

#Fields
*Primary input file path
private String in1=null

*Primary output file path
private String out1=null

*Junk output file path
private String outInvalid=null

private long linesProcessed=0

private long linesOut=0

private long bytesProcessed=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Output File
private final FileFormat ffout1

*Optional Output File for Junk
private final FileFormat ffoutInvalid

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public ParseCrispr(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create streams and process all data
void process(Timer t)

private void processInner(ByteFile bf, ByteStreamWriter bsw, ByteStreamWriter bswInvalid)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class ParseCrispr>
<class VcfToGff>
*Stripped out of GffLine into independent class.
*@author Brian Bushnell
*@date Sep 12, 2018
public class VcfToGff

#Methods
*Translates VCF to GFF
public static void main(String[] args)

*Translates VCF to GFF
private static void translate(String in, String out, boolean overwrite, boolean append)

</class VcfToGff>
