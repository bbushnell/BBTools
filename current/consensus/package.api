#version 1
#package consensus
#generated 2025-09-06T20:35:59

<class BaseGraph>
*A graph of the possible alignments of a reference sequence.
*@author Brian Bushnell
*@date September 6, 2019
public class BaseGraph

#Fields
private static final long serialVersionUID=3000198119165515066L

public long readTotal

public long baseTotal

public long symbolTotal

public long msTotal

public long insTotal

public long delTotal

public long qualTotal

public int subCount=0

public int refCount=0

public int delCount=0

public int insCount=0

public final String name

public final byte[] original

public final long numericID

public final int pad

public final BaseNode[] ref

public final BaseNode[] del

public float[] refWeights

public static final BaseNode dummy=new BaseNode('.',INS,0)

public static byte fakeQuality=15

public static boolean qualityByMS=true


#Methods
public BaseGraph(String name_, byte[] bases_, byte[] quals_, long numericID_, int pad_)

private float[] makeWeightsFromQual(byte[] quals)

private static byte[] pad(byte[] in, int pad, byte symbol)

*This method should be threadsafe
public void add(Read r)

*This method should be threadsafe
public void add(Read r, int leftBorder, int rightBorder)

*Generates a score indicating how well the alignment matches the model.
*Scores range from 1 to -1 times the alignment length; a random sequence
*might be around 0. Less-conserved models result in lower scores,
*even for optimally-matching alignments.
*A relative score divides by the alignment length.
public float scoreOld(Read r, boolean local, boolean relative)

*Generates a score indicating how well the alignment matches the model.
*Scores range from 1 to -1 times the alignment length; a random sequence
*might be around 0. Less-conserved models result in lower scores,
*even for optimally-matching alignments.
*A relative score divides by the alignment length.
public float score(Read r, boolean local, boolean relative)

*Count of alignments over this reference position.
int countSum(int rpos)

@Override public ByteBuilder toText()

int maxDepth()

public Read traverse()

public void makeWeights()

public int findBestOrientation(Read r, float minRatio)

*Generates match string and returns identity
public float alignAndGenerateMatch(Read r, Aligner ssa)

*Generates match string and returns identity
public float alignAndGenerateMatch(Read r, Aligner ssa, boolean findOrientation, float minRatio)

void calcProbs()

</class BaseGraph>
<class BaseGraphPart>
*Superclass for BaseEdge and BaseNode.
*@author Brian Bushnell
*@date September 6, 2019
public abstract class BaseGraphPart

#Fields
private static final long serialVersionUID=3854022870880887972L

*Type of this part
public final int type


#Methods
public BaseGraphPart(int type_)

*Name of this type
public final String typeString()

*Name of this part
public String partString()

</class BaseGraphPart>
<class BaseNode>
*A placeholder for a base.
*Tracks counts of bases seen at that position.
*Maintains edges to observed next bases.
*@author Brian Bushnell
*@date September 6, 2019
public class BaseNode

#Fields
private static final long serialVersionUID=7932097131372307182L

*Number of times this node has been traversed
public int countSum

*Sum of scores of traversals. Generally, sum of quality scores of this or adjacent bases.
*Probably equal to sum of acgt.
public int weightSum

public final int rpos

public final byte refBase

public final int[] acgtWeight

public final int[] acgtCount

public float acgtProb

public BaseNode refEdge

public BaseNode insEdge

public BaseNode delEdge

private static final float slope=(4f / 3f)


#Methods
public BaseNode(char refBase_, int type_, int rpos_)

public BaseNode(byte refBase_, int type_, int rpos_)

*Add a traversal of the designated base and quality
public void add(byte base, int quality)

public byte consensus(byte[] r)

public float baseProb(byte b)

public float baseScore(byte b)

byte minBase()

byte maxBase()

byte secondBase()

*Add a traversal of the designated quality
void increment(byte base, int quality)

@Override public final String partString()

@Override public ByteBuilder toText()

public ByteBuilder toTextWeight()

public ByteBuilder toTextCount()

@Override public int compareTo(BaseNode b)

void calcProbs()

public float alleleDif()

</class BaseNode>
<class ConsensusMaker>
*Alters a reference to represent the consensus of aligned reads.
*@author Brian Bushnell
*@date September 6, 1019
public class ConsensusMaker

#Fields
*Read input file path
private String in=null

*Reference input file path
private String ref=null

private String inModelFile

private BaseGraph inModel

private String outHistFile

*Consensus output file path
private String out=null

*Model output file path
private String outModel=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

protected long alignedReads=0

protected double identitySum=0

protected double scoreSum=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

public long subCount=0

public long refCount=0

public long delCount=0

public long insCount=0

long[] idHist=new long[101]

long[] scoreHist=new long[101]

boolean printScores=false

*Threads dedicated to reading the sam file
private int streamerThreads=SamStreamer.DEFAULT_THREADS

private String name=null

private boolean loadedRef=false

private boolean specialRef=false

private boolean realign=false

private int ploidy=1

private final boolean silent

public final SamFilter samFilter=new SamFilter()

*Uses full ref names
public LinkedHashMap<String,BaseGraph> refMap

*Uses truncated ref names
public LinkedHashMap<String,BaseGraph> refMap2

private String defaultRname=null

*Read input file
private final FileFormat ffin

*Reference input file
private final FileFormat ffref

*Consensus output file
private final FileFormat ffout

*Model output file
private final FileFormat ffmodel

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads ARE output in input order, even though this is false
private final boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public ConsensusMaker(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

private void writeHist(String fname)

*Create read streams and process all data
void process(Timer t)

private LinkedHashMap<String,BaseGraph> loadReferenceCustom()

private LinkedHashMap<String,BaseGraph> loadReferenceSpecial()

private void makeRefMap2()

private ConcurrentReadInputStream makeRefCris()

private SamStreamer makeStreamer(FileFormat ff)

private ConcurrentReadInputStream makeCris(FileFormat ff)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(SamStreamer ss)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris)

private void outputConsensus(ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public ByteBuilder toText()

@Override public final ReadWriteLock rwlock()

</class ConsensusMaker>
<class ConsensusMaker.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class ConsensusMaker.ProcessThread

#Fields
long[] idHistT=new long[101]

long[] scoreHistT=new long[101]

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

protected long alignedReadsT=0

double identitySumT=0

double scoreSumT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final SamStreamer ss

*Alternate input stream
private final ConcurrentReadInputStream cris

*Thread ID
final int tid

*For realigning reads
final Realigner realigner


#Methods
ProcessThread(SamStreamer ss_, int tid_)

ProcessThread(ConcurrentReadInputStream cris_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
void processRead(Read r)

</class ConsensusMaker.ProcessThread>
<class ConsensusObject>
*Superclass for consensus package classes.
*@author Brian Bushnell
*@date September 6, 2019
public abstract class ConsensusObject

#Fields
static int minDepth=2

public static float MAF_sub=0.25f

public static float MAF_del=0.5f

public static float MAF_ins=0.5f

public static float MAF_noref=0.4f

static boolean onlyConvertNs=false

static boolean noIndels=false

public static float trimDepthFraction=0.0f

public static boolean trimNs=false

public static boolean useMapq=false

public static boolean invertIdentity=false

public static int identityCeiling=150

*Match/Sub, neutral-length node or edge to the next REF node
public static final int REF=2

*Insertion node or edge to an insertion node
public static final int INS=1

*Edge to a non-adjacent node
public static final int DEL=0

static final String[] TYPE_NAMES={"DEL","INS","REF"}

public static boolean verbose=false


#Methods
*Return the text representation of this object
public ByteBuilder toText()

@Override public final String toString()

</class ConsensusObject>
<class FixScaffoldGaps>
*Resizes scaffold gaps to represent the best estimate
*based on the insert size distribution of paired reads.
*@author Brian Bushnell
*@date September 11, 2019
public class FixScaffoldGaps

#Fields
*Primary input file path
private String in=null

*Secondary input file path
private String ref=null

*Primary output file path
private String out=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private String insertList=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

protected long scaffoldsOut=0

protected long scaffoldLengthOut=0

protected long gapsUnchanged=0

protected long gapsWidened=0

protected long gapsNarrowed=0

protected long nsAdded=0

protected long nsRemoved=0

protected long nsTotal=0

protected long totalInsertSum=0

protected long totalInsertCount=0

protected double totalAverageInsert

protected AtomicLongArray insertCounts=new AtomicLongArray(20000)

protected int[] insertByPercentile

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Threads dedicated to reading the sam file
private int streamerThreads=SamStreamer.DEFAULT_THREADS

private boolean loadedRef=false

private int scaffoldBreakNs=10

int buckets=1000

private int minDepth=10

private float trimFraction=0.4f

public final SamFilter samFilter=new SamFilter()

*Uses full ref names
public LinkedHashMap<String,Scaffold> refMap=new LinkedHashMap<String,Scaffold>()

*Uses truncated ref names
public LinkedHashMap<String,Scaffold> refMap2=new LinkedHashMap<String,Scaffold>()

*Primary input file
private final FileFormat ffin

*Secondary input file
private final FileFormat ffref

*Primary output file
private final FileFormat ffout

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public FixScaffoldGaps(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private void loadReferenceCustom()

private ConcurrentReadInputStream makeRefCris()

private SamStreamer makeStreamer(FileFormat ff)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(SamStreamer ss)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

private void fixScaffolds(ConcurrentReadOutputStream ros)

private static int calcInsertSize(SamLine sl)

@Override public final ReadWriteLock rwlock()

</class FixScaffoldGaps>
<class FixScaffoldGaps.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class FixScaffoldGaps.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

protected long totalInsertSumT=0

protected long totalInsertCountT=0

long insertSum=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final SamStreamer ss

*Thread ID
final int tid


#Methods
ProcessThread(SamStreamer ss_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
void processRead(Read r)

</class FixScaffoldGaps.ProcessThread>
<class Lilypad>
*Scaffolds contigs based on paired read mapping.
*@author Brian Bushnell
*@date September 11, 2019
public class Lilypad

#Fields
*Primary input file path
private String in=null

*Secondary input file path
private String ref=null

*Primary output file path
private String out=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private String insertList=null

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

protected long scaffoldsOut=0

protected long scaffoldLengthOut=0

protected long totalInsertSum=0

protected long totalInsertCount=0

protected double totalAverageInsert

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

boolean sameStrandPairs=false

int gapsAdded=0

long nsAdded=0

*Threads dedicated to reading the sam file
private int streamerThreads=SamStreamer.DEFAULT_THREADS

private boolean loadedRef=false

private int minDepth=4

private float minWeightRatio=0.8f

private float minStrandRatio=0.8f

private int scaffoldBreakNs=10

private int maxPairDist=3000

private int buckets=1000

protected AtomicLongArray insertCounts=new AtomicLongArray(20000)

protected int[] insertByPercentile

public final SamFilter samFilter=new SamFilter()

*Uses full ref names
public LinkedHashMap<String,Contig> refMap=new LinkedHashMap<String,Contig>()

*Uses truncated ref names
public LinkedHashMap<String,Contig> refMap2=new LinkedHashMap<String,Contig>()

*Primary input file
private final FileFormat ffin

*Secondary input file
private final FileFormat ffref

*Primary output file
private final FileFormat ffout

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Constructor.
*@param args Command line arguments
public Lilypad(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private void loadReferenceCustom()

private ConcurrentReadInputStream makeRefCris()

private SamStreamer makeStreamer(FileFormat ff)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(SamStreamer ss)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

private void makeScaffolds(ConcurrentReadOutputStream ros)

private static int calcInsertSize(SamLine sl)

private Contig getScaffold(String rname)

Contig findLeftmost(Contig source)

Read expandRight(Contig source0, ByteBuilder bb)

@Override public final ReadWriteLock rwlock()

</class Lilypad>
<class Lilypad.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class Lilypad.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

protected long totalInsertSumT=0

protected long totalInsertCountT=0

long insertSum=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final SamStreamer ss

*Thread ID
final int tid


#Methods
ProcessThread(SamStreamer ss_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
void processRead(Read r)

</class Lilypad.ProcessThread>
