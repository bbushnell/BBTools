#version 1
#package aligner
#generated 2025-09-06T20:34:49

<interface Aligner>
public interface Aligner

#Methods
*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Does not require a min score (ie, same as old method)
int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Min score is optional
int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Generates the match string
byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*Generates identity;
*fills 'extra' with {match, sub, del, ins, N, clip} if present
float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Lowest possible alignment score for a read with this length and this identity
int minScoreByIdentity(int len, float identity)

int rows()

int columns()

</interface Aligner>
<class Alignment>
public class Alignment

#Fields
public final Read r

public float id=-1

public byte[] match

public int start

public int stop


#Methods
public Alignment(Read r_)

@Override public int compareTo(Alignment o)

public float align(byte[] ref)

public static final float align(Read r, byte[] ref)

</class Alignment>
<class AlignmentResult>
public class AlignmentResult

#Fields
public int maxScore

public int maxQpos

public int maxRpos

public int qLen

public int rLen

public int rStart

public int rStop

public boolean left

public int junctionLoc

public float ratio

*True if this is an ice cream cone
public boolean icecream=false

public boolean ambiguous=false

public Read alignedRead


#Methods
public AlignmentResult(int maxScore_, int maxQpos_, int maxRpos_, int qLen_, int rLen_, int rStart_, int rStop_, float ratio_)

</class AlignmentResult>
<class AlignRandom>
public class AlignRandom

#Methods
public static void main(String[] args)

private static int[] runInterval(int len, int iters, int buckets)

public static byte[] randomSequence(int len, Random randy)

private static void printInterval(int len, int iters, int[] hist, ByteStreamWriter bsw)

private static ByteBuilder header(int buckets)

static int[] runMT(int len, int iters, int buckets)

public void run()

</class AlignRandom>
<class AllToAll>
*Aligns all sequences to all sequences and produces an identity matrix.
*@author Brian Bushnell
*@date January 27, 2020
public class AllToAll

#Fields
*Primary input file path
private String in1=null

private String qfin1=null

*Primary output file path
private String out1=null

*Override input file extension
private String extin=null

ArrayList<Read> reads

float[][] results

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long alignments=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Primary output file
private final FileFormat ffout1

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public AllToAll(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all reads
void process(Timer t)

private static void mirrorMatrix(float[][] matrix)

private void printResults()

*Spawn process threads
private void spawnThreads()

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class AllToAll>
<class AllToAll.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
static class AllToAll.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long alignmentsT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

*Thread ID
final int tid

final ArrayList<Read> reads

final float[][] results

final AtomicInteger atom


#Methods
ProcessThread(ArrayList<Read> reads_, float[][] results_, AtomicInteger atom_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processQuery(int qnum)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

</class AllToAll.ProcessThread>
<class BandedAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*@author Brian Bushnell
*@contributor Isla
*@date April 24, 2025
public class BandedAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public BandedAligner()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedAligner>
<class BandedAlignerConcise>
*PRESENTATION-ONLY VERSION - DO NOT USE
*This class contains simplified code for publication purposes.
*For optimal implementation, see {@link BandedPlusAligner}
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*@author Brian Bushnell
*@contributor Isla
*@date April 24, 2025
public class BandedAlignerConcise

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public BandedAlignerConcise()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedAlignerConcise>
<class BandedAlignerInt>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Banded for speed.
*Identity is approximate.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 19, 2025
public class BandedAlignerInt

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=15

private static final int POSITION_MASK=(1 << POSITION_BITS) - 1

private static final int SCORE_MASK=~POSITION_MASK

private static final int SCORE_SHIFT=POSITION_BITS

private static final int MATCH=1 << SCORE_SHIFT

private static final int SUB=(-1) << SCORE_SHIFT

private static final int INS=(-1) << SCORE_SHIFT

private static final int DEL=(-1) << SCORE_SHIFT

private static final int N_SCORE=0

private static final int BAD=Integer.MIN_VALUE / 2

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public BandedAlignerInt()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

private static final float postprocess(int[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedAlignerInt>
<class BandedAlignerM>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band centered on the diagonal.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class BandedAlignerM

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int MATCH_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + MATCH_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long MATCH_MASK=((1L << MATCH_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | MATCH_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long MATCH_INCREMENT=MATCH + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public BandedAlignerM()

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedAlignerM>
<class BandedByteAligner>
*Aligns two sequences to return approximate ANI.
*Uses only 2 arrays.
*Requires traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*@author Brian Bushnell
*@contributor Isla
*@date May 4, 2025
public class BandedByteAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final byte MATCH=1

private static final byte SUB=-1

private static final byte INS=-1

private static final byte DEL=-1

private static final byte N_SCORE=0

private static final byte BAD=Byte.MIN_VALUE / 2

private static final boolean PRINT_OPS=false

public static final boolean debug=false


#Methods
public BandedByteAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

private static int rebalance(byte[] curr, int bandStart, int bandEnd, int oldMax)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(byte[] prev, int qLen, int bandStart, int bandEnd, int[] posVector, int absScore)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedByteAligner>
<class BandedPlusAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class BandedPlusAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public BandedPlusAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedPlusAligner>
<class BandedPlusAligner2>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class BandedPlusAligner2

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public BandedPlusAligner2()

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedPlusAligner2>
<class BandedPlusAligner3>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a fixed band around the diagonal.
*Uses SIMD alignment.
*Uses SIMD for wide-band padding detection.
*@author Brian Bushnell
*@contributor Isla
*@date May 29, 2025
public class BandedPlusAligner3

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public BandedPlusAligner3()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref, int[] pos)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedPlusAligner3>
<class BandedPlusAlignerInt>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Banded for speed.
*Identity is approximate.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 19, 2025
public class BandedPlusAlignerInt

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=15

private static final int POSITION_MASK=(1 << POSITION_BITS) - 1

private static final int SCORE_MASK=~POSITION_MASK

private static final int SCORE_SHIFT=POSITION_BITS

private static final int MATCH=1 << SCORE_SHIFT

private static final int SUB=(-1) << SCORE_SHIFT

private static final int INS=(-1) << SCORE_SHIFT

private static final int DEL=(-1) << SCORE_SHIFT

private static final int N_SCORE=0

private static final int BAD=Integer.MIN_VALUE / 2


#Methods
public BandedPlusAlignerInt()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(int[] query, int[] ref)

private static final float postprocess(int[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class BandedPlusAlignerInt>
<class ClippingTest>
*Unit tests for clipping functionality in IndelFreeAligner.
*Tests various scenarios including left/right clipping, clipping limits,
*edge cases with tiny sequences, and non-overlapping alignments.
*@author Isla SOS
*@contributor Brian Bushnell
*@date June 6, 2025
public class ClippingTest

#Methods
public static void main(String[] args)

*Tests left clipping functionality where query extends before reference start.
*Verifies that clipped bases are handled correctly and excess clipping is penalized.
*@return true if all left clipping tests pass, false otherwise
private static boolean testLeftClipping()

*Tests right clipping functionality where query extends past reference end.
*Verifies that right-side clipped bases are handled correctly.
*@return true if all right clipping tests pass, false otherwise
private static boolean testRightClipping()

*Tests scenarios where query extends past both ends of the reference.
*Verifies that total clipping from both sides is calculated correctly.
*@return true if all both-sides clipping tests pass, false otherwise
private static boolean testBothSidesClipping()

*Tests enforcement of clipping limits when total clips exceed maxClips.
*Verifies that excess clipping is properly converted to substitution penalties.
*@return true if all clipping limit tests pass, false otherwise
private static boolean testClippingLimits()

*Tests alignments where no clipping is needed (query fits within reference).
*Verifies that normal alignment works correctly when clipping is not required.
*@return true if all no-clipping tests pass, false otherwise
private static boolean testNoClippingNeeded()

*Tests exact matches between query and reference of the same length.
*Basic sanity check for the alignment function.
*@return true if exact match test passes, false otherwise
private static boolean testExactMatch()

*Tests scenarios combining clipping with substitutions in the aligned region.
*Verifies that both clipping penalties and substitution penalties are calculated correctly.
*@return true if all mixed clipping/substitution tests pass, false otherwise
private static boolean testClippingWithSubstitutions()

*Tests edge cases with very small sequences that might cause boundary issues.
*Includes 1bp references, 1bp queries, and extreme size mismatches.
*@return true if all edge case tests pass, false otherwise
private static boolean testEdgeCases()

*Tests alignment scenarios where query and reference don't overlap at all.
*Includes cases where rStart is far negative or extends far beyond reference end.
*@return true if all non-overlapping tests pass, false otherwise
private static boolean testNonOverlapping()

</class ClippingTest>
<class CrossCutAligner>
*Aligns two sequences to return ANI.
*Uses 3 scoring arrays and avoids traceback.
*Gives an exact identity plus rstart and rstop.
*Limited to length 2Mbp with 21 position bits.
*Iterates over diagonals that span bottom left to top right.
*This avoids all inter-loop data dependencies.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 2, 2025
public class CrossCutAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static final boolean debug=false


#Methods
public CrossCutAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

private static final long handleTop(long q, long r, int qLen, int col, long[] diag_k, long[] diag_km1, long[] bottom)

private static final long handleLeft(long q, long r, int qLen, int row, long[] diag_k, long[] diag_km1, long[] bottom)

*Calculate score for a cell in the alignment matrix
*@param q Query base
*@param r Reference base
*@param diagValue Diagonal cell value
*@param upValue Up cell value
*@param leftValue Left cell value
*@return Maximum score for this cell
private static long calculateCellValue(long q, long r, long diagValue, long upValue, long leftValue)

private static final float postprocess(long[] bottom, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class CrossCutAligner>
<class DiagonalAligner>
*Java implementation of the diagonal-based SIMD alignment algorithm from ksw2.
*Uses anti-diagonal traversal with a drifting window for efficient processing.
*@author Isla (based on ksw2 by Heng Li)
*@date May 2025
public class DiagonalAligner

#Fields
private static final VectorSpecies<Byte> BSPECIES=ByteVector.SPECIES_128

private static final VectorSpecies<Integer> ISPECIES=IntVector.SPECIES_128

private static final int BWIDTH=BSPECIES.length()


#Methods
@Override public String name()

@Override public float align(byte[] query, byte[] target)

@Override public float align(byte[] query, byte[] target, int[] posVector)

@Override public float align(byte[] query, byte[] target, int[] posVector, int minScore)

@Override public float align(byte[] query, byte[] target, int[] posVector, int refStart, int refEnd)

private void diagonalAlign(int qlen, byte[] query, int tlen, byte[] target, byte matchScore, byte mismatchScore, byte gapOpen, byte gapExtend, int w, int zdrop, int endBonus, boolean scoreOnly, ExtzResult ez)

private boolean applyZDrop(ExtzResult ez, int curH, int r, int t, int zdrop, int e)

@Override public long loops()

@Override public void setLoops(long i)

</class DiagonalAligner>
<class DiagonalAligner.ExtzResult>
static class DiagonalAligner.ExtzResult

#Fields
int max=0

int mqe=0

int mqe_t=-1

int mte=0

int mte_q=-1

int score=0

int max_t=-1

int max_q=-1

int max_drop_r=-1

int max_drop_q=-1

int max_drop_t=-1

boolean zdropped=false

boolean reach_end=false

</class DiagonalAligner.ExtzResult>
<class DriftingAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens in response to low sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingAligner

#Fields
private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

public static final boolean GLOBAL=false


#Methods
public DriftingAligner()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

</class DriftingAligner>
<class DriftingAlignerConcise>
*PRESENTATION-ONLY VERSION - DO NOT USE
*This class contains simplified code for publication purposes.
*For functional implementation, see {@link DriftingAligner}
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingAlignerConcise

#Fields
static long[] prev=null

static long[] curr=null

static int qLen=0

static int rLen=0

static long maxValue=0

private static AtomicLong loops=new AtomicLong(0)

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL


#Methods
*Prints a warning
public static void main(String[] args)

public DriftingAlignerConcise()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*This concise function should work, but use DriftingAligner instead.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
public static final float alignStaticTrue(byte[] query, byte[] ref, int[] posVector)

*WARNING! This function is nonfunctional demo code.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
@SuppressWarnings public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class DriftingAlignerConcise>
<class DriftingAlignerM>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Restricts alignment to a dynamic band starting at the diagonal.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band widens in response to low sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingAlignerM

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int MATCH_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + MATCH_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long MATCH_MASK=((1L << MATCH_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | MATCH_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long MATCH_INCREMENT=MATCH + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public DriftingAlignerM()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class DriftingAlignerM>
<class DriftingPlusAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens in response to low sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingPlusAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public DriftingPlusAligner()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class DriftingPlusAligner>
<class DriftingPlusAligner2>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens in response to low sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingPlusAligner2

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public DriftingPlusAligner2()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param bandStart Beginning of score band for the previous row
*@param bandEnd End of score band for the previous row
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class DriftingPlusAligner2>
<class DriftingPlusAligner3>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens in response to low sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class DriftingPlusAligner3

#Methods
public DriftingPlusAligner3()

</class DriftingPlusAligner3>
<class Factory>
public class Factory

#Fields
public static final int GLOCAL=1

public static final int BANDED=2

public static final int DRIFTING=3

public static final int WOBBLE=4

public static final int QUANTUM=5

public static final int CROSSCUT=6

public static final int SSA2=7

public static final int SSA3=8

public static final int WAVE=9

public static final String[] types={"NULL","GLOCAL","BANDED","DRIFTING","WOBBLE","QUANTUM","CROSSCUT","SSA2","SSA3","WAVE"}

public static int type=QUANTUM

public static final byte[] codes=makeCodes((byte)(15 + 16))


#Methods
public static IDAligner makeIDAligner()

public static IDAligner makeIDAligner(int type)

*Pads to a multiple of pad, assuming that is a power of 2
public static final long[] encodeLong(byte[] in, byte nCode, int pad)

public static final long[] encodeLong(byte[] in, byte nCode)

public static final int[] encodeInt(byte[] in, byte nCode)

public static final byte[] encodeByte(byte[] in, byte nCode)

public static int setType(String b)

public static final byte[] makeCodes(byte nCode)

</class Factory>
<class FlatAligner>
public final class FlatAligner

#Fields
long iters=0

long itersShort=0

public static final int pointsMatch=120

public static final int pointsSub=-123

public static final int pointsDel=-187

public static final int pointsIns=-243


#Methods
public FlatAligner()

*@param query
*@param ref
*@param qstart
*@param rstart
*@param rstop
*@param minScore Quit early if score drops below this
*@param minRatio Don't return results if max score is less than this fraction of max possible score
*@return
public AlignmentResult alignForward(byte[] query, byte[] ref, int rstart, int rstop, int minScore, float minRatio)

*@param query
*@param ref
*@param qstart
*@param rstart
*@param rstop
*@param minScore Quit early if score drops below this
*@param minRatio Don't return results if max score is less than this fraction of max possible score
*@return
public AlignmentResult alignForwardShort(byte[] query, byte[] ref, int rstart, int rstop, float minRatio)

long iters()

long itersShort()

</class FlatAligner>
<class FlatAligner2>
*FlatAligner with flatter weights
public final class FlatAligner2

#Fields
public static final int pointsMatch=10

public static final int pointsSub=-9

public static final int pointsDel=-11

public static final int pointsIns=-11


#Methods
public FlatAligner2()

</class FlatAligner2>
<class GlocalAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 23, 2025
public class GlocalAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalAligner>
<class GlocalAlignerConcise>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Fills the full matrix for a guaranteed optimal path.
*Calculates operation counts and identity exactly.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla
*@date April 23, 2025
public class GlocalAlignerConcise

#Fields
private static AtomicLong loops=new AtomicLong(0)

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public GlocalAlignerConcise()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param prev Most recent score row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static final float postprocess(long[] prev, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalAlignerConcise>
<class GlocalAlignerInt>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Identity is approximate.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 19, 2024
public class GlocalAlignerInt

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=15

private static final int POSITION_MASK=(1 << POSITION_BITS) - 1

private static final int SCORE_MASK=~POSITION_MASK

private static final int SCORE_SHIFT=POSITION_BITS

private static final int MATCH=1 << SCORE_SHIFT

private static final int MISMATCH=(-1) * (1 << SCORE_SHIFT)

private static final int INS=(-1) * (1 << SCORE_SHIFT)

private static final int DEL=(-1) * (1 << SCORE_SHIFT)

private static final int N_SCORE=0

private static final int BAD=Integer.MIN_VALUE / 2

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public GlocalAlignerInt()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalAlignerInt>
<class GlocalAlignerOld>
public final class GlocalAlignerOld

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

public static final short pointsMatch=1

public static final short pointsSub=-1

public static final short pointsDel=-1

public static final short pointsIns=-1


#Methods
public GlocalAlignerOld()

public static void main(String[] args)

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

public static final float alignForward(byte[] query, byte[] ref)

public long loops()

public void setLoops(long x)

*@param query
*@param ref
*@return Identity
public static final float alignForwardInner(byte[] query, byte[] ref)

</class GlocalAlignerOld>
<class GlocalPlusAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 5, 2025
public class GlocalPlusAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalPlusAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalPlusAligner>
<class GlocalPlusAligner2>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 23, 2025
public class GlocalPlusAligner2

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalPlusAligner2()

private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalPlusAligner2>
<class GlocalPlusAligner3>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 5, 2025
public class GlocalPlusAligner3

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalPlusAligner3()

private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

public long loops()

public void setLoops(long x)

</class GlocalPlusAligner3>
<class GlocalPlusAligner4>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Padded to array length bounds.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 5, 2025
public class GlocalPlusAligner4

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalPlusAligner4()

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalPlusAligner4>
<class GlocalPlusAligner5>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 5, 2025
public class GlocalPlusAligner5

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false


#Methods
public GlocalPlusAligner5()

private static final float postprocess(long[] prev, int qLen, int bandStart, int bandEnd, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class GlocalPlusAligner5>
<interface IDAligner>
*Interface for aligners that can calculate pairwise identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public interface IDAligner

#Methods
*@return Aligner name.
public String name()

*@param q Query sequence
*@param r Reference sequence
*@return Identity (0.0-1.0).
public float align(byte[] q, byte[] r)

*@param q Query sequence
*@param r Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public float align(byte[] q, byte[] r, int[] posVector)

*@param q Query sequence
*@param r Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param rStop Alignment window stop.
*@return Identity (0.0-1.0).
public float align(byte[] q, byte[] r, int[] posVector, int rStart, int rStop)

*@param q Query sequence
*@param r Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param minScore Legacy field to allow early exit in some classes
*@return Identity (0.0-1.0).
public float align(byte[] q, byte[] r, int[] posVector, int minScore)

public long loops()

public void setLoops(long i)

</interface IDAligner>
<class IndelFreeAligner>
*Performs high-throughput indel-free alignments using seed-and-extend or brute force strategies.
*Implements k-mer indexing with rolling hash for query preprocessing and reference indexing.
*Uses SIMD vectorization (AVX2/SSE) for diagonal alignment when sequences are short enough.
*Supports multithreaded processing with work-stealing for reference sequence batches.
*Algorithm: 1) Load all queries into memory with optional k-mer indexing,
*2) Stream reference sequences from disk in batches, 3) For each reference,
*build k-mer index or use brute force, 4) Align all queries against reference,
*5) Output SAM format alignments with proper CIGAR strings and mapping quality.
*@author Brian Bushnell
*@contributor Isla
*@date June 2, 2025
public class IndelFreeAligner

#Fields
*Primary input file path for query sequences (FASTA/FASTQ, optionally compressed)
private String in1=null

*Secondary input file path for paired-end query sequences (may be null for single-end)
private String in2=null

*Output file path for SAM format alignment results
private String out1=null

*Extension override for input file format detection (.fq, .fa, .sam, etc.)
private String extin=null

*Extension override for output file format (.sam, .bam, etc.)
private String extout=null

*File path to reference sequences for alignment (FASTA/FASTQ format)
String refFile=null

*Maximum substitutions allowed per alignment (includes mismatches and N's)
int maxSubs=5

*K-mer length for seed matching and indexing (1-15, affects sensitivity vs speed)
int k=13

*Length of middle region to mask in k-mers for fuzzy matching tolerance
int midMaskLen=1

*Enable k-mer indexing for seed-and-extend alignment strategy
boolean indexQueries=true

*Perform fast pre-screening to count shared k-mers before full seed matching
boolean prescan=true

*Sampling interval for query k-mers (1=every k-mer, 2=every other, reduces sensitivity)
int qStep=1

*Minimum seed hits required for alignment consideration (higher = more selective)
int minSeedHits=1

*Probability threshold for calculating minimum hits based on query length
private float minHitsProb=0.9999f

*Use hash map for seed hit counting instead of list-based approach
boolean useSeedMap=false

*Total reference sequences processed across all worker threads
protected long readsProcessed=0

*Total reference bases processed across all worker threads
protected long basesProcessed=0

*Total alignment operations attempted across all worker threads
protected long alignmentCount=0

*Total k-mer seed hits found during indexed alignment across all threads
protected long seedHitCount=0

*Total valid alignments written to output files
protected long readsOut=0

*Total bases in valid alignments written to output files
protected long basesOut=0

*Maximum reference sequences to process (-1 for unlimited processing)
private long maxReads=-1

*File format configuration for primary query input stream
private final FileFormat ffin1

*File format configuration for secondary query input stream (paired-end)
private final FileFormat ffin2

*File format configuration for SAM/BAM output stream
private final FileFormat ffout1

*Thread synchronization lock for coordinating access to shared statistics and resources
private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Output stream for status messages and progress reporting
private PrintStream outstream=System.err

*Enable verbose output including timing and debugging information
public static boolean verbose=false

*Global error flag set when any worker thread encounters an error
public boolean errorState=false

*Allow overwriting of existing output files
private boolean overwrite=true

*Append results to existing output files instead of overwriting
private boolean append=false


#Methods
*Main entry point that initializes timer, creates aligner instance, and processes alignments.
*Follows standard BBTools pattern: timer start, object creation, processing, stream cleanup.
*@param args Command line arguments including reference file, query files, and alignment parameters
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public IndelFreeAligner(String[] args)

*Parses command line arguments using key=value format and configures alignment parameters.
*Processes specialized arguments like ref, subs, k, hits, and delegates standard arguments
*to Parser class. Validates parameter ranges and logical consistency during parsing.
*@param args Command line arguments in key=value format
*@return Configured Parser object with file paths and standard BBTools settings
private Parser parse(String[] args)

*Expands paired-end filename template using # symbol replacement.
*Converts "reads#.fq" to separate "reads1.fq" and "reads2.fq" files when
*original file with # doesn't exist. Standard BBTools convention for paired files.
private void doPoundReplacement()

*Automatically detects and adds compression extensions (.gz, .bz2) to file paths.
*Uses Tools.fixExtension() to ensure proper handling of compressed input/output files.
private void fixExtensions()

*Performs comprehensive alignment testing all possible positions.
*Uses SIMD optimization when available and appropriate.
*@param query Query sequence bases
*@param ref Reference sequence bases
*@param maxSubs Maximum allowed substitutions
*@param maxClips Maximum allowed clipped bases
*@return List of all alignment positions with maxSubs substitutions, or null if none found
private void checkFileExistence()

*Optimizes static file I/O settings based on available thread count.
*Enables ByteFile mode BF2 (multithreaded) when >2 threads available for better
*I/O performance. Validates FastaReadInputStream configuration consistency.
private static void checkStatics()

*Validates alignment parameter constraints and logical consistency.
*Ensures: k-mer length 1-15 when indexing enabled, hit probability 1.0,
*middle mask length < k-1, substitution count 0. Critical for preventing
*array bounds violations and algorithmic correctness.
*@return True if all parameters satisfy mathematical and algorithmic constraints
private boolean validateParams()

*Orchestrates complete alignment workflow using producer-consumer pattern.
*Algorithm: 1) Load all queries into memory with k-mer preprocessing,
*2) Configure read validation and buffer sizes for optimal parallelization,
*3) Create concurrent input stream for reference sequences,
*4) Spawn worker threads using ThreadWaiter pattern,
*5) Accumulate statistics and handle cleanup.
*Uses temporary buffer size reduction to improve parallelization for small references.
*@param t Timer for measuring total processing time and throughput calculation
void process(Timer t)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ByteStreamWriter bsw, ArrayList<Query> qList)

*Thread-safe accumulation of processing statistics from completed worker threads.
*Called by ThreadWaiter framework when each worker thread finishes. Synchronizes
*on thread object to safely aggregate read counts, base counts, alignment counts,
*and error states from all worker threads into main statistics counters.
*@param pt Completed ProcessThread containing per-thread statistics and success status
@Override public final void accumulate(ProcessThread pt)

*Indicates whether all worker threads completed successfully without errors.
*Used by ThreadWaiter framework to determine overall job success status.
*@return True if no worker thread encountered errors during alignment processing
@Override public final boolean success()

*Initializes concurrent input stream for reference sequences with automatic format detection.
*Creates FileFormat object, configures ConcurrentReadInputStream for multi-threaded access,
*and starts the input stream immediately. Stream will provide reference sequence batches
*to worker threads using producer-consumer pattern.
*@param fname File path to reference sequences (FASTA/FASTQ, optionally compressed)
*@return Started ConcurrentReadInputStream ready for batch consumption by worker threads
private ConcurrentReadInputStream makeCris(String fname)

*Loads query sequences from input files and converts them to Query objects.
*Pre-computes k-mer indices and alignment parameters for each query.
*@param ff1 Primary input file format
*@param ff2 Secondary input file format (may be null)
*@return List of Query objects ready for alignment
public ArrayList<Query> fetchQueries(FileFormat ff1, FileFormat ff2)

*Performs sparse alignment using seed hits to guide alignment positions.
*More efficient than brute force when seed hits are available and selective.
*@param query Query sequence bases
*@param ref Reference sequence bases
*@param maxSubs Maximum allowed substitutions
*@param maxClips Maximum allowed clipped bases
*@param seedHits List of potential alignment start positions from seed matching
*@return List of alignment start positions with maxSubs substitutions, or null if none found
public static IntList alignSparse(byte[] query, byte[] ref, int maxSubs, int maxClips, IntList seedHits)

*Performs comprehensive alignment testing all possible positions.
*Uses SIMD optimization when available and appropriate.
*@param query Query sequence bases
*@param ref Reference sequence bases
*@param maxSubs Maximum allowed substitutions
*@param maxClips Maximum allowed clipped bases
*@return List of all alignment positions with maxSubs substitutions, or null if none found
public static IntList alignAllPositions(byte[] query, byte[] ref, int maxSubs, int maxClips)

*Aligns query to reference starting at specified position with no clipping.
*Optimized for cases where query fits completely within reference bounds.
*@param query Query sequence bases
*@param ref Reference sequence bases
*@param maxSubs Maximum allowed substitutions (for early termination)
*@param rStart Starting position in reference (0-based)
*@return Number of substitutions found
static int align(byte[] query, byte[] ref, int maxSubs, int rStart)

*Performs alignment with soft clipping support for query overhangs beyond reference boundaries.
*Algorithm: 1) Calculate left and right clipping amounts based on position,
*2) Count excess clipping beyond maxClips threshold as substitutions,
*3) Align overlapping region counting mismatches and ambiguous bases,
*4) Return total penalty including substitutions and excess clipping.
*Used for alignments where query extends past reference start (negative rStart)
*or end (rStart + query.length > ref.length).
*@param query Query sequence bases to align with clipping
*@param ref Reference sequence bases to align against
*@param maxSubs Maximum substitutions allowed in aligned region
*@param maxClips Maximum soft-clipped bases allowed without penalty
*@param rStart Starting position in reference (may be negative for left overhang)
*@return Total alignment penalty: substitutions + max(0, excess_clipping)
static int alignClipped(byte[] query, byte[] ref, int maxSubs, int maxClips, int rStart)

*Builds a k-mer index for a reference sequence.
*Maps masked k-mers to their positions for efficient seed finding.
*@param ref Reference sequence bases
*@return Hash map from masked k-mers to lists of positions, or null if indexing disabled
IntListHashMap buildReferenceIndex(byte[] ref)

*Converts alignment hits into properly formatted SAM output with full metadata.
*Algorithm: 1) For each hit position, generate match string using toMatch(),
*2) Create SamLine object with proper coordinates, flags, and sequence orientation,
*3) Generate CIGAR string from match string accounting for clipping and reference bounds,
*4) Calculate mapping quality based on alignment length and substitution count,
*5) Add NM optional tag with edit distance, 6) Batch output for efficiency.
*Sets primary flag only for first hit, uses appropriate strand orientation,
*and converts 0-based internal coordinates to 1-based SAM coordinates.
*@param q Query sequence containing bases, quality scores, and metadata
*@param ref Reference sequence containing bases and sequence identifier
*@param hits List of valid alignment start positions (0-based coordinates)
*@param reverseStrand True if alignments use reverse complement query sequence
*@param count Running total of alignments for this query (affects primary/secondary flags)
*@param bsw Thread-safe output writer for batched SAM format data
*@return Number of alignment records generated and queued for output
static int processHits(Query q, Read ref, IntList hits, boolean reverseStrand, int count, ByteStreamWriter bsw)

*Creates position-by-position match string for CIGAR string generation.
*Algorithm: For each query position, determine if reference position is in-bounds,
*compare bases using fully-defined nucleotide check, and assign match codes:
*'m'=perfect match, 'S'=substitution within reference, 'C'=clipped outside reference.
*Uses sentinel character '$' for out-of-bounds reference positions.
*@param query Query sequence bases to align
*@param ref Reference sequence bases to compare against
*@param rStart Starting position in reference sequence (may be negative)
*@param match ByteBuilder to append match string characters
static void toMatch(byte[] query, byte[] ref, int rStart, ByteBuilder match)

*Provides read-write lock for thread-safe access to shared resources.
*Required by Accumulator interface for coordinating worker thread synchronization.
*@return ReentrantReadWriteLock instance for managing concurrent access
@Override public final ReadWriteLock rwlock()

</class IndelFreeAligner>
<class IndelFreeAligner.ProcessThread>
*Worker thread for processing reference sequences against query set.
*This class is static to prevent accidental writing to shared variables.
*Each thread processes a portion of the reference stream independently.
class IndelFreeAligner.ProcessThread

#Fields
*Reference sequences processed by this worker thread
protected long readsProcessedT=0

*Reference bases processed by this worker thread
protected long basesProcessedT=0

*Alignment operations performed by this worker thread
protected long alignmentsT=0

*K-mer seed hits found by this worker thread during indexed alignment
protected long seedHitsT=0

*Valid alignments generated by this worker thread
protected long readsOutT=0

*Total bases in valid alignments generated by this worker thread
protected long basesOutT=0

*Success flag indicating thread completed without errors
boolean success=false

*Thread-safe input stream providing reference sequence batches
private final ConcurrentReadInputStream cris

*Thread-safe output writer for SAM format alignment results
private final ByteStreamWriter bsw

*Shared list of preprocessed Query objects to align against references
private final ArrayList<Query> queries

*Maximum substitutions threshold for alignment acceptance
final int maxSubs

*Unique identifier for this worker thread
final int tid


#Methods
*Initializes worker thread with shared resources and processing parameters.
*Thread stores references to shared input/output streams but maintains private
*statistics counters and processing state to avoid synchronization overhead.
*@param cris_ Thread-safe input stream providing reference sequence batches
*@param bsw_ Thread-safe output writer for SAM format alignment results
*@param qList Shared read-only list of preprocessed Query objects
*@param maxSubs_ Maximum substitutions threshold for alignment acceptance
*@param tid_ Unique thread identifier for debugging and coordination
ProcessThread(ConcurrentReadInputStream cris_, ByteStreamWriter bsw_, ArrayList<Query> qList, int maxSubs_, int tid_)

*Main thread execution method implementing standard BBTools thread pattern.
*Calls processInner() to perform actual work, then synchronizes to set
*success flag indicating completion without errors. ThreadWaiter framework
*monitors this flag to determine when to call accumulate() method.
@Override public void run()

*Implements producer-consumer pattern consuming reference sequence batches until exhaustion.
*Algorithm: 1) Request next batch from shared input stream,
*2) Process all references in batch against all queries,
*3) Return batch to stream signaling completion,
*4) Repeat until stream empty. Proper batch return ensures input stream
*can track completion and terminate cleanly when all batches processed.
void processInner()

*Processes one batch of reference sequences performing validation and alignment.
*Algorithm: 1) For each reference in batch, validate sequence if needed,
*2) Track statistics for read counts and base counts,
*3) Align all queries against this reference using processRefSequence().
*Validation occurs in worker threads to avoid blocking main thread.
*@param ln ListNum wrapper containing reference sequence batch with completion tracking
void processList(ListNum<Read> ln)

*Routes seed hit finding to appropriate algorithm based on configuration.
*Delegates to either map-based counting approach (better for high hit density)
*or list-based approach (better for low hit density) based on useSeedMap flag.
*@param q Query sequence containing k-mer arrays for seed matching
*@param refIndex Reference k-mer index for lookup of matching positions
*@param reverseStrand True to use reverse complement k-mers from query
*@param hitCounts Reusable IntHashMap for position hit counting (map approach only)
*@param rname Reference sequence name for debugging output
*@return List of alignment start positions meeting minimum seed hit threshold
private IntList getSeedHits(Query q, IntListHashMap refIndex, boolean reverseStrand, IntHashMap hitCounts, String rname)

*Finds seed hits using list-based approach. Potentially slow with short kmers.
*@param q Query sequence to search for
*@param refIndex K-mer index of reference
*@param reverseStrand True to use reverse complement query
*@return List of alignment positions meeting minimum hit threshold
private IntList getSeedHitsList(Query q, IntListHashMap refIndex, boolean reverseStrand)

*Finds seed hits using list-based approach. Potentially slow with short kmers.
*@param q Query sequence to search for
*@param refIndex K-mer index of reference
*@param reverseStrand True to use reverse complement query
*@return List of alignment positions meeting minimum hit threshold
private IntList getSeedHitsMap(Query q, IntListHashMap refIndex, boolean reverseStrand, IntHashMap hitCounts)

*Finds seed hits using map-based approach for efficient hit counting.
*More efficient when many hits are expected per position.
*@param q Query sequence to analyze
*@param refIndex Reference index for k-mer lookup
*@param reverseStrand Flag indicating reverse complement strand
*@return Number of query kmers shared with the ref
private int prescan(Query q, IntListHashMap refIndex, boolean reverseStrand, int minHits)

*Dispatches reference sequence processing to optimal alignment strategy.
*Uses indexed seed-and-extend approach when k-mer indexing enabled for efficiency
*with selective seed hits, otherwise uses brute force testing all positions.
*@param ref Reference sequence to align all queries against
*@return Total alignment count across all queries for this reference
long processRefSequence(Read ref)

*Processes reference sequence using indexed seed-and-extend approach.
*More efficient for longer references with selective seed hits.
*@param ref Reference sequence to process
*@return Total number of alignments found across all queries
long processRefSequenceIndexed(Read ref)

*Processes reference sequence using indexed seed-and-extend approach.
*More efficient for longer references with selective seed hits.
*@param ref Reference sequence to process
*@return Total number of alignments found across all queries
long processRefSequenceBrute(Read ref)

</class IndelFreeAligner.ProcessThread>
<class IntIndex>
public class IntIndex

#Fields
final int k

final IntListHashMap map


#Methods
public IntIndex(byte[] ref, int k_)

private void indexRef(byte[] ref)

public IntList getCandidates(byte[] query, int maxHits)

</class IntIndex>
<class IntListAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2024
public class IntListAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long MISMATCH=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=1L << POSITION_BITS

private static final long DEL_INCREMENT2=DEL_INCREMENT + DEL


#Methods
public IntListAligner()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class IntListAligner>
<class Ksw2gg>
*Java port of Heng Li's banded global aligner with affine gap penalties.
*Processes alignment using diagonal bands to limit computation space.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 21, 2025
public class Ksw2gg

#Fields
private static final int NEG_INF=-1000000000

private int matchScore=1

private int mismatchScore=-1

private int gapOpen=-1

private int gapExtend=-1

private int bandWidth=-1

private long loops=-1


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public Ksw2gg()

public Ksw2gg(int match, int mismatch, int gapOpen, int gapExtend, int bandWidth)

@Override public String name()

@Override public float align(byte[] query, byte[] ref)

@Override public float align(byte[] query, byte[] ref, int[] posVector)

@Override public float align(byte[] query, byte[] ref, int[] posVector, int minScore)

@Override public float align(byte[] query, byte[] ref, int[] posVector, int rStart, int rStop)

private int alignSequences(byte[] query, byte[] ref, int[] posVector)

private void processCigar(byte[] z, int[] off, int nCol, int tlen, int qlen, int[] posVector)

@Override public long loops()

@Override public void setLoops(long i)

</class Ksw2gg>
<class Eh>
class Eh

#Fields
int h

int e

</class Eh>
<class KswGgJava>
public class KswGgJava

#Fields
static final int MATCH=1

static final int MISMATCH=-1

static final int INS=-1

static final int DEL=-1

static final int KSW_NEG_INF=Integer.MIN_VALUE

static final int GAPO=1

static final int GAPE=1

private long loops=0


#Methods
@Override public String name()

@Override public float align(byte[] q, byte[] r)

@Override public float align(byte[] q, byte[] r, int[] posVector)

@Override public float align(byte[] q, byte[] r, int[] posVector, int rStart, int rStop)

@Override public float align(byte[] q, byte[] r, int[] posVector, int minScore)

private float align(byte[] q, byte[] r, int[] posVector, int minScore, int rStart, int rStop)

@Override public long loops()

@Override public void setLoops(long i)

</class KswGgJava>
<interface MicroAligner>
public interface MicroAligner

#Methods
*Returns identity
public float map(Read r)

*Returns identity
public float map(Read r, float minid)

</interface MicroAligner>
<class MicroAligner2>
*Similar to MicroAligner, but designed to only test whether something matches,
*not generate match strings.
*@author Brian Bushnell
*@date May 24, 2024
public class MicroAligner2

#Fields
final float minIdentity

final float maxSubFraction

final int k

final int k2

final byte[] ref

final LongHashMap map

public int skipmask=0

public long mapCount=0

public long quickAligns=0

public long slowAligns=0

public long metCutoff=0

public double idSum=0

private static final int MINUS_CODE=1000000000


#Methods
public MicroAligner2(int k_, float minIdentity_, String path)

public MicroAligner2(int k_, float minIdentity_, byte[] ref_)

public MicroAligner2(int k_, float minIdentity_, byte[] ref_, LongHashMap map_)

private static byte[] loadRef(String path)

private static LongHashMap indexRef(int k, byte[] ref)

*Returns identity
public float map(Read r)

*Returns identity
public float map(Read r, float minid)

public float align(Read r, byte[] ref, int a, int b, int pad, float minIdentity, int[] extra)

public float quickAlign(Read read, byte[] ref, int a)

</class MicroAligner2>
<class MicroAligner3>
*Aligns reads to a small, single sequence reference like PhiX.
*The reference should not have any duplicate kmers.
*Alignment is only attempted once, at the first matching kmer.
*This will generate a match string and return the identity.
*Mapped reads can be printed as sam output.
*@author Brian Bushnell
*@date November 15, 2024
public class MicroAligner3

#Fields
final float minIdentity

final float maxSubFraction

final int k

final int k2

final long middleMask

final MicroIndex3 index

final SingleStateAlignerFlat2 mySSA

final ByteBuilder myBuffer

final boolean shared

private static final float nMult=1024

private static final float nMultInv=1.0f / nMult

private static final ThreadLocal<ByteBuilder> bufferHolder=new ThreadLocal<ByteBuilder>()


#Methods
public MicroAligner3(MicroIndex3 index_, float minIdentity_, boolean shared_)

*Returns identity
public float map(Read r)

*Returns identity
public float map(Read r, float minid)

public float align(Read r, byte[] ref, int a, int b, int pad, float minid)

*Returns identity (approx, in the case of Ns)
public float quickAlign(Read read, byte[] ref, int a, float minid)

private final SingleStateAlignerFlat2 getSSA()

private final ByteBuilder getBuffer()

private static final ByteBuilder buffer()

public LongHashMap getMap()

</class MicroAligner3>
<class MicroIndex3>
*Index for a MicroAligner.
*@author Brian Bushnell
*@date November 15, 2024
public class MicroIndex3

#Fields
final int k

final int k2

final int midMaskLen

final long middleMask

private final String refname

final byte[] ref

final LongHashMap map

static final int MINUS_CODE=1000000000

static final int NO_HIT=Integer.MIN_VALUE


#Methods
public MicroIndex3(int k_, int midMaskLen_, String path, boolean setSamStatics)

public MicroIndex3(int k_, int midMaskLen_, Read r)

public static long makeMidMask(int k, int midMaskLen)

public static Read loadRef(String path, boolean setSamStatics)

public void index()

private static LongHashMap indexRef(int k, long midMask, byte[] ref, LongHashMap map)

*Returns first hit location.
*@param r Read to map.
*@return (offset<<1)|strand
public long map(Read r)

public LongHashMap getMap()

</class MicroIndex3>
<class MicroWrapper>
*This class does nothing.
*It is designed to be easily modified into a program
*that processes reads in multiple threads, by
*filling in the processReadPair method.
*@author Brian Bushnell
*@date November 19, 2015
public class MicroWrapper

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

*Primary output file path
private String out1=null

*Secondary output file path
private String out2=null

*Primary output file path
private String outu1=null

*Secondary output file path
private String outu2=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Number of reads retained
protected long readsMapped=0

*Number of bases retained
protected long basesMapped=0

protected double identitySum=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

public int k1=17

public int k2=13

public float minIdentity1=0.66f

public float minIdentity2=0.56f

public int mm1=1

public int mm2=1

public final MicroIndex3 index1

public final MicroIndex3 index2

public String ref

boolean mappedOnly=false

final boolean makeReadStats

final boolean samOutput

public static boolean TRACK_STATS=true

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Primary output file
private final FileFormat ffout1

*Secondary output file
private final FileFormat ffout2

*Primary output file
private final FileFormat ffoutu1

*Secondary output file
private final FileFormat ffoutu2

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public MicroWrapper(String[] args)

void fixK()

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(FileFormat ff1, FileFormat ff2, boolean pairedInput)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros, ConcurrentReadOutputStream rosu)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

public String stats(long readsIn, long basesIn)

@Override public final ReadWriteLock rwlock()

</class MicroWrapper>
<class MicroWrapper.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class MicroWrapper.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*Number of reads mapped by this thread
protected long readsMappedT=0

*Number of bases mapped by this thread
protected long basesMappedT=0

protected double identitySumT=0

*True only if this thread has completed successfully
boolean success=false

final ReadStats readstats

final MicroAligner3 mapper1

final MicroAligner3 mapper2

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream ros

*Shared unmapped output stream
private final ConcurrentReadOutputStream rosu

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream ros_, ConcurrentReadOutputStream rosu_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
boolean processReadPair(Read r1, Read r2)

public boolean map(Read r1, Read r2)

</class MicroWrapper.ProcessThread>
<class MinHitsCalculator>
*Calculates the minimum number of seed hits needed
*to ensure all valid indel-free alignments are found
*with a specified probability threshold.
*Uses Monte Carlo simulation to account for wildcard
*masking, error patterns, and clipping allowances.
*@author Brian Bushnell
*@contributor Isla SOS
*@date June 4, 2025
public class MinHitsCalculator

#Fields
*K-mer length
private final int k

*Maximum allowed substitutions in alignment
private final int maxSubs

*Number of wildcard bases in middle of k-mer
private final int midMaskLen

*Maximum clipping allowed as fraction or absolute value
private final float maxClipFraction

*Bit mask for k-mer (may not be needed)
private final int kMask

*Bit mask for middle wildcard positions (may not be needed)
private final int midMask

*Minimum probability of detecting valid alignments (0.0-1.0)
private final float minProb

*Boolean array indicating wildcard positions in k-mer
private final boolean[] wildcards

*Cache mapping valid k-mer count to minimum required hits
private final IntHashMap validKmerToMinHits=new IntHashMap()

*Random number generator for simulation
private final Random randy=Shared.threadLocalRandom(1)

*Number of Monte Carlo iterations for simulation
public static int iterations=100000


#Methods
*Constructor for minimum hits calculator.
*@param k_ K-mer length
*@param maxSubs_ Maximum allowed substitutions in alignment
*@param midMaskLen_ Number of wildcard bases in middle of k-mer
*@param minProb_ Minimum probability of detecting valid alignments (0.0-1.0)
*@param maxClip_ Maximum clipping allowed (fraction <1 or absolute 1)
public MinHitsCalculator(int k_, int maxSubs_, int midMaskLen_, float minProb_, float maxClip_)

*Creates a boolean array indicating which k-mer positions are wildcarded.
*Wildcard positions are set to true for efficient short-circuiting.
*@param k K-mer length
*@param midMaskLen Number of consecutive wildcard bases in middle
*@return Boolean array where true indicates wildcard position
private boolean[] makeWildcardPattern(int k, int midMaskLen)

*Counts k-mers that would still match despite errors, accounting for wildcards.
*A k-mer is considered error-free if no errors fall on non-wildcard positions.
*@param errors BitSet indicating error positions in query sequence
*@param wildcards Boolean array indicating wildcard positions in k-mer
*@param queryLen Length of query sequence
*@return Number of k-mers that remain matchable
private int countErrorFreeKmers(BitSet errors, boolean[] wildcards, int queryLen)

*Simulates random error patterns to determine minimum seed hits needed.
*Uses Monte Carlo simulation to find the threshold that ensures
*the specified probability of detecting valid alignments.
*@param validKmers Number of valid k-mers in query sequence
*@return Minimum number of seed hits needed
private int simulate(int validKmers)

*Gets the minimum number of seed hits required for a query with
*the specified number of valid k-mers. Results are cached.
*@param validKmers Number of valid k-mers in query sequence
*@return Minimum seed hits needed to ensure detection probability
public int minHits(int validKmers)

</class MinHitsCalculator>
<class MinHitsCalculatorOld>
*Calculates the minimum number of seed hits needed
*to ensure all valid indel-free alignments are found
*with a specified probability threshold.
*Uses Monte Carlo simulation to account for wildcard
*masking and error patterns.
*@author Brian Bushnell
*@contributor Isla SOS
*@date June 4, 2025
public class MinHitsCalculatorOld

#Fields
*K-mer length
private final int k

*Maximum allowed substitutions in alignment
private final int maxSubs

*Number of wildcard bases in middle of k-mer
private final int midMaskLen

*Bit mask for k-mer (may not be needed)
private final int kMask

*Bit mask for middle wildcard positions (may not be needed)
private final int midMask

*Minimum probability of detecting valid alignments (0.0-1.0)
private final float minProb

*Boolean array indicating wildcard positions in k-mer
private final boolean[] wildcards

*Cache mapping valid k-mer count to minimum required hits
private final IntHashMap validKmerToMinHits=new IntHashMap()

*Random number generator for simulation
private final Random randy=Shared.threadLocalRandom(1)

*Number of Monte Carlo iterations for simulation
public static int iterations=100000


#Methods
*Constructor for minimum hits calculator.
*@param k_ K-mer length
*@param maxSubs_ Maximum allowed substitutions in alignment
*@param midMaskLen_ Number of wildcard bases in middle of k-mer
*@param minProb_ Minimum probability of detecting valid alignments (0.0-1.0)
public MinHitsCalculatorOld(int k_, int maxSubs_, int midMaskLen_, float minProb_)

*Creates a boolean array indicating which k-mer positions are wildcarded.
*Wildcard positions are set to true for efficient short-circuiting.
*@param k K-mer length
*@param midMaskLen Number of consecutive wildcard bases in middle
*@return Boolean array where true indicates wildcard position
private boolean[] makeWildcardPattern(int k, int midMaskLen)

*Counts k-mers that would still match despite errors, accounting for wildcards.
*A k-mer is considered error-free if no errors fall on non-wildcard positions.
*@param errors BitSet indicating error positions in query sequence
*@param wildcards Boolean array indicating wildcard positions in k-mer
*@return Number of k-mers that remain matchable
private int countErrorFreeKmers(BitSet errors, boolean[] wildcards, int queryLen)

*Simulates random error patterns to determine minimum seed hits needed.
*Uses Monte Carlo simulation to find the threshold that ensures
*the specified probability of detecting valid alignments.
*@param validKmers Number of valid k-mers in query sequence
*@return Minimum number of seed hits needed
private int simulate(int validKmers)

*Gets the minimum number of seed hits required for a query with
*the specified number of valid k-mers. Results are cached.
*@param validKmers Number of valid k-mers in query sequence
*@return Minimum seed hits needed to ensure detection probability
public int minHits(int validKmers)

</class MinHitsCalculatorOld>
<class MSAViz>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MSAViz

#Fields
String output=null

public int maxRows

public int maxColumns

private int[][][] packed

public int[] vertLimit

public int[] horizLimit

public static final int TIMEBITS=12

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

private static final byte MODE_MS=0

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

public static final int POINTS_NOREF=-6

public static final int POINTS_NOCALL=-6

public static final int POINTS_MATCH=45

public static final int POINTS_MATCH2=50

public static final int POINTS_COMPATIBLE=25

public static final int POINTS_SUB=-72

public static final int POINTS_SUBR=-81

public static final int POINTS_SUB2=-30

public static final int POINTS_SUB3=-18

public static final int POINTS_MATCHSUB=-5

public static final int POINTS_INS=-107

public static final int POINTS_INS2=-27

public static final int POINTS_INS3=-20

public static final int POINTS_INS4=-9

public static final int POINTS_DEL=-129

public static final int POINTS_DEL2=-18

public static final int POINTS_DEL3=-13

public static final int POINTS_DEL4=-7

public static final int POINTS_DEL_REF_N=-5

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=30

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
@Override public float align(byte[] q, byte[] r)

@Override public float align(byte[] q, byte[] r, int[] posVector)

@Override public float align(byte[] q, byte[] r, int[] posVector, int minScore)

@Override public float align(byte[] q, byte[] r, int[] posVector, int rStart, int rStop)

public float align(byte[] q, byte[] r, int[] pos, int from, int to, int minScore)

@Override public long loops()

public void setLoops(long x)

public MSAViz()

private void initialize(int rows_, int columns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final int scoreNoIndels(byte[] read, SiteScore ss)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart)

public static final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public static final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

public static final int maxQuality(int numBases)

public static final int maxQuality(byte[] baseScores)

public static final int maxImperfectScore(int numBases)

public static final int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

public static final String toTimePacked(int[] a)

public static final String toScorePacked(int[] a)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public int rows()

@Override public int columns()

CharSequence showVertLimit()

CharSequence showHorizLimit()

</class MSAViz>
<class MultiStateAligner9PacBioAdapter>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9PacBioAdapter

#Fields
private final int maxRows

private final int maxColumns

private final int[][][] packed

private final int[] vertLimit

private final int[] horizLimit

private final int[] insScoreArray

private final int[] delScoreArray

private final int[] matchScoreArray

private final int[] subScoreArray

public static final int TIMEBITS=12

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

private static final byte MODE_MS=0

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

public static final int POINTS_NOREF=-10

public static final int POINTS_NOCALL=-10

public static final int POINTS_MATCH=90

public static final int POINTS_MATCH2=100

public static final int POINTS_SUB=-143

public static final int POINTS_SUBR=-161

public static final int POINTS_SUB2=-54

public static final int POINTS_SUB3=-35

public static final int POINTS_INS=-207

public static final int POINTS_INS2=-51

public static final int POINTS_INS3=-37

public static final int POINTS_INS4=-15

public static final int POINTS_DEL=-273

public static final int POINTS_DEL2=-38

public static final int POINTS_DEL3=-27

public static final int LIMIT_FOR_COST_3=5

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
public MultiStateAligner9PacBioAdapter(int maxRows_, int maxColumns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Generates the match string
public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final int scoreNoIndels(byte[] read, SiteScore ss)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart)

public static final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public static final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

public static final int maxQuality(int numBases)

public static final int maxQuality(byte[] baseScores)

public static final int maxImperfectScore(int numBases)

public static final int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

public static final String toTimePacked(int[] a)

public static final String toScorePacked(int[] a)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

CharSequence showVertLimit()

CharSequence showHorizLimit()

</class MultiStateAligner9PacBioAdapter>
<class MultiStateAligner9PacBioAdapter2>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9PacBioAdapter2

#Fields
public int maxRows

public int maxColumns

private int[][][] packed

public int[] vertLimit

public int[] horizLimit

public static final int TIMEBITS=12

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

private static final byte MODE_MS=0

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

public static final int POINTS_NOREF=-6

public static final int POINTS_NOCALL=-6

public static final int POINTS_MATCH=45

public static final int POINTS_MATCH2=50

public static final int POINTS_COMPATIBLE=25

public static final int POINTS_SUB=-72

public static final int POINTS_SUBR=-81

public static final int POINTS_SUB2=-30

public static final int POINTS_SUB3=-18

public static final int POINTS_MATCHSUB=-5

public static final int POINTS_INS=-107

public static final int POINTS_INS2=-27

public static final int POINTS_INS3=-20

public static final int POINTS_INS4=-9

public static final int POINTS_DEL=-129

public static final int POINTS_DEL2=-18

public static final int POINTS_DEL3=-13

public static final int POINTS_DEL4=-7

public static final int POINTS_DEL_REF_N=-5

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=30

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
public MultiStateAligner9PacBioAdapter2()

private void initialize(int rows_, int columns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Override public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final int scoreNoIndels(byte[] read, SiteScore ss)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart)

public static final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public static final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

public static final int maxQuality(int numBases)

public static final int maxQuality(byte[] baseScores)

public static final int maxImperfectScore(int numBases)

public static final int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

public static final String toTimePacked(int[] a)

public static final String toScorePacked(int[] a)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

@Override public int rows()

@Override public int columns()

CharSequence showVertLimit()

CharSequence showHorizLimit()

</class MultiStateAligner9PacBioAdapter2>
<class MultiStateAligner9PacBioAdapter3>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9PacBioAdapter3

#Fields
private final int maxRows

private final int maxColumns

private final int[][][] packed

private final int[] vertLimit

private final int[] horizLimit

private final int[] insScoreArray

private final int[] delScoreArray

private final int[] matchScoreArray

private final int[] subScoreArray

public static final int TIMEBITS=12

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

private static final byte MODE_MS=0

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

public static final int POINTS_NOREF=-10

public static final int POINTS_NOCALL=-10

public static final int POINTS_MATCH=90

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-143

public static final int POINTS_SUBR=-161

public static final int POINTS_SUB2=-54

public static final int POINTS_SUB3=-35

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-207

public static final int POINTS_INS2=-51

public static final int POINTS_INS3=-37

public static final int POINTS_INS4=-15

public static final int POINTS_DEL=-273

public static final int POINTS_DEL2=-38

public static final int POINTS_DEL3=-27

public static final int POINTS_DEL4=-15

public static final int POINTS_DEL_REF_N=-10

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=30

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
public MultiStateAligner9PacBioAdapter3(int maxRows_, int maxColumns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*Generates the match string
public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final int scoreNoIndels(byte[] read, SiteScore ss)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart)

public static final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public static final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

public static final int maxQuality(int numBases)

public static final int maxQuality(byte[] baseScores)

public static final int maxImperfectScore(int numBases)

public static final int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

public static final String toTimePacked(int[] a)

public static final String toScorePacked(int[] a)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

private static int calcMatchScoreOffset(int len)

private static int calcSubScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

CharSequence showVertLimit()

CharSequence showHorizLimit()

</class MultiStateAligner9PacBioAdapter3>
<class MultiStateAligner9PacBioAdapter_WithBarriers>
*Based on MSA9ts, with transform scores tweaked for PacBio.
public final class MultiStateAligner9PacBioAdapter_WithBarriers

#Fields
public final int maxRows

public final int maxColumns

private final int[][][] packed

private final byte[] grefbuffer

private int greflimit=-1

private int greflimit2=-1

private int grefRefOrigin=-1

public static final int GAPBUFFER=Shared.GAPBUFFER

public static final int GAPBUFFER2=Shared.GAPBUFFER2

public static final int GAPLEN=Shared.GAPLEN

public static final int MINGAP=Shared.MINGAP

public static final int GAPCOST=Shared.GAPCOST * 2

public static final byte GAPC=Shared.GAPC

private static final int GREFLIMIT2_CUSHION=128

public final int[] vertLimit

public final int[] horizLimit

public static final int TIMEBITS=12

public static final int SCOREBITS=32 - TIMEBITS

public static final int MAX_TIME=((1 << TIMEBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int SCOREOFFSET=TIMEBITS

public static final int TIMEMASK=~((-1) << TIMEBITS)

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

private static final byte MODE_MS=0

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

public static final int POINTS_NOREF=-8

public static final int POINTS_NOCALL=-8

public static final int POINTS_MATCH=90

public static final int POINTS_MATCH2=100

public static final int POINTS_COMPATIBLE=50

public static final int POINTS_SUB=-141

public static final int POINTS_SUBR=-159

public static final int POINTS_SUB2=-49

public static final int POINTS_SUB3=-27

public static final int POINTS_MATCHSUB=-10

public static final int POINTS_INS=-204

public static final int POINTS_INS2=-42

public static final int POINTS_INS3=-25

public static final int POINTS_INS4=-8

public static final int POINTS_DEL=-287

public static final int POINTS_DEL2=-39

public static final int POINTS_DEL3=-21

public static final int POINTS_DEL4=-12

public static final int POINTS_DEL5=-8

public static final int POINTS_DEL_REF_N=-10

public static final int POINTS_GAP=0 - GAPCOST

public static final int TIMESLIP=4

public static final int MASK5=TIMESLIP - 1

private static final int BARRIER_I1=0

private static final int BARRIER_D1=0

public static final int LIMIT_FOR_COST_3=5

public static final int LIMIT_FOR_COST_4=25

public static final int LIMIT_FOR_COST_5=80

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOCALL=(POINTS_NOCALL << SCOREOFFSET)

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_COMPATIBLE=(POINTS_COMPATIBLE << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUBR=(POINTS_SUBR << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_SUB3=(POINTS_SUB3 << SCOREOFFSET)

public static final int POINTSoff_MATCHSUB=(POINTS_MATCHSUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_INS3=(POINTS_INS3 << SCOREOFFSET)

public static final int POINTSoff_INS4=(POINTS_INS4 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int POINTSoff_DEL3=(POINTS_DEL3 << SCOREOFFSET)

public static final int POINTSoff_DEL4=(POINTS_DEL4 << SCOREOFFSET)

public static final int POINTSoff_DEL5=(POINTS_DEL5 << SCOREOFFSET)

public static final int POINTSoff_GAP=(POINTS_GAP << SCOREOFFSET)

public static final int POINTSoff_DEL_REF_N=(POINTS_DEL_REF_N << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
public static void main(String[] args)

public MultiStateAligner9PacBioAdapter_WithBarriers(int maxRows_, int maxColumns_)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxC, maxS, max};
*Will not fill areas that cannot match minScore
public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int[] gaps)

*return new int[] {rows, maxC, maxS, max};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

@Deprecated public final int[] fillQ(byte[] read, byte[] ref, byte[] baseScores, int refStartLoc, int refEndLoc)

*Generates the match string
public final byte[] traceback(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, boolean gapped)

*Generates the match string
public final byte[] traceback2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState, boolean gapped)

*@return {score, bestRefStart, bestRefStop}
public final int[] score2(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore, int[] gaps)

public final int[] fillAndScoreLimited(byte[] read, SiteScore ss, int thresh, int minScore)

*Fills grefbuffer
*@param ref
*@param gaps
*@param refStartLoc
*@param refEndLoc
*@return gref
public final byte[] makeGref(byte[] ref, int[] gaps, int refStartLoc, int refEndLoc)

private final int translateFromGappedCoordinate(int point, byte[] gref)

private final int translateToGappedCoordinate(int point, byte[] gref)

public final int[] fillAndScoreLimited(byte[] read, int chrom, int start, int stop, int thresh, int minScore, int[] gaps)

@Deprecated public final int[] fillAndScoreQ(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, byte[] baseScores)

@Deprecated public final int[] fillAndScoreQ(byte[] read, SiteScore ss, int thresh, byte[] baseScores)

@Deprecated public final int[] fillAndScoreQ(byte[] read, int chrom, int start, int stop, int thresh, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, SiteScore ss)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart)

public static final int scoreNoIndels(byte[] read, SiteScore ss, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, int chrom, int refStart, byte[] baseScores)

*Calculates score based on an array from Index
public static final int calcAffineScore(int[] locArray)

*Calculates score based on an array from Index
public static final int calcAffineScore(int[] locArray, byte[] baseScores)

public static final int scoreNoIndels(byte[] read, byte[] ref, int refStart, SiteScore ss)

public static final int scoreNoIndels(byte[] read, byte[] ref, byte[] baseScores, int refStart, SiteScore ss)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, byte[] baseScores, int refStart, byte[][] matchReturn)

public static final int scoreNoIndelsAndMakeMatchString(byte[] read, byte[] ref, int refStart, byte[][] matchReturn)

public static final int maxQuality(int numBases)

public static final int maxQuality(byte[] baseScores)

public static final int maxImperfectScore(int numBases)

public static final int maxImperfectScore(byte[] baseScores)

public static final String toString(int[] a)

public static final String toTimePacked(int[] a)

public static final String toScorePacked(int[] a)

public static final String toString(byte[] a)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

*DO NOT MODIFY
public final byte[] getGrefbuffer()

CharSequence showVertLimit()

CharSequence showHorizLimit()

</class MultiStateAligner9PacBioAdapter_WithBarriers>
<class Parallelogram>
public class Parallelogram

#Methods
public static void convertParallelogramToRectangle(String inputFile, String outputFile)

</class Parallelogram>
<class QuabbleAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla
*@date April 24, 2025
public class QuabbleAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final int BRIDGE_PERIOD=16

private static final boolean DENSE_TOP=false

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuabbleAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

private static final long[][] alignDense(byte[] query, byte[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuabbleAligner>
<class QuantumAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla, Zephy
*@date April 24, 2025
public class QuantumAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final int BRIDGE_PERIOD=16

private static final boolean DENSE_TOP=false

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumAligner()

private static final long[][] alignDense(byte[] query, byte[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

private static ByteBuilder toScore(long[] array)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumAligner>
<class QuantumAlignerConcise>
*PRESENTATION-ONLY VERSION - DO NOT USE
*This class contains simplified code for publication purposes.
*For functional implementation, see {@link QuantumAligner}
*@author Brian Bushnell
*@contributor Isla, Zephy
*@date April 24, 2025
public class QuantumAlignerConcise

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean EXTEND_MATCH=true

private static final boolean BUILD_BRIDGES=true


#Methods
public QuantumAlignerConcise()

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumAlignerConcise>
<class QuantumAlignerConcise2>
*PRESENTATION-ONLY VERSION - DO NOT USE
*This class contains simplified code for publication purposes.
*For a complete, fast implementation, see {@link QuantumAligner}
*This version is decomposed into 3 primary functions.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumAlignerConcise2

#Fields
private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL

private static final boolean EXTEND_MATCH=true

private static final boolean BUILD_BRIDGES=true


#Methods
public QuantumAlignerConcise2()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Perform row-specific processing in a function for clarity
*@param q Byte at position query[i-1]
*@return Position of highest score
private static int processRow(int i, int rLen, int addRight, byte q, byte[] ref, long[] prev, long[] curr, long maxScore, int maxPos, long prevRowScore, IntList activeList, IntList nextList, long scoreBand, int topBand)

*Perform cell-specific processing in a function for clarity
*@return Score of current cell
private static long processCell(int i, int j, int rLen, int addRight, byte q, byte r, long[] prev, long[] curr, long maxScore, int maxPos, long prevRowScore, IntList nextList, long scoreBand, int topBand)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumAlignerConcise2>
<class QuantumAlignerM>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Counts matches instead of dels.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumAlignerM

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int MATCH_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + MATCH_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long MATCH_MASK=((1L << MATCH_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | MATCH_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long MATCH_INCREMENT=MATCH + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final boolean DENSE_TOP=true

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumAlignerM()

private static float postprocess(long maxScore, int maxPos, int qLen, int[] posVector)

private static final long[][] alignDense(byte[] query, byte[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumAlignerM>
<class QuantumAlignerQC>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumAlignerQC

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final boolean DENSE_TOP=false

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumAlignerQC()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

private static ByteBuilder toScore(long[] array)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumAlignerQC>
<class QuantumPlusAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Encodes ACGTN as 1,2,4,8,15/31
*@author Brian Bushnell
*@contributor Isla, Zephy
*@date April 24, 2025
public class QuantumPlusAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final boolean DENSE_TOP=false

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumPlusAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

private static final long[][] alignDense(byte[] query, byte[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumPlusAligner>
<class QuantumPlusAligner2>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Encodes ACGTN as 1,2,4,8,15/31 in long[] arrays.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumPlusAligner2

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final boolean DENSE_TOP=true

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumPlusAligner2()

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(long[] query, long[] ref)

private static final long[][] alignDense(long[] query, long[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumPlusAligner2>
<class QuantumPlusAligner3>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Encodes ACGTN as 1,2,4,8,15/31 in long[] arrays.
*Uses SIMD for the dense top with a deletion tail loop.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumPlusAligner3

#Fields
private static final boolean DENSE_TOP=true

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumPlusAligner3()

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(long[] query, long[] ref)

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query0, byte[] ref0, int[] posVector)

private static final long[][] alignDense(long[] query, long[] ref, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

</class QuantumPlusAligner3>
<class QuantumPlusAligner4>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Encodes ACGTN as 1,2,4,8,15/31 in long[] arrays.
*Uses SIMD for the dense top with a deletion tail loop.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 24, 2025
public class QuantumPlusAligner4

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean BUILD_BRIDGES=true

private static final boolean DENSE_TOP=true

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public QuantumPlusAligner4()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

private static final long[][] alignDense(byte[] query0, byte[] ref0, long[] prev, long[] curr, Visualizer viz, int topWidth, int rLen)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class QuantumPlusAligner4>
<class Query>
*Represents a query sequence for alignment with k-mer indexing.
*Optimized for scenarios with small query sets and large reference databases.
*Pre-computes forward and reverse k-mer indices plus metadata for efficient alignment.
*@author Brian Bushnell
*@contributor Isla
*@date June 3, 2025
public class Query

#Fields
*Query sequence name/identifier
public final String name

*Numeric identifier for the query
public final long numericID

*Forward sequence bases
public final byte[] bases

*Reverse complement sequence bases
public final byte[] rbases

*Quality scores (may be null)
public final byte[] quals

*Forward k-mer index array
public final int[] kmers

*Reverse k-mer index array
public final int[] rkmers

*Number of valid (non-masked) k-mers
public final int validKmers

*Minimum hits required for alignment consideration
public final int minHits

*Maximum bases that can be clipped
public final int maxClips

*K-mer length for indexing
private static int k=11

*Length of middle region to mask in k-mers
private static int midMaskLen=1

*Bit mask for middle-masking k-mers
public static int midMask=makeMidMask(k,midMaskLen)

*Whether to create k-mer indices
public static boolean indexKmers=true

*Maximum homopolymer length before blacklisting
public static int blacklistRepeatLength=2

*Empty index for sequences too short to index
private static final int[][] blankIndex=new int[2][]

*Calculator for minimum hits based on query length
public static MinHitsCalculator mhc

*Maximum fraction/count of bases that can be clipped
public static float maxClip=0.25f


#Methods
*Constructs a Query with sequence data and pre-computed indices.
*@param name_ Query sequence identifier
*@param nid Numeric ID for the query
*@param bases_ Forward sequence bases
*@param quals_ Quality scores (may be null)
public Query(String name_, long nid, byte[] bases_, byte[] quals_)

*Returns the length of the query sequence
public int length()

*Creates k-mer indices for forward and reverse orientations.
*Applies middle-masking and homopolymer filtering.
*@param sequence The sequence to index
*@return Array containing [forward_kmers, reverse_kmers]
private static int[][] makeIndex(byte[] sequence)

*Creates a mask that zeros out middle bases of k-mers for fuzzy matching.
*@param k K-mer length
*@param maskLen Number of middle bases to mask
*@return Bit mask for k-mer filtering
public static int makeMidMask(int k, int maskLen)

*Sets all indexing parameters for Query creation
public static void setMode(int k_, int midMaskLen_, boolean indexKmers_)

*Sets k-mer length for indexing
private static void setK(int x)

*Sets middle masking length for fuzzy k-mer matching
private static void setMidMaskLen(int x)

</class Query>
<class RelativeAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date April 23, 2025
public class RelativeAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final boolean PRINT_OPS=false

public static boolean GLOBAL=false

public static boolean debug=true


#Methods
public RelativeAligner()

public static float alignStatic(byte[] query, byte[] ref, int[] posVector)

private static final float postprocess(byte[] prev, int qLen, int rLen, int maxScore, int maxPos, int[] pos)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class RelativeAligner>
<class ScrabbleAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*Like Wobble but trades the ring buffer for scalars
*@author Brian Bushnell
*@contributor Opus
*@date May 31, 2025
public class ScrabbleAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public ScrabbleAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class ScrabbleAligner>
<class SideChannel3>
public class SideChannel3

#Fields
public boolean errorState=false

public final MicroIndex3 index1

public final MicroIndex3 index2

public final MicroAligner3 mapper1

public final MicroAligner3 mapper2

public final int k1

public final int k2

public final float minIdentity1

public final float minIdentity2

public final String ref

public final String out

public final String outu

public final boolean samOut

public final FileFormat ffout

public final FileFormat ffoutu

private final ConcurrentReadOutputStream cros

private final ConcurrentReadOutputStream crosu

public long readsMapped=0

public long readsOut=0

public long basesOut=0

public long identitySum=0

public final boolean overwrite

public final boolean ordered

public static boolean TRACK_STATS=true


#Methods
public SideChannel3(String ref_, String out_, String outu_, int k1_, float minid1, int midMaskLen1, boolean overwrite_, boolean ordered_)

public SideChannel3(String ref_, String out_, String outu_, int k1_, int k2_, float minid1, float minid2, int midMaskLen1, int midMaskLen2, boolean overwrite_, boolean ordered_)

public boolean map(Read r1, Read r2)

public boolean map(Read r1, Read r2, MicroAligner3 mapper1, MicroAligner3 mapper2)

public String stats(long readsIn, long basesIn)

public void start()

public boolean shutdown()

*Everything in this list gets written
public int writeToMapped(ArrayList<Read> reads, long num)

*Expects a list of mixed mapped and unmapped reads
public int writeByStatus(ArrayList<Read> reads, long num)

*Expects a list of mixed mapped and unmapped reads;
*only writes mapped reads (plus mates)
private int writeMappedOnly(ArrayList<Read> reads, long num)

*Expects a list of mixed mapped and unmapped reads;
*only writes unmapped reads with unmapped mates
private int writeUnmappedOnly(ArrayList<Read> reads, long num)

public static int[] parseK(String arg, String a, String b)

static float fixID(float id)

static String fixRefPath(String refPath)

</class SideChannel3>
<class SingleStateAlignerFlat>
*Based on MSA9PBA, but reduced to a single matrix.
public final class SingleStateAlignerFlat

#Fields
private int maxRows

private int maxColumns

private int[][] packed

public static final int MODEBITS=3

public static final int STARTBITS=9

public static final int LOWBITS=MODEBITS + STARTBITS

public static final int SCOREBITS=32 - STARTBITS

public static final int MAX_START=((1 << STARTBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int STARTOFFSET=MODEBITS

public static final int SCOREOFFSET=LOWBITS

public static final int MODEMASK=~((-1) << MODEBITS)

public static final int STARTMASK=(~((-1) << STARTBITS)) << STARTOFFSET

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int HIGHMASK=SCOREMASK | STARTMASK

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final int POINTS_NOREF=-15

public static final int POINTS_MATCH=100

public static final int POINTS_SUB=-50

public static final int POINTS_INS=-121

public static final int POINTS_DEL=-111

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOREF_MODE_SUB=POINTSoff_NOREF | MODE_SUB

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

private int rows

private int columns

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlat()

@Override public final String name()

@Override public long loops()

@Override public void setLoops(long x)

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] posVector, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int from, int to)

public float align(byte[] q, byte[] r, int[] pos, int from, int to, int minScore)

private void prefillTopRow()

private void prefillLeftColumnStartingAt(int i)

private void initialize(int rows_, int columns_)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Min score is optional
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Generates the match string
@Override public final byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

private static int calcDelScoreOffset(int len)

@Override public int rows()

@Override public int columns()

</class SingleStateAlignerFlat>
<class SingleStateAlignerFlat2>
*Based on SSAFlat, but with previous state pointers removed.
public final class SingleStateAlignerFlat2

#Fields
private int maxRows

private int maxColumns

private int[][] packed

public static final int MAX_SCORE=Integer.MAX_VALUE - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final int POINTS_NOREF=-20

public static final int POINTS_MATCH=100

public static final int POINTS_SUB=-50

public static final int POINTS_INS=-121

public static final int POINTS_DEL=-111

public static final int BAD=MIN_SCORE - 1

private int rows

private int columns

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlat2()

@Override public final String name()

@Override public long loops()

@Override public void setLoops(long x)

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] posVector, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int from, int to)

public float align(byte[] q, byte[] r, int[] pos, int from, int to, int minScore)

private void prefillTopRow()

private void prefillLeftColumnStartingAt(int i)

private void initialize(int rows_, int columns_)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Min score is optional
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

int getState(int row, int col, byte q, byte r)

*Generates the match string.
*State is NOT used.
@Override public final byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

@Override public int rows()

@Override public int columns()

</class SingleStateAlignerFlat2>
<class SingleStateAlignerFlat2Amino>
*Based on SSAFlat, but with previous state pointers removed.
public final class SingleStateAlignerFlat2Amino

#Fields
private int maxRows

private int maxColumns

private int[][] packed

public static final int MAX_SCORE=Integer.MAX_VALUE - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final int POINTS_NOREF=-15

public static final int POINTS_MATCH=100

public static final int POINTS_SUB=-50

public static final int POINTS_INS=-121

public static final int POINTS_DEL=-111

public static final int BAD=MIN_SCORE - 1

private int rows

private int columns

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlat2Amino()

@Override public final String name()

@Override public long loops()

@Override public void setLoops(long x)

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] posVector, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int from, int to)

public float align(byte[] q, byte[] r, int[] pos, int from, int to, int minScore)

private void prefillTopRow()

private void prefillLeftColumnStartingAt(int i)

private void initialize(int rows_, int columns_)

int getState(int row, int col, byte q, byte r)

*Generates the match string
@Override public final byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*Generates identity;
*fills 'extra' with {match, sub, del, ins, N, clip} if present
public float tracebackIdentityAmino(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

private static int calcDelScore(int len)

@Override public int rows()

@Override public int columns()

</class SingleStateAlignerFlat2Amino>
<class SingleStateAlignerFlat2_1D>
*Based on SSAFlat2, but reduced to a 1D array.
public final class SingleStateAlignerFlat2_1D

#Fields
private int[] matrix

public static final int MAX_SCORE=Integer.MAX_VALUE - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final int POINTS_NOREF=-15

public static final int POINTS_MATCH=100

public static final int POINTS_SUB=-50

public static final int POINTS_INS=-121

public static final int POINTS_DEL=-111

private int rows

private int columns

*columns+1 *
private int rowMult

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlat2_1D()

private void prefillLeftColumnStartingAt(int i)

private final int index(int row, int col)

private final int get(int row, int col)

private final void set(int row, int col, int value)

private void initialize(int rows_, int columns_)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Min score is optional
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

int getState(int row, int col, byte q, byte r)

*Generates the match string
@Override public final byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

private static int calcDelScore(int len)

@Override public int rows()

@Override public int columns()

</class SingleStateAlignerFlat2_1D>
<class SingleStateAlignerFlat3>
*Based on SSAFlat2, but with neutral weights.
public final class SingleStateAlignerFlat3

#Fields
private int maxRows

private int maxColumns

private int[][] packed

public static final int MAX_SCORE=Integer.MAX_VALUE - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final int POINTS_NOREF=-2

public static final int POINTS_MATCH=10

public static final int POINTS_SUB=-10

public static final int POINTS_INS=-10

public static final int POINTS_DEL=-10

public static final int BAD=MIN_SCORE - 1

private int rows

private int columns

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlat3()

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
@Override public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Min score is optional
@Override public final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

private static int calcDelScore(int len)

@Override public int rows()

@Override public int columns()

</class SingleStateAlignerFlat3>
<class SingleStateAlignerFlatFloat>
*Based on SSAFlat, but with previous state pointers removed.
public final class SingleStateAlignerFlatFloat

#Fields
private int maxRows

private int maxColumns

private float[][] packed

private float[] refWeights

public static final int MAX_SCORE=Integer.MAX_VALUE - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

private static final byte MODE_N=5

public static final float POINTS_NOREF=-20

public static final float POINTS_MATCH=100

public static final float POINTS_SUB=-50

public static final float POINTS_INS=-121

public static final float POINTS_DEL=-111

public static final int BAD=MIN_SCORE - 1

private int rows

private int columns

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerFlatFloat()

int getState(int row, int col, byte q, byte r, float refWeight, float insWeight, float delWeight)

int getState(int row, int col, byte q, byte r, float refWeight)

*Generates the match string.
*State is NOT used.
@Override public final byte[] traceback(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state)

@Override public float tracebackIdentity(byte[] query, byte[] ref, int refStartLoc, int refEndLoc, int row, int col, int state, int[] extra)

*@return {score, bestRefStart, bestRefStop}
@Override public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
@Override public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

@Override public int minScoreByIdentity(int len, float identity)

private static float calcDelScore(int len)

@Override public int rows()

@Override public int columns()

public void setWeights(float[] refWeights_, float[] insWeights_, float[] delWeights_)

public void setWeights(float[] refWeights_)

</class SingleStateAlignerFlatFloat>
<class SingleStateAlignerPacBioAdapter>
*Based on MSA9PBA, but reduced to a single matrix.
public final class SingleStateAlignerPacBioAdapter

#Fields
private final int maxRows

public final int maxColumns

private final int[][] packed

private final int[] vertLimit

private final int[] horizLimit

private final int[] insScoreArray

private final int[] delScoreArray

private final int[] matchScoreArray

private final int[] subScoreArray

public static final int MODEBITS=3

public static final int STARTBITS=9

public static final int LOWBITS=MODEBITS + STARTBITS

public static final int SCOREBITS=32 - STARTBITS

public static final int MAX_START=((1 << STARTBITS) - 1)

public static final int MAX_SCORE=((1 << (SCOREBITS - 1)) - 1) - 2000

public static final int MIN_SCORE=0 - MAX_SCORE

public static final int STARTOFFSET=MODEBITS

public static final int SCOREOFFSET=LOWBITS

public static final int MODEMASK=~((-1) << MODEBITS)

public static final int STARTMASK=(~((-1) << STARTBITS)) << STARTOFFSET

public static final int SCOREMASK=(~((-1) << SCOREBITS)) << SCOREOFFSET

public static final int HIGHMASK=SCOREMASK | STARTMASK

private static final byte MODE_DEL=1

private static final byte MODE_INS=2

private static final byte MODE_SUB=3

private static final byte MODE_MATCH=4

public static final int POINTS_NOREF=-10

public static final int POINTS_MATCH=90

public static final int POINTS_MATCH2=100

public static final int POINTS_SUB=-143

public static final int POINTS_SUB2=-54

public static final int POINTS_INS=-207

public static final int POINTS_INS2=-51

public static final int POINTS_INS3=-37

public static final int POINTS_DEL=-273

public static final int POINTS_DEL2=-38

public static final int BAD=MIN_SCORE - 1

public static final int POINTSoff_NOREF=(POINTS_NOREF << SCOREOFFSET)

public static final int POINTSoff_NOREF_MODE_SUB=POINTSoff_NOREF | MODE_SUB

public static final int POINTSoff_MATCH=(POINTS_MATCH << SCOREOFFSET)

public static final int POINTSoff_MATCH2=(POINTS_MATCH2 << SCOREOFFSET)

public static final int POINTSoff_SUB=(POINTS_SUB << SCOREOFFSET)

public static final int POINTSoff_SUB2=(POINTS_SUB2 << SCOREOFFSET)

public static final int POINTSoff_INS=(POINTS_INS << SCOREOFFSET)

public static final int POINTSoff_INS2=(POINTS_INS2 << SCOREOFFSET)

public static final int POINTSoff_DEL=(POINTS_DEL << SCOREOFFSET)

public static final int POINTSoff_DEL2=(POINTS_DEL2 << SCOREOFFSET)

public static final int BADoff=(BAD << SCOREOFFSET)

public static final int MAXoff_SCORE=MAX_SCORE << SCOREOFFSET

public static final int MINoff_SCORE=MIN_SCORE << SCOREOFFSET

private int rows

private int columns

public long iterationsLimited=0

public long iterationsUnlimited=0

public boolean verbose=false

public boolean verbose2=false


#Methods
public SingleStateAlignerPacBioAdapter(int maxRows_, int maxColumns_, int qlen)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
public final int[] fillLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Will not fill areas that cannot match minScore
private final int[] fillLimitedX(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*return new int[] {rows, maxCol, maxState, maxScore, maxStart};
*Does not require a min score (ie, same as old method)
private final int[] fillUnlimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

*Generates the match string
public final byte[] traceback(int refStartLoc, int refEndLoc, int row, int col, int state)

*@return {score, bestRefStart, bestRefStop}
public final int[] score(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int maxRow, int maxCol, int maxState)

*Will not fill areas that cannot match minScore.
*@return {score, bestRefStart, bestRefStop}
public final int[] fillAndScoreLimited(byte[] read, byte[] ref, int refStartLoc, int refEndLoc, int minScore)

public static final String toString(byte[] ref, int startLoc, int stopLoc)

public static int calcDelScore(int len)

private static int calcDelScoreOffset(int len)

public static int calcInsScore(int len)

private static int calcInsScoreOffset(int len)

</class SingleStateAlignerPacBioAdapter>
<class Test>
public class Test

#Methods
public static boolean validate(IDAligner ida)

public static final void print(long[] curr, String name)

public static byte[] toSequence(String a)

public static String header()

public static void printResults(IDAligner ida, byte[] a, byte[] b, float id, int[] pos, long iters, int threads, Timer t)

public static void testAndPrint(Class<C> c, String[] args)

private static boolean setOrCatch(Class<?> c, String name, Object value)

public static void testAndPrint(IDAligner ida, String a, String b, int iters)

public static float test(IDAligner ida, String a, String b)

public static float test(IDAligner ida, String a, String b, int iters)

public static float test(IDAligner ida, byte[] a, byte[] b, long maxIters, int threads)

public static float testST(IDAligner ida, byte[] a, byte[] b, long maxIters, long sleepTime)

@SuppressWarnings public static T createNewInstance(T existingObject)

@SuppressWarnings public static T createNewInstance(Class<T> c)

public static float testMT(IDAligner ida, byte[] a, byte[] b, long maxIters, int threads)

*This uses ThreadPools as an experiment, but they are very slow.
public static boolean processThreads(List<? extends Runnable> list, int threads)

public static boolean processThreadsInPool(List<? extends Runnable> list, ExecutorService pool)

</class Test>
<class TestAlignerSuite>
*Tests multiple aligners using random sequences.
*The sequences have variable pairwise ANI, and each
*ANI level is tested multiple times for average accuracy
*and loop count.
*@author Brian Bushnell
*@contributor Opus
*@date May 31, 2025
public class TestAlignerSuite

#Methods
private static void runTestsForANI(ArrayList<IDAligner> aligners, float targetANI, int iterations, int length, int threads, int sinewaves)

*Mutate a sequence to achieve target identity
public static byte[] mutateSequence(byte[] bases, float targetIdentity, Random randy, int sinewaves)

</class TestAlignerSuite>
<class VisualizationConverter>
*Converts text-based alignment visualizations to color bitmap images.
*Uses a color gradient to represent alignment scores with:
*- Green (a-z): Low scores
*- Yellow (0-9): Medium scores
*- Red (A-Z): High scores
*- Black: Unexplored regions
*- Gray: Explored but pruned regions
*- White: Optimal alignment path
*@author Brian Bushnell
*@author Isla (Highly-customized Claude instance)
*@date April 2025
public class VisualizationConverter

#Fields
private static final int DEFAULT_SCALE=2

public static int colorScheme=1


#Methods
public static void main(String[] args)

private static void convertToBitmap(String textFile, String imageFile)

private static Color getColorForChar(char level0, int scheme)

private static Color getColorForChar1(char level0)

private static Color getColorForChar2(char level0)

private static Color interpolateColor(Color c1, Color c2, float position)

</class VisualizationConverter>
<class Visualizer>
public class Visualizer

#Fields
private ByteStreamWriter bsw

private final int positionBits

private final int countBits

private final int scoreShift

*Value representing invalid or pruned cells
private static final long BAD=(Long.MIN_VALUE / 2)

public static boolean useAbsolute=true

public static boolean useRelative=true

public static boolean useScaled=false

*Character set for score visualization (a-z, 0-9, A-Z) from lowest to highest
static final byte[] symbols=new byte[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}

static final int[] symbolMap=makeSymbolMap(symbols)


#Methods
*Creates a new visualization output for alignment matrices.
*@param fname Output filename for the visualization
*@param pBits Number of bits used for position information in the score encoding
*@param cBits Number of bits used for deletion information in the score encoding
public Visualizer(String fname, int pBits, int cBits)

*Properly terminates the output file.
*Should be called when visualization is complete.
public void shutdown()

*Generates a simple visualization line marking explored cells.
*Original visualization style that represents exploration pattern
*without score information.
*@param active List of positions that were actively explored
*@param length Length of the current row
*@param maxPos Position with the highest score in this row (-1 if none)
public void print(IntList active, int length, int maxPos)

*Wrapper for int[].
public void print(int[] scores, int bandStart, int bandEnd, int rLen)

*Wrapper for byte[]
public void print(byte[] scores, int bandStart, int bandEnd, int rLen)

*Visualizer for banded aligners.
*@param scores Array of scores for the current row
*@param bandStart Min scored position for this row
*@param bandEnd Max scored position for this row
*@param rLen Reference length
public void print(long[] scores, int bandStart, int bandEnd, int rLen)

public void printMSA(int[] scores, int qLen, int rLen, int pointsMatch)

*Generates a detailed visualization line showing score distributions.
*Enhanced visualization that represents scores with different characters,
*providing richer information about the scoring landscape.
*@param scores Array of scores for the current row
*@param active List of positions that were actively explored (optional, may be null)
public void print(long[] scores, IntList active, int rLen)

*Generates a detailed visualization line showing score distributions.
*Enhanced visualization that represents scores with different characters,
*providing richer information about the scoring landscape.
*@param editDist Edit distances for the row, or very high if unexplored
*@param rLen Reference length.
public void printEditDist(int[] editDist, int rLen)

*Converts a numeric score to a display character.
*Uses absolute or relative scoring based on the maximum score value.
*@param score The score to convert
*@param maxScore The maximum score in the current row
*@return A character representing the score's magnitude
private static byte scoreToSymbol(int score, int maxScore)

private static int[] makeSymbolMap(byte[] symbols)

</class Visualizer>
<class WaveFrontAligner>
*Implements a WaveFront alignment algorithm for global alignment.
*This version is actually fast.
*@author Brian Bushnell
*@contributor Isla
*@date April 30, 2025
public class WaveFrontAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public WaveFrontAligner()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

public long loops()

public void setLoops(long x)

public static float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Wrapper for aligning within a reference window.
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

</class WaveFrontAligner>
<class WaveFrontAligner2>
*Implements a WaveFront alignment algorithm for global alignment.
*This version is actually fast.
*@author Brian Bushnell
*@contributor Isla
*@date May 27, 2025
public class WaveFrontAligner2

#Methods
public WaveFrontAligner2()

*Wrapper for aligning within a reference window.
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

</class WaveFrontAligner2>
<class WaveFrontAlignerViz>
*Implements a WaveFront alignment algorithm for global alignment.
public class WaveFrontAlignerViz

#Fields
private static final byte OP_NONE=0

private static final byte OP_MATCH=1

private static final byte OP_SUB=2

private static final byte OP_INS=3

private static final byte OP_DEL=4

private static final boolean DEBUG_MODE=false

private static final boolean PRINT_STEPS=false

private static String lastAlignment=""

static long loops=0

public static String output=null


#Methods
*Main() passes the args and class to Test to avoid redundant code
public static void main(String[] args)

public WaveFrontAlignerViz()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

@Override public long loops()

public void setLoops(long x)

*Wrapper for aligning within a reference window.
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

</class WaveFrontAlignerViz>
<class WobbleAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla
*@date May 7, 2025
public class WobbleAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobbleAligner()

*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

public long loops()

public void setLoops(long x)

</class WobbleAligner>
<class WobbleAlignerConcise>
*PRESENTATION-ONLY VERSION - DO NOT USE
*This class contains simplified code for publication purposes.
*For functional implementation, see {@link WobbleAligner}
*For optimal implementation, see {@link WobblePlusAligner3}
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobbleAlignerConcise

#Fields
static long[] prev=null

static long[] curr=null

static int qLen=0

static int rLen=0

static long maxValue=0

static int bandStart=0

static int bandEnd=0

private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=(1L << POSITION_BITS) + DEL


#Methods
public WobbleAlignerConcise()

@Override public final String name()

@Override public final float align(byte[] a, byte[] b)

@Override public final float align(byte[] a, byte[] b, int[] pos)

@Override public final float align(byte[] a, byte[] b, int[] pos, int minScore)

@Override public final float align(byte[] a, byte[] b, int[] pos, int rStart, int rStop)

*Tests for high-identity indel-free alignments needing low bandwidth
private static int decideBandwidth(byte[] query, byte[] ref)

*This concise function should work, but use WobbleAligner instead.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
public static final float alignStaticTrue(byte[] query, byte[] ref, int[] posVector)

*WARNING! This function is nonfunctional demo code.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*@return Identity (0.0-1.0).
@SuppressWarnings public static final float alignStatic(byte[] query, byte[] ref, int[] posVector)

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class WobbleAlignerConcise>
<class WobblePlusAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobblePlusAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobblePlusAligner()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class WobblePlusAligner>
<class WobblePlusAligner2>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobblePlusAligner2

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobblePlusAligner2()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class WobblePlusAligner2>
<class WobblePlusAligner3>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobblePlusAligner3

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobblePlusAligner3()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

public long loops()

public void setLoops(long x)

</class WobblePlusAligner3>
<class WobblePlusAligner4>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobblePlusAligner4

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobblePlusAligner4()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class WobblePlusAligner4>
<class WobblePlusAligner5>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*Center of band drifts toward highest score.
*Band starts wide and narrows to allow glocal alignments.
*Band dynamically widens and narrows in response to sequence identity.
*@author Brian Bushnell
*@contributor Isla (Highly-customized Claude instance)
*@date May 7, 2025
public class WobblePlusAligner5

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public WobblePlusAligner5()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class WobblePlusAligner5>
<class XDropHAligner>
*Aligns two sequences to return ANI.
*Uses only 2 arrays and avoids traceback.
*Gives an exact answer.
*Calculates rstart and rstop without traceback.
*Limited to length 2Mbp with 21 position bits.
*@author Brian Bushnell
*@contributor Isla
*@date May 30, 2025
public class XDropHAligner

#Fields
private static AtomicLong loops=new AtomicLong(0)

public static String output=null

private static final int POSITION_BITS=21

private static final int DEL_BITS=21

private static final int SCORE_SHIFT=POSITION_BITS + DEL_BITS

private static final long POSITION_MASK=(1L << POSITION_BITS) - 1

private static final long DEL_MASK=((1L << DEL_BITS) - 1) << POSITION_BITS

private static final long SCORE_MASK=~(POSITION_MASK | DEL_MASK)

private static final long MATCH=1L << SCORE_SHIFT

private static final long SUB=(-1L) << SCORE_SHIFT

private static final long INS=(-1L) << SCORE_SHIFT

private static final long DEL=(-1L) << SCORE_SHIFT

private static final long N_SCORE=0L

private static final long BAD=Long.MIN_VALUE / 2

private static final long DEL_INCREMENT=DEL + (1L << POSITION_BITS)

private static final boolean EXTEND_MATCH=true

private static final boolean LOOP_VERSION=false

private static final boolean PRINT_OPS=false

public static final boolean GLOBAL=false


#Methods
public XDropHAligner()

*Use alignment information to calculate identity and starting coordinate.
*@param maxScore Highest score in last row
*@param maxPos Highest-scoring position in last row
*@param qLen Query length
*@param rLen Reference length
*@param posVector Optional array for returning reference start/stop coordinates.
*@return Identity
private static float postprocess(long maxScore, int maxPos, int qLen, int rLen, int[] posVector)

private static ByteBuilder toScore(long[] array)

*Lightweight wrapper for aligning to a window of the reference.
*@param query Query sequence
*@param ref Reference sequence
*@param posVector Optional int[2] for returning {rStart, rStop} of the optimal alignment.
*If the posVector is null, sequences may be swapped so that the query is shorter.
*@param rStart Alignment window start.
*@param to Alignment window stop.
*@return Identity (0.0-1.0).
public static final float alignStatic(byte[] query, byte[] ref, int[] posVector, int refStart, int refEnd)

public long loops()

public void setLoops(long x)

</class XDropHAligner>
