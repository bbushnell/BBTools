#version 1
#package barcode
#generated 2025-09-06T20:35:07

<class AnalyzeBarcodes>
*Analyzes paired barcode counts.
*This is the output file from CountBarcodes2.
*Example: TODO
*@author Brian Bushnell
*@date July 19, 2023
public class AnalyzeBarcodes

#Fields
*Primary input file path
private String in1=null

private String expectedBarcodeFile=null

private int expectedBarcodeCount=-1

*Primary output file path
private String outLeft="leftStats.txt"

private String outRight="rightStats.txt"

private String outPair="pairStats.txt"

private BarcodeStats bs

private long linesProcessed=0

private long bytesProcessed=0

private long linesOut=0

private long bytesOut=0

private long maxLines=Long.MAX_VALUE

*Input File
private final FileFormat ffin1

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public AnalyzeBarcodes(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create streams and process all data
void process(Timer t)

void printMismatchVsTotal(BarcodeStats bs, ByteStreamWriter bsw)

void printActualVsExpected(BarcodeStats bs, ByteStreamWriter bsw)

private ByteStreamWriter makeBSW(String fname)

private static ByteStreamWriter makeBSW(FileFormat ff)

</class AnalyzeBarcodes>
<class Barcode>
public class Barcode

#Fields
public final String name

private long count=0

public final int expected

public float frequency=1f

public int tile=0


#Methods
public Barcode(String s)

public Barcode(String s, long c)

public Barcode(String s, long c, int e)

public Barcode(String s, long c, int e, int t)

*Gets one of two barcodes for dual indexes
public Barcode getBarcodeForPairnum(int pairnum, char delimiter)

public String getStringForPairnum(int pairnum, char delimiter)

public Barcode left(char delimiter)

public Barcode right(char delimiter)

public String leftString(char delimiter)

public String rightString(char delimiter)

public int countUndefined()

public boolean isHomopolymer()

public boolean isHomopolymer(char h)

public static boolean isHomopolymer(String name)

public static boolean isHomopolymer(String name, char h)

*Returns -1 if false, and the homopolymer character 2-bit encoding if true
public byte checkHomopolymer()

public static final boolean nonLetter(int a, int b)

public int hdist(Barcode b)

public int hdist(String b)

public int hdist(byte[] b)

public int hdistL(Barcode b)

public int hdistL(String b)

public int hdistR(Barcode b)

public int hdistR(String b)

public static int hdist(byte[] a, byte[] b)

public static int hdist(String a, String b)

public static int hdist(String a, byte[] b)

public static int hdistL(String a, String b, int len1)

public static int hdistR(String a, String b, int len2)

public static int hdistL(String a, String b)

public static int hdistR(String a, String b)

public int edist(Barcode b, BandedAligner bandy)

public int edist(String b, BandedAligner bandy)

public static HashMap<String,Barcode> barcodesToMap(Collection<Barcode> codes)

public static ArrayList<Barcode> summateAssignments(HashMap<String,String> assignmentMap, ArrayList<Barcode> expectedCodeList, HashMap<String,Barcode> countMap)

public static ArrayList<Barcode> summateAssignments(HashMap<String,String> assignmentMap, Collection<String> expectedCodeList, Collection<Barcode> counts)

public static ArrayList<Barcode> summateAssignments(HashMap<String,String> assignmentMap, Collection<String> expectedCodeList, HashMap<String,Barcode> countMap)

public static String parseBarcodeFromFname(String fname)

public static final boolean isBarcodeSymbol(char x)

public static final boolean isBarcodeSymbol(byte x)

public static boolean isBarcode(String s)

public static final boolean containsOnlyBarcodeSymbols(String s)

public long count()

public void setCount(long x)

public int length()

public char charAt(int i)

public byte[] getBytes()

public int length1()

public int length2()

public void increment()

public void increment(Barcode b)

public void increment(long x)

public void incrementSync(long x)

@Override public int hashCode()

@Override public int compareTo(Barcode b)

@Override public boolean equals(Object b)

public boolean equals(Barcode b)

@Override public String toString()

public ByteBuilder appendTo(ByteBuilder bb)

public ByteBuilder appendIndex(ByteBuilder bb, byte delimiter, int indexNum)

public static ByteBuilder appendIndex(ByteBuilder bb, byte delimiter, int indexNum, String name)

public static byte delimiter(String barcode)

public static byte delimiter(byte[] barcode)

public static int countPolymers(String code)

</class Barcode>
<class BarcodeCounter>
*Static class for routine barcode-counting functions,
*like file manipulation and actually counting them.
*@author Brian Bushnell
*@date April 9, 2024
public class BarcodeCounter

#Fields
public static boolean errorState=false


#Methods
public static final HashMap<String,Barcode> countBarcodes(String readsFile, long maxReads, boolean addTile)

public static final HashMap<String,Barcode> countBarcodes(FileFormat ff, long maxReads, boolean addTile)

private static final ConcurrentReadInputStream makeCris(FileFormat ff1, long maxReads)

private static final void processList(ListNum<Read> ln, ConcurrentReadInputStream cris, HashMap<String,Barcode> codeMap, IlluminaHeaderParser2 ihp, boolean addTile)

private static final void processRead(Read r1, HashMap<String,Barcode> codeMap, IlluminaHeaderParser2 ihp, boolean addTile)

public static final ArrayList<String> loadBarcodes(String fname, int forceDelimiter)

public static final ArrayList<Barcode> loadCounts(String fname, long minCount)

public static final boolean writeCounts(Collection<Barcode> counts, long minCount, FileFormat ff, boolean sort, boolean overwrite, boolean append)

public static final boolean writeCounts(Collection<Barcode> counts, long minCount, String fname, boolean sort, boolean overwrite, boolean append)

public static final boolean writeCounts(HashMap<String,Barcode> counts, String fname, boolean overwrite, boolean append)

public static HashMap<String,String> loadAssignmentMap(String mapIn)

public static boolean writeAssignmentMap(HashMap<String,String> assignmentMap, String mapOut, boolean overwrite, boolean append)

public static SuperLongList makeCountList(Collection<Barcode> barcodes)

*The goal of this function is to return a count such that
*only percentile of observed barcodes have counts below that.
*@param barcodes
*@param percentile
*@return
public static long barcodeCountPercentile(Collection<Barcode> barcodes, float percentile)

</class BarcodeCounter>
<class BarcodeMappingStats>
public class BarcodeMappingStats

#Fields
*Raw counts of barcodes
public HashMap<String,Barcode> codeMap=new HashMap<String,Barcode>()

*A table of tables. Key1 is the barcode of a read; key2 is where the read mapped to.
*The barcode for key2 tracks the number of times reads with key1 barcode mapped to key2's reference.
*E.G. if key1 is ABC-DEF then the top barcode in its table would be expected to
*be ABC-DEF, and other entries would indicate contamination of that library.
public HashMap<String,HashMap<String,Barcode>> sourceMap=new HashMap<String,HashMap<String,Barcode>>()

public boolean errorState=false


#Methods
public BarcodeMappingStats()

public void merge(BarcodeMappingStats bs)

public void increment(Read r, String refKey)

public void incrementCodeMap(String key, long amt)

public void incrementSourceMap(String readKey, String refKey, long amt)

public void writeStats(String outbarcodes, boolean overwrite)

private static long sum(ArrayList<Barcode> list)

private static ArrayList<Barcode> toSortedList(HashMap<String,Barcode> map)

</class BarcodeMappingStats>
<class BarcodeStats>
public class BarcodeStats

#Fields
public final HashMap<String,Barcode> codeMap=new HashMap<String,Barcode>()

public HashMap<String,Barcode> badPairMap=new HashMap<String,Barcode>()

public HashMap<String,Barcode> goodPairMap=new HashMap<String,Barcode>()

public final ArrayList<Barcode> expectedCodeList=new ArrayList<Barcode>()

public final HashMap<String,Barcode> expectedCodeMap=new HashMap<String,Barcode>()

public final char delimiter

public final int barcodesPerRead

public int length1

public int length2

public long linesProcessed=0

public long bytesProcessed=0

public long nCodes=0

public long expectedCodes=0

public long totalCodes=0

public float badPairFraction=-1

public float goodPairFraction=-1

*0 is nonmatches, 1 is single matches, 2 is both barcodes match but pair doesn't
public long[] validArray=new long[3]

public long[] polymerArray=new long[4]

public long[] hdistArray=new long[30]

public long[] edistArray=new long[30]

public long nCodesU=0

public long expectedCodesU=0

public long totalCodesU=0

public long[] validArrayU=new long[3]

public long[] polymerArrayU=new long[4]

public long[] hdistArrayU=new long[30]

public long[] edistArrayU=new long[30]

public LongList transitions=new LongList()

public BarcodeStats leftStats=null

public BarcodeStats rightStats=null

private final BandedAlignerConcrete bandy=new BandedAlignerConcrete(31)

private String label

public static boolean calcEdist=false

public static boolean errorState=false


#Methods
public static void main(String[] args)

public BarcodeStats(int delimiter_, int barcodesPerRead_, String label_)

*Loads a set of barcodes from a set of barcodes or filenames.
*They can have a tab after them with more stuff, which will be trimmed.
*Modifies the input set.
public static LinkedHashSet<String> loadBarcodeSet(LinkedHashSet<String> barcodeSet, byte barcodeDelimiter, boolean rcIndex1, boolean rcIndex2)

public int loadBarcodeList(String fname, int forceDelimiter, boolean rcIndex1, boolean rcIndex2)

public static String fixBarcode(String s, int delimiter, boolean rcIndex1, boolean rcIndex2)

public static String rcompBarcode(String s, int delimiter, boolean rcIndex1, boolean rcIndex2)

public static String fixDelimiter(String s, int forceDelimiter)

public long loadBarcodeCounts(String fname)

public BarcodeStats split(int pairnum)

public static int findDelimiter(String fname)

public static BarcodeStats loadStatic(String fname, String expectedBarcodeFile, int expectedBarcodeCount)

public static BarcodeStats loadStatic(String fname)

public BarcodeStats makeLeft()

public BarcodeStats makeRight()

public void addExpectedCodes(BarcodeStats bs)

public int addExpectedCode(String s)

public int addExpectedCode(Barcode b)

public void increment(String key, long amt)

public void increment(String key, long amt, int tile)

public void incrementBad(String key, long amt)

public void incrementGood(String key, long amt)

public void incrementMismatches(String s, long count, LongList transitions)

public void incrementMismatch(int pos, int ref, int query, long incr, LongList transitions)

public ByteBuilder printTransitions()

public static ByteBuilder printTransitions(LongList transitions, ByteBuilder bb)

public void calcStats()

public Barcode findClosest(String s, int maxHDist)

public Barcode findClosest(String s, int maxHDist, int clearzone)

public int calcHdist(String s)

public int calcHdist(Barcode b)

public int calcEdist(Barcode b)

public BarcodeStats copySpecial()

public void merge(BarcodeStats bs)

public boolean isBadPair(String s)

public boolean hasErrors(String s)

private static String[] split(String s, int delimiter)

public int size()

public ArrayList<Barcode> toList()

public long hdistSum(int min, int max)

public long edistSum(int min, int max)

String pad(long x)

public String toStats(String hdr)

public void printToFile(String fname, boolean overwrite)

public void printToFile(FileFormat ff)

public void printToFile(FileFormat ff, long minCount)

</class BarcodeStats>
<class CompareLabels>
*@author Brian Bushnell
*@date May 8, 2014
public class CompareLabels

#Fields
private String in1=null

private String out1="stdout.txt"

private final FileFormat ffin1

private final FileFormat ffout1

private char delimiter='\t'

private final LineParserS1 lp

private boolean swap=false

private String labelStats=null

private String quantSetFile=null

private final LinkedHashMap<String,Label> map

private final HashSet<String> quantSet

private long maxReads=-1

private long readsProcessed=0

private long basesProcessed=0

private long labelsProcessed=0

private LongList termCounts=new LongList()

private long uuCount=0

private long uaCount=0

private long auCount=0

private long aaCount=0

private long abCount=0

private long invalidCount=0

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public CompareLabels(String[] args)

void process(Timer t)

private void processInner(ConcurrentReadInputStream cris)

private void summarize(ByteStreamWriter bsw)

private void printMap(ByteStreamWriter bsw)

private void processRead(Read r)

private Label getLabel(String s)

</class CompareLabels>
<class CorrelateBarcodes>
*@author Brian Bushnell
*@date June 20, 2014
public class CorrelateBarcodes

#Fields
private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String extin=null

private String extout=null

private String outcor=null

private String bqhist=null

private String aqhist=null

private String mqhist=null

private float minBarcodeAverageQuality=0

private int minBarcodeMinQuality=0

private long[][] qualCor1=new long[50][50]

private long[][] qualCor2=new long[50][50]

private long[] aqhistArray=new long[100]

private long[] mqhistArray=new long[100]

private long maxReads=-1

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffcor

private final FileFormat ffaq

private final FileFormat ffmq

private final FileFormat ffout1

private final FileFormat ffout2

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public CorrelateBarcodes(String[] args)

void process(Timer t)

</class CorrelateBarcodes>
<class CountBarcodes>
*@author Brian Bushnell
*@date June 20, 2014
public class CountBarcodes

#Fields
private String in1=null

private String in2=null

private String qfin1=null

private String qfin2=null

private String out1=null

private String out2=null

private String outCounts=null

private String qfout1=null

private String qfout2=null

private String extin=null

private String extout=null

private boolean reverseComplementMate=false

private boolean reverseComplement=false

private boolean countUndefined=true

private boolean printHeader=true

private int maxRows=-1

private long maxReads=-1

private final FileFormat ffin1

private final FileFormat ffin2

private final FileFormat ffout1

private final FileFormat ffout2

private final FileFormat ffCounts

private final HashMap<String,String> expectedCodeMap

private final HashMap<String,String> validCodeMap

private final ArrayList<String> expectedCodes

private final ArrayList<String> validCodes

private final BandedAlignerConcrete bandy=new BandedAlignerConcrete(21)

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public CountBarcodes(String[] args)

void process(Timer t)

*@param s
*@param expectedCodes
*@return
public static int calcHdist(String s, ArrayList<String> expectedCodes)

static int hdist(String s, String code)

*@param s
*@param expectedCodes
*@return
int calcEdist(String s, ArrayList<String> expectedCodes)

int edist(String s, String code)

</class CountBarcodes>
<class CountBarcodes2>
*Counts barcodes in a fastq file and produces a summary.
*Sample command:
*countbarcodes2.sh pcrmatrix type=hdist in=sub005.fq.gz ow expected=expected.txt -Xmx31g t=32
*countbarcodes2.sh pcrmatrix type=hdist in=sub005.fq.gz ow expected=expected.txt -Xmx31g t=32
*outcontam=contam2.txt quantset=quantset.txt
*@author Brian Bushnell
*@date June 20, 2014
public class CountBarcodes2

#Fields
*Primary input file path
private ArrayList<String> in1=new ArrayList<String>()

*Secondary input file path
private ArrayList<String> in2=new ArrayList<String>()

*Expected Barcodes
private String expectedBarcodesFile=null

*Pre-counted barcodes
private String countsIn=null

private long minCount0=0

private long minCountR=4

private long minCountA=4

private float minCountPercentile=0.0f

*Primary output file path
private String out1=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

private String transitionsOut=null

private String matrixOut=null

private String probsOut=null

private String accuracyOut=null

private String mapOut=null

private String barcodesOut=null

private String contamOut=null

private String quantSetFile=null

private boolean quantifySource=false

private boolean excludeUnknownInAccuracy=true

private boolean useServer=false

private boolean setUseServer=false

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

private HashMap<String,LongPair> contamMap

private BarcodeStats bs

private boolean calcStats=true

private boolean printStats=true

byte delimiter=-1

int barcodesPerRead=-1

private boolean useMatrix=false

private IlluminaHeaderParser2 ihp=new IlluminaHeaderParser2()

long totalBarcodes=0

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final ArrayList<FileFormat> ffin1=new ArrayList<FileFormat>()

*Secondary input file
private final ArrayList<FileFormat> ffin2=new ArrayList<FileFormat>()

*Primary output file
private final FileFormat ffout1

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

public static boolean verboseClient=true

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CountBarcodes2(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris(FileFormat ff1, FileFormat ff2, boolean printPaired)

*Iterate through the reads
void processCounts(String countsFile)

*Iterate through the reads
void processInner(FileFormat ff1, FileFormat ff2)

*Iterate through the reads
long[] processContam(FileFormat ff, HashMap<String,String> assignmentMap, HashMap<String,LongPair> counts, HashSet<String> quantSet, boolean addTile)

void readFile(ConcurrentReadInputStream cris)

*Process a list of Reads.
*@param ln The list.
*@param cris Read Input Stream
*@param ros Read Output Stream for reads that will be retained
void processList(ListNum<Read> ln, ConcurrentReadInputStream cris)

*Process a single read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
void processReadPair(Read r1, Read r2)

</class CountBarcodes2>
<class DemuxClient>
*Sends data to the demux server.
*@author BBushnell
*@date June 24, 2024
public class DemuxClient

#Fields
public boolean errorState=false

public String address=Shared.demuxServer()

public static String writeSent=null


#Methods
public static void main(String[] args)

public DemuxClient()

public DemuxClient(String address_)

HashMap<String,String> getMap(DemuxData dd, boolean verbose)

private String sendAndReceive(DemuxData dd, boolean verbose)

private static HashMap<String,String> toMapRaw(String response, boolean verbose)

private static HashMap<String,String> toMapA48(byte[] response, boolean verbose, DemuxData dd)

private static HashMap<String,String> toMapA48(byte[] response, boolean verbose, int coding, int len1, int len2, byte delimiter)

public static byte[] decodeA48(byte[] term, int from, int to, ByteBuilder bb, int len)

private static boolean checkForError(String s)

</class DemuxClient>
<class DemuxData>
public class DemuxData

#Fields
public Collection<Barcode> codeCounts

public LinkedHashSet<String> expectedList

private long prevCode1=0

private long prevCode2=0

public int length1=-1

public int length2=-1

public int barcodeDelimiter='+'

public int maxHDist0=6

public float minRatio0=20f

public float minProb0=-12

public int maxHDist1=6

public float minRatio1=1_000_000f

public float minProb1=-5.6f

public boolean addPolyA=PCRMatrix.addPolyA

public boolean addPolyC=PCRMatrix.addPolyC

public boolean addPolyG=PCRMatrix.addPolyG

public boolean addPolyT=PCRMatrix.addPolyT

public int SEND_BUFFER_MAX_BYTES=8000000

public boolean deltaCounts=deltaCountsDefault

public boolean deltaBarcodes=deltaBarcodesDefault

public static boolean deltaCountsDefault=true

public static boolean deltaBarcodesDefault=false

private LineParser1 equalsParser=new LineParser1('=')

private LineParser1 tabParser=new LineParser1('\t')

public int type=PCRMatrix.PROB_TYPE

public boolean hdistSum=false

public int coding=DEFAULT_CODING

public static int DEFAULT_CODING=Sketch.A48

public static boolean ENSURE_SORTED=true

public static boolean SKIP_DUPLICATE=true

private static final int FLAGS=1

private static final int EXPECTED=2

private static final int COUNTS=3

private static final int END=4

public static final byte[] numberToBaseACGNT=new byte[]{'A','C','G','N','T'}

public static final byte[] baseToNumberACGNT=makeBaseToNumberACGNT()


#Methods
public static void main(String[] args)

public DemuxData(int length1_, int length2_, int delimiter_)

public DemuxData(ArrayList<byte[]> chunks)

public ArrayList<byte[]> encode()

private ByteBuilder appendBarcode(Barcode bc, ByteBuilder bb, long prevCount, String prevName, byte[] buffer)

public static final long encodeACGTN(String s, int a, int b)

public static final void decodeACGTN(long code0, ByteBuilder bb, int len)

public static final void appendA48(long value, ByteBuilder bb, byte[] temp)

public static long parseA48(byte[] line, int from)

private static String toStringChunk(byte[] chunk, int x)

public void decode(Collection<byte[]> chunks)

private Barcode parseCountLine(byte[] line, long prevCount, String prevName, ByteBuilder bb)

public int parseMode(byte[] line)

public boolean parseFlag(byte[] line)

public boolean parseFlag(String a, String b)

private static final byte[] makeBaseToNumberACGNT()

</class DemuxData>
<class DemuxServer>
*Server for barcode demux queries.
*@author Brian Bushnell
*@date June 24, 2024
public class DemuxServer

#Fields
private HashMap<String,StringNum> versionMap=new HashMap<String,StringNum>()

private AtomicLongArray timesByCount=new AtomicLongArray(10000)

private AtomicLongArray queryCounts=new AtomicLongArray(10000)

private AtomicLong queries=new AtomicLong(0)

*Same IP address mask
private AtomicLong internalQueries=new AtomicLong(0)

private AtomicLong iconQueries=new AtomicLong(0)

private AtomicLong baseQueries=new AtomicLong(0)

private AtomicLong bytesIn=new AtomicLong(0)

private AtomicLong bytesOut=new AtomicLong(0)

private AtomicLong elapsedTimeUsage=new AtomicLong(0)

private AtomicLong timeMeasurementsUsage=new AtomicLong(0)

private AtomicLong lastTimeUsage=new AtomicLong(0)

private AtomicLong elapsedTimeRemote=new AtomicLong(0)

private AtomicLong timeMeasurementsRemote=new AtomicLong(0)

private AtomicLong lastTimeRemote=new AtomicLong(0)

private AtomicLong elapsedTimeLocal=new AtomicLong(0)

private AtomicLong timeMeasurementsLocal=new AtomicLong(0)

private AtomicLong lastTimeLocal=new AtomicLong(0)

private AtomicLong malformedQueries=new AtomicLong(0)

private boolean printIP=true

private boolean printHeaders=false

private boolean countQueries=true

final boolean allowLocalHost

final String addressPrefix

*Address of current server instance (optional)
private String domain=null

private final String startTime=new Date().toString()

*Listen on this port
private final int port

int handlerThreads=0

private final HttpServer httpServer

private boolean useHtml=false

private String killCode=null

private final String favIconPath=Data.findPath("?favicon.ico")

private final byte[] favIcon=ReadWrite.readRaw(favIconPath)

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
private static boolean verbose=false

*Print verbose messages
private static boolean verbose2=false

*Print verbose messages
private static boolean logUsage=false

*True if an error was encountered
private boolean errorState=false


#Methods
*Command line entrance
public static void main(String[] args)

*Constructor
private DemuxServer(String[] args)

*Iterative wait for server initialization
private HttpServer initializeServer(int millis0, int iterations, boolean https)

*Parse the query from the URL
private static String getRParam(HttpExchange t)

*Write to the body of an incoming HTTP session
@SuppressWarnings private static boolean reply(ArrayList<Pair> map, int encoding, int len1, int len2, String type, HttpExchange t, boolean verbose, int code, boolean close)

public static boolean writeToStream(ArrayList<Pair> map, OutputStream os, int encoding, int len1, int len2)

private static void appendA48(ByteBuilder bb, Pair p, Pair prev, int length1, int length2, byte[] buffer)

private HashMap<String,String> toAssignmentMap(DemuxData dd)

static final ArrayList<Pair> toPairList(HashMap<String,String> map)

static ArrayList<byte[]> getBody(HttpExchange t)

private void returnStats(long startTime, HttpExchange t)

private String basicStats()

private static boolean printQuery(HttpExchange t, String prefix, boolean allowLocalHost, boolean printIP, boolean printHeaders)

</class DemuxServer>
<class DemuxServer.Pair>
static class DemuxServer.Pair

#Fields
final String a

final String b


#Methods
Pair(String a_, String b_)

@Override public int compareTo(Pair o)

public final String toString()

</class DemuxServer.Pair>
<class LegacyFileWriter>
*Writes legacy stats files when demultiplexing, for compatibility.
*These are not very informative and not recommended for use.
*@author BBushnell
public class LegacyFileWriter

#Fields
private long totalR1=0

private long totalR2=0

private long totalR1Assigned=0

private long totalR2Assigned=0

Collection<Barcode> counts=null

final HashMap<String,QTag[]> tagMap=new HashMap<String,QTag[]>()

private static final String UNDETERMINED="Undetermined"

LinkedHashMap<Integer,LinkedHashMap<String,Barcode>> tileMap=new LinkedHashMap<Integer,LinkedHashMap<String,Barcode>>()

final IlluminaHeaderParser2 ihp=new IlluminaHeaderParser2()


#Methods
public LegacyFileWriter()

long writeTopUnknownBarcodes(Set<String> expectedSet, HashMap<String,String> assignmentMap, byte delimiter, String fname, int lane, int lines, boolean overwrite)

void writeIndexHoppingCounts(Set<String> expectedSet, LinkedHashMap<String,String> sampleMap, byte delimiter, String fname, int lane, boolean overwrite)

int writeQualityMetrics(Set<String> expectedSet, LinkedHashMap<String,String> sampleMap, byte delimiter, String fname, int lane, boolean overwrite)

void writeDemultiplexStats(String fname, HashMap<String,String> assignmentMap, Set<String> expected, LinkedHashMap<String,String> sampleMap, int lane, boolean overwrite)

void writeDemultiplexTileStats(String fname, LinkedHashMap<String,String> sampleMap, Collection<String> expected, int lane, byte delimiter, boolean overwrite)

void add(Read r, String barcode)

LinkedHashMap<String,String> loadSampleMap(String fname, byte barcodeDelimiter, boolean rcIndex1, boolean rcIndex2)

</class LegacyFileWriter>
<class LegacyFileWriter.QTag>
static class LegacyFileWriter.QTag

#Fields
long reads=0

long bases=0

long q30PositionSum=0

long q30CountSum=0

LongList qsum=new LongList()

LongList qcount=new LongList()


#Methods
int add(Read r)

int add(byte[] quals)

long yieldBases()

long yieldQ30()

long qualityScoreSum()

double meanQualityScore()

double fractionQ30()

ByteBuilder appendTo(ByteBuilder bb, int lane, int pairnum, String sampleID, byte delimiter, String barcode)

static String header()

</class LegacyFileWriter.QTag>
<class NovaDemux>
*This class is designed to demultiplex barcoded reads using PCRMatrix.
*@author Brian Bushnell
*@date April 2, 2024
public class NovaDemux

#Fields
*Primary input file
private String in1=null

*Optional input file for read 2 of paired reads in twin files
private String in2=null

*Output file pattern 1
private String out1=null

*Output file pattern 2
private String out2=null

*Unmatched read output file 1
private String outu1=null

*Unmatched read output file 2
private String outu2=null

*File extension override for input files
private String extin=null

*File extension override for output files
private String extout=null

*Pre-counted barcodes
private String countsIn=null

*Output for barcode counts
private String countsOut=null

*Output for barcode assignment counts
private String barcodesOut=null

private boolean rename=false

private boolean nosplit=false

*Ignore barcodes occuring fewer times than this.
*Saves memory and speeds processing.
private long minCount0=0

*Use stricter cutoffs during refinement for barcodes with lower count.
private long minCountR=4

*Use stricter cutoffs during assignment for barcodes with lower count.
private long minCountA=4

*Premade assignment map
private String mapIn=null

*Assignment map output
private String mapOut=null

private boolean useServer=false

private boolean setUseServer=false

private String spikeLabel=null

private String refPath="phix"

private MicroAligner2 spikeMapper

private int kSpike=27

private int skipMask=3

float minSpikeIdentity=0.7f

boolean mapUnexpectedToSpike=false

boolean mapAllToSpike=false

*Primary input file
private final FileFormat ffin1

*Read 2 input file
private final FileFormat ffin2

*Input reads
long readsProcessed=0

long basesProcessed=0

*Demultiplexed output reads
long readsOut=0

long basesOut=0

*Output reads that did not get demultiplexed
long readsUnmatched=0

long basesUnmatched=0

*Stop after this many input reads
private long maxReads=-1

*File to print number of reads sent to each output file
private String stats=null

*For splitting headers on a symbol
private String headerDelimiter=null

*For splitting headers faster if the delimiter is just one character
private char delimiterChar=0

private LineParserS2 lp=null

*Precompiled pattern matching the delimiter
private Pattern delimiterPattern=null

*For replacing symbols in the filename
private byte[] symbolRemap=null

*If there is a delimiter, use this column after splitting.
*Column is 1-based for parsing parameters but 0-based internally.
private int column=-1

*How to select a read's key; see static modes array
private int mode=BARCODE_MODE

*Track per-output-file cardinality; may be slow
private boolean trackCardinality=false

*Prevents issuing warnings multiple times
private boolean warned=false

private boolean printRetireTime=false

*Do not create files with under this many reads.
*Increases memory usage since reads must be retained until processing is finished.
*Upon running out of memory the program may go very slowly.
private long minReadsToDump=0

*Affix length if fixed
private int fixedLength=-1

*A set of recognized names and the output names they map to.
*The keys and values will be identical unless a Hamming distance is used.
*This is only filled if explicit names are provided.
private HashMap<String,String> assignmentMap=null

private LinkedHashSet<String> expectedSet=null

private LinkedHashSet<String> outSubset=null

*Whether input file interleaving was explicitly set
private boolean setInterleaved=false

private IlluminaHeaderParser2 ihp=new IlluminaHeaderParser2()

private int lane=0

private String legacyPath

private String sampleMapFile

private final LegacyFileWriter legacyWriter

private int barcodeDelimiter=0

private int barcodeLength1=0

private int barcodeLength2=0

private boolean rcIndex1=false

private boolean rcIndex2=false

*Print messages here
private PrintStream outstream=System.err

*True if errors were encountered
public boolean errorState=false

*Create empty files for barcodes that are expected but absent.
private boolean writeEmptyFiles=true

*Permission to overwrite existing files.
private boolean overwrite=true

*Append to existing files rather than overwriting.
*It is not advisable to set this flag for this class.
private boolean append=false

*Retain header of sam/bam files.
private boolean useSharedHeader=false

*Operation mode for selection of key
public static final int BARCODE_MODE=1

*Operation mode for selection of key
public static final int PREFIX_MODE=2

*Operation mode for selection of key
public static final int SUFFIX_MODE=3

*Operation mode for selection of key
public static final int DELIMITER_MODE=4

*Operation mode for selection of key
public static final int HEADER_MODE=5

private static final String empty=""

*Verbose messages for debugging
public static boolean verbose=false

public static boolean verboseClient=true

public static boolean statsOnly=false


#Methods
*Code entrance from the command line
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public NovaDemux(String[] args)

*Parse command-line arguments
*@param args Command-line arguments
*@return A Parser object with fields filled from the parameters
private Parser parse(String[] args)

*Ensure input and output files are specified correctly,
*and that interleaved mode is consistent with the number of input files.
private void validate()

private void processHeaderDelimiter()

private HashMap<String,String> makeAssignmentMap()

private HashMap<String,String> filterAssignmentMap(HashMap<String,String> map, Set<String> set)

*Primary method.
*Starts and stops I/O streams, processes the data, and prints results.
*@param t A timer that was already started.
void process(Timer t)

*Create and start the input stream (cris).
private ConcurrentReadInputStream makeInputStream()

*Create and start the normal output streams (mcros).
private BufferedMultiCros makeMatchedOutputStream(boolean pairedInput)

*Create and start the unmatched output stream (rosu).
private ConcurrentReadOutputStream makeUnmatchedOutputStream()

*Process all reads.
*@param cris Input stream (required).
*@param mcros Matched read output stream (optional).
*@param rosu Unmatched read output stream (optional).
private void processInner(ConcurrentReadInputStream cris, BufferedMultiCros mcros, ConcurrentReadOutputStream rosu)

private void rename(Read r, String name)

*Finish writing and close streams.
*@param cris Input stream (required).
*@param mcros Matched read output stream (optional).
*@param rosu Unmatched read output stream (optional).
private void cleanup(ConcurrentReadInputStream cris, BufferedMultiCros mcros, ConcurrentReadOutputStream rosu)

*@param t A Timer that has already been stopped
private void printResultsToScreen(Timer t)

*Returns the value this read maps to; meaning, the variable part of the output filename
private String getValue(Read r)

*Generates a key from the read header
private String getKey(Read r)

*Print statistics about demultiplexing to a file.
*@param mcros Output stream, after processing is completely finished.
void printReport(BufferedMultiCros mcros)

</class NovaDemux>
<class PCRMatrix>
*Tracks data about bar code mismatches by position.
*Used for demultiplexing.
*@author Brian Bushnell
*@date March 7, 2024
public abstract class PCRMatrix

#Fields
private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

protected final int length

protected final int length1

protected final int length2

protected final int delimiter

protected final int delimiterPos

protected final int start2

protected final int letters

protected final boolean hdistSum

*[position][Call: A,C,G,T,N][Ref: A,C,G,T,N,Sum]
protected final long[][][] counts

protected long totalCounted

protected long totalAssigned

protected long totalAssignedToExpected

protected ArrayList<Barcode> expectedList

protected HashMap<String,Barcode> expectedMap

protected byte[][] leftBytes

protected byte[][] rightBytes

protected byte[][][] splitBytes

protected Barcode[] leftCodes

protected Barcode[] rightCodes

protected Barcode[] allCodes

protected HashMap<String,Barcode> allCodesMap

public boolean verbose=true

public static boolean verbose2=false

public boolean errorState=false

public static boolean errorStateS=false

protected static boolean addPolyA=false

protected static boolean addPolyC=false

protected static boolean addPolyG=false

protected static boolean addPolyT=false

protected static int matrixThreads=64

protected static boolean localCounts=true

public static boolean byTile=false

protected static boolean devMode=false

protected static boolean hdistSum0=false

public static final int HDIST_TYPE=0

public static final int PROB_TYPE=1

public static final int TILE_TYPE=2

public static final int HDIST_OLD_TYPE=7

public static final int PROB_OLD_TYPE=8

protected static int matrixType0=HDIST_TYPE

protected static final byte[] baseToNumber=AminoAcid.baseToNumber4

protected static final byte[] numberToBase=AminoAcid.numberToBase


#Methods
protected PCRMatrix(int length1_, int length2_, int delimiter_, boolean hdistSum_)

public static PCRMatrix create(int length1_, int length2_, int delimiter_)

public static PCRMatrix create(int type, int length1_, int length2_, int delimiter_, boolean hdistSum_)

public static boolean parseStatic(String arg, String a, String b)

public boolean parse(String arg, String a, String b)

public static void postParseStatic()

public final void printAssignmentMap(HashMap<String,String> assignmentMap, String mapOut, Collection<Barcode> counts, boolean overwrite, boolean append)

public void printAssignmentMap(HashMap<String,String> assignmentMap, String mapOut, HashMap<String,Barcode> counts, boolean overwrite, boolean append)

public static final void printAssignmentMapStatic(HashMap<String,String> assignmentMap, String mapOut, Collection<Barcode> counts, boolean overwrite, boolean append)

public static void printAssignmentMapStatic(HashMap<String,String> assignmentMap, String mapOut, HashMap<String,Barcode> counts, boolean overwrite, boolean append)

public static final void printAssignmentMap(ArrayList<MapLine> lines, String mapOut, boolean overwrite, boolean append)

protected static final void fillHDistList(byte[] q, byte[][] list, IntList hdList)

public static final int hdist(byte[] q, byte[] r)

public final int hdist(int d1, int d2)

public final int hdist(Barcode q, String r)

public final int hdist(String q, String r)

public static final long encodeHDist(long idx, long hdist, long hdist2)

protected final ArrayList<Barcode> highpass(Collection<Barcode> codeCounts, long minCount)

protected final Barcode findClosestHDist(String s, int maxHDist, int clearzone)

protected final Barcode findClosestSingleHDist(String q, int maxHDist, int clearzone)

protected final Barcode findClosestDualHDist(String q, int maxHDist, int clearzone)

protected final long findClosestHDist(byte[] q, byte[][] list, int maxHDist, int clearzone)

public Barcode findClosest(String s)

public void refine(Collection<Barcode> codeCounts, long minCount)

public HashMap<String,String> makeAssignmentMap(Collection<Barcode> codeCounts, long minCount)

public void populateCounts(ArrayList<Barcode> list, long minCount)

public void makeProbs()

public void initializeData()

protected boolean valid()

@SuppressWarnings public final void populateExpected(Collection<String> expected)

public final void populateExpectedFromBarcodes(Collection<Barcode> expected)

public void populateUnexpected()

public final void populateSplitCodes()

public final void populateSplitCodes(DemuxData dd)

public void clearCounts()

public final float assignedFraction()

public final float expectedFraction()

public final float chimericFraction()

public final void add(Barcode query, Barcode ref)

public final void add(String query, Barcode ref, long count)

public final void add(String query, Barcode ref, long count, int pos)

public ByteBuilder toBytes(ByteBuilder bb)

public ByteBuilder toAccuracy(ByteBuilder bb, boolean excludeUnknown)

public boolean byTile()

public ByteBuilder toBytesProb(ByteBuilder bb)

public final void add(PCRMatrix p)

protected final Barcode getBarcode(String s)

public static final ByteBuilder toBytes(long[][][] counts, ByteBuilder bb)

public static final ByteBuilder toAccuracy(long[][][] counts, ByteBuilder bb, boolean excludeUnknown)

private static String poly(char c, int len)

protected final void writelock()

protected final void writeunlock()

protected final void readlock()

protected final void readunlock()

public final ReadWriteLock rwlock()

</class PCRMatrix>
<class PCRMatrix.MapLine>
public static class PCRMatrix.MapLine

#Fields
final String observed

final String assigned

final long count

final int hdist

float prob=-1


#Methods
public MapLine(String observed_, String assigned_, long count_, float prob_)

@Override public int compareTo(MapLine b)

public ByteBuilder toBytes()

@Override public String toString()

</class PCRMatrix.MapLine>
<class PCRMatrixHDist>
*Tracks data about bar code mismatches by position.
*Uses split barcodes instead of contiguous.
*@author Brian Bushnell
*@date March 22, 2024
public class PCRMatrixHDist

#Fields
static int maxHDist0=2

static int clearzone0=1


#Methods
public PCRMatrixHDist(int length1_, int length2_, int delimiter_, boolean hdistSum_)

public static boolean parseStatic(String arg, String a, String b)

@Override public boolean parse(String arg, String a, String b)

public static void postParseStatic()

@Override public Barcode findClosest(String s)

public Barcode findClosest(String s, int maxHDist, int clearzone)

@Override public void makeProbs()

@Override public void initializeData()

@Override public void refine(Collection<Barcode> codeCounts, long minCount)

@Override public HashMap<String,String> makeAssignmentMap(Collection<Barcode> codeCounts, long minCount)

@Override public void populateCounts(ArrayList<Barcode> list, long minCount)

private void populateCountsST(ArrayList<Barcode> countList, int maxHDist, int clearzone)

private void populateCountsMT(ArrayList<Barcode> list, int maxHDist, int clearzone, HashMap<String,String> map)

@Override public void populateUnexpected()

@Override public ByteBuilder toBytesProb(ByteBuilder bb)

protected boolean valid()

@Override public final void accumulate(PopThread t)

@Override public boolean success()

</class PCRMatrixHDist>
<class PCRMatrixHDist.PopThread>
final class PCRMatrixHDist.PopThread

#Fields
final ArrayList<Barcode> list

final int maxHDist

final int clearzone

final int tid

final int threads

final HashMap<String,String> map

final long[][][] countsT

long totalCountedT

long totalAssignedT

long totalAssignedToExpectedT


#Methods
public PopThread(ArrayList<Barcode> list_, int maxHDist_, int clearzone_, HashMap<String,String> map_, int tid_, int threads_)

@Override public void run()

public void addT(String query, Barcode ref, long count)

</class PCRMatrixHDist.PopThread>
<class TagAndMerge>
*This is intended to run simultaneously on all files from a demultiplexed lane,
*labeling each read with the barcode of the input file, then printing them
*to a single output file.
*For example, all reads from input file 52866.4.475040.GAGGCCGCCA-TTATCTAGCT.filter-DNA.fastq.gz
*would have "(tab)GAGGCCGCCA+TTATCTAGCT" appended to their headers.
*@author Brian Bushnell
*@date May 10, 2024
public class TagAndMerge

#Fields
private ArrayList<String> in=new ArrayList<String>()

private String out1=null

private String barcodesOutFile=null

private LinkedHashSet<String> barcodes=new LinkedHashSet<String>()

private int trimLen=-1

private boolean dropR2=false

private boolean shrinkHeader=false

private char[] remap=new char[]{'-','+'}

private final FileFormat ffout1

private boolean overwrite=true

private boolean append=false

private long maxReads=-1

private long readsProcessed=0

private long basesProcessed=0

private long readsOut=0

private long basesOut=0

private final ByteBuilder bb=new ByteBuilder()

private final LineParserS4 lp=new LineParserS4(":::::: ")

private java.io.PrintStream outstream=System.err

public static boolean verbose=false


#Methods
public static void main(String[] args)

public TagAndMerge(String[] args)

void process(Timer t)

void processInner(String fname, ConcurrentReadOutputStream ros)

private void processPair(Read r, String tag)

private void processRead(Read r, String tag)

</class TagAndMerge>
<class Transition>
public class Transition

#Fields
public final int pos

public final byte ref

public final byte query

public long count

private static final byte[] numberToBase=AminoAcid.numberToBase

private static final byte[] baseToNumber=AminoAcid.baseToNumber4


#Methods
public Transition(int pos_, byte ref_, byte query_, long count_)

public int encode()

public static int encode(int pos, int ref, int query)

public static Transition decode(int idx)

public ByteBuilder appendTo(ByteBuilder bb)

@Override public int compareTo(Transition b)

</class Transition>
