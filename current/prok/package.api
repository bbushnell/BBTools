#version 1
#package prok
#generated 2025-09-06T20:38:00

<class AnalyzeGenes>
*This class is designed to analyze paired prokaryotic fna and gff files
*to calculate the patterns in coding and noncoding frames, start and stop sites.
*It outputs a pgm file.
*@author Brian Bushnell
*@date Sep 27, 2018
public class AnalyzeGenes

#Fields
private ArrayList<String> fnaList=new ArrayList<String>()

private ArrayList<String> gffList=new ArrayList<String>()

private IntList taxList=new IntList()

private String out=null

private long bytesOut=0

static boolean alignRibo=true

static boolean adjustEndpoints=true

private final FileFormat ffout

private final int threads

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public AnalyzeGenes(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

void process(Timer t)

private static String timeReadsBasesGenesProcessed(Timer t, long readsProcessed, long basesProcessed, long genesProcessed, long filesProcessed, int pad)

private static String readsBasesGenesProcessed(long elapsed, long reads, long bases, long genes, long files, int pad)

private static String typesProcessed(GeneModel pgm, int pad)

private GeneModel makeModelST()

*Spawn process threads
private GeneModel spawnThreads()

private GeneModel waitForThreads(ArrayList<FileThread> alpt)

</class AnalyzeGenes>
<class CallGenes>
*This is the executable class for gene-calling.
*@author Brian Bushnell
*@date Sep 24, 2018
public class CallGenes

#Fields
private long maxReads=-1

private boolean merge

private boolean ecco

private int passes=1

private long readsIn=0

private long basesIn=0

private long genesOut=0

private long bytesOut=0

private static int minLen=80

private static int maxOverlapSameStrand=80

private static int maxOverlapOppositeStrand=110

private static float minStartScore=-0.10f

private static float minStopScore=-0.5f

private static float minKmerScore=0.02f

private static float minOrfScore=50f

private static float minAvgScore=0.08f

long geneStopsMade=0

long geneStartsMade=0

long geneStartsRetained=0

long geneStopsRetained=0

long geneStartsOut=0

long tRNAOut=0

long r16SOut=0

long r23SOut=0

long r5SOut=0

long r18SOut=0

ScoreTracker stCds=new ScoreTracker(CDS)

ScoreTracker stCds2=new ScoreTracker(CDS)

ScoreTracker stCdsPass=new ScoreTracker(CDS)

ScoreTracker sttRNA=new ScoreTracker(tRNA)

ScoreTracker st16s=new ScoreTracker(r16S)

ScoreTracker st23s=new ScoreTracker(r23S)

ScoreTracker st5s=new ScoreTracker(r5S)

ScoreTracker st18s=new ScoreTracker(r18S)

ScoreTracker[] trackers=new ScoreTracker[]{stCdsPass,sttRNA,st16s,st23s,st5s,st18s}

private int geneHistBins=1000

private int geneHistDiv=21

private final long[] geneHist

private boolean printZeroCountHist=false

private ArrayList<String> fnaList=new ArrayList<String>()

private ArrayList<String> pgmList=new ArrayList<String>()

private ArrayList<String> inGffList=new ArrayList<String>()

private String outGff=null

private String outAmino=null

private String out16S=null

private String out18S=null

private String compareToGff=null

private String outStats="stderr"

private String geneHistFile=null

private boolean json_out=false

private final FileFormat ffoutGff

private final FileFormat ffoutAmino

private final FileFormat ffout16S

private final FileFormat ffout18S

*Determines how sequence is processed if it will be output
int mode=TRANSLATE

*Translate nucleotides to amino acids
private static final int TRANSLATE=1

*Translate nucleotides to amino acids,
*then translate back to nucleotides
private static final int RETRANSLATE=2

*Re-encode coding regions of nucleotide
*sequences as a canonical codons
private static final int RECODE=3

private PrintStream outstream=System.err

public boolean verbose=false

public boolean extendedStats=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false

private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public CallGenes(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Create read streams and process all data
void process(Timer t)

private void printStats(String fname)

private void printStatsJson(String fname)

private void printHist(String fname)

private ConcurrentReadInputStream makeCris(String fname)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ByteStreamWriter bsw, ConcurrentReadOutputStream rosAmino, ConcurrentReadOutputStream ros16S, ConcurrentReadOutputStream ros18S, GeneModel pgm)

private void waitForThreads(ArrayList<ProcessThread> alpt)

public static GeneModel makeMultipassModel(GeneModel pgm0, String fna, String gff, int passes)

public static GeneModel makeMultipassModel(GeneModel pgm0, ArrayList<Read> reads, String gff, int passes)

*This needs a pgm OR a gff, not both
public static GeneModel runOnePass(String fna, String gff, GeneModel pgm0)

*This needs a pgm OR a gff, not both
public static GeneModel runOnePass(ArrayList<Read> reads, String gff, GeneModel pgm0)

private static ByteStreamWriter makeBSW(FileFormat ff)

private ConcurrentReadOutputStream makeCros(FileFormat ff)

public static ArrayList<Read> fetchType(Read r, ArrayList<Orf> list, int type)

public static ArrayList<Read> translate(Read r, ArrayList<Orf> list)

public static Read recode(Read r, ArrayList<Orf> list)

public static ArrayList<Read> detranslate(ArrayList<Read> prots)

public static Read translate(Orf orf, byte[] bases, String id)

public static ArrayList<Read> fetch(Read r, ArrayList<Orf> list)

public static Read fetch(Orf orf, Read source)

public static Read fetch(Orf orf, byte[] bases, String id)

public static void recode(Orf orf, byte[] bases)

public static Read detranslate(Read prot)

public static GeneCaller makeGeneCaller(GeneModel pgm)

</class CallGenes>
<class FetchProks>
*Crawls ncbi's ftp site to download genomes and annotations
public class FetchProks

#Fields
static boolean verbose=true

static int maxSpeciesPerGenus=1

static boolean renameFiles=true

static boolean renameSequences=true

static int retries=40

static boolean findBest=false

static boolean tidInFilename=true

static int totalSpecies=0

static int totalGenus=0

static int totalGenomes=0

private static final Integer one=1


#Methods
public static void main(String[] args)

static String getGenus(String path)

static String getSpecies(String path)

static int examineSpecies(String baseAddress, TextStreamWriter tsw)

static int examineAssemblies(String baseAddress, TextStreamWriter tsw, String speciesName)

*Tries to find the assembly with the longest contig
static Stats findBestAssembly(String baseAddress)

static Stats calcStats(String baseAddress)

static int examineAssembly(Stats stats, TextStreamWriter tsw, String speciesName)

static String makeSubAddress(String baseAddress, String extension)

static int seen(String s, HashMap<String,Integer> map)

static void put(String s, int found, HashMap<String,Integer> map)

</class FetchProks>
<class FetchProks.ProcessThread>
static class FetchProks.ProcessThread

#Fields
final ArrayList<String> speciesList

final int tid

final int threads

HashMap<String,Integer> seen=new HashMap<String,Integer>()

final TextStreamWriter tsw

int totalSpeciesT=0

int totalGenusT=0

int totalGenomesT=0


#Methods
ProcessThread(ArrayList<String> speciesList_, TextStreamWriter tsw_, int tid_, int threads_)

@Override public void run()

void processSpecies(String species)

</class FetchProks.ProcessThread>
<class FetchProks.Stats>
static class FetchProks.Stats

#Fields
String path

String name

long maxContig

long size

int contigs

int taxID


#Methods
public Stats(String path_, long maxContig_, long size_, int contigs_, int taxID_)

@Override public int compareTo(Stats b)

</class FetchProks.Stats>
<class FilterSilva>
*Removes unwanted sequences from Silva, particularly bacteria flagged as euks due to name misidentification.
*@author Brian Bushnell
*@date January 27, 2020
public class FilterSilva

#Fields
private String in1=null

private String out1=null

private String extin=null

private String extout=null

private String treeFile="auto"

private long maxReads=-1

private final FileFormat ffin1

private final FileFormat ffout1

private final TaxTree tree

private PrintStream outstream=System.err

public static boolean verbose=false

public boolean errorState=false

private boolean overwrite=true

private boolean append=false


#Methods
public static void main(String[] args)

public FilterSilva(String[] args)

void process(Timer t)

private boolean process(Read r)

</class FilterSilva>
<class FrameStats>
*Stores frame-relative kmer counts for a type of genomic feature, such as a coding start site.
*@author Brian Bushnell
*@date Sep 24, 2018
public class FrameStats

#Fields
public final String name

public final int k

public final int mask

public final int frames

public final int kMax

public final float invFrames

public final int leftOffset

public final float[][] probs

public final long[][] countsTrue

public final long[][] countsFalse

public final long[][][] counts

public final long[] validSums=KillSwitch.allocLong1D(2)

private float average=-1

private float invAvg=-1


#Methods
public FrameStats(String name_, int k_, int frames_, int leftOffset_)

public void add(int kmer, int frame, int valid)

public boolean compatibleWith(FrameStats fs)

public void clear()

public void setFrom(FrameStats fs)

public void add(FrameStats fs)

public void multiplyBy(double mult)

void calculate()

public float scorePoint(int point, byte[] bases)

void processCDSFrames(byte[] bases, byte[] validFrames)

void processPoint(byte[] bases, int point, int valid)

public void parseData(byte[] line)

@Override public String toString()

public ByteBuilder appendTo(ByteBuilder bb)

public ByteBuilder append0(ByteBuilder bb)

public int rightOffset()

</class FrameStats>
<class GeneCaller>
*This class calls genes within a single thread.
*@author Brian Bushnell
*@date Sep 24, 2018
public class GeneCaller

#Fields
*Current gene model.
*TODO: Dynamically swap this as needed for contigs with varying GC.
GeneModel pgm

final int minLen

final int maxOverlapSameStrand

final int maxOverlapOppositeStrand

final float minStartScore

final float minStopScore

final float minInnerScore

final float minOrfScore

final float minAvgScore

static float[] cutoff1=new float[]{0,20f,300f,400f,100f,400f}

static float[] cutoff2=new float[]{0,36f,300f,300f,32f,300f}

static float[] cutoff3=new float[]{0,2.4f,1.65f,1.6f,1.8f,1.5f}

static float[] cutoff4=new float[]{0,1.5f,1.70f,0.90f,1.0f,1.1f}

static float[] cutoff5=new float[]{0,2.2f,1.70f,1.55f,2.6f,1.5f}

static float[] scoreMult=new float[]{1f,1.0f,35f,80f,1.25f,35f}

static float[] biases=new float[]{1f,1.45f,1.30f,1.30f,1.55f,1.50f}

long geneStopsMade=0

long geneStartsMade=0

long geneStartsRetained=0

long geneStopsRetained=0

long geneStartsOut=0

long tRNAOut=0

long r16SOut=0

long r23SOut=0

long r5SOut=0

long r18SOut=0

ScoreTracker stCds=new ScoreTracker(CDS)

ScoreTracker stCds2=new ScoreTracker(CDS)

ScoreTracker stCdsPass=new ScoreTracker(CDS)

ScoreTracker sttRNA=new ScoreTracker(tRNA)

ScoreTracker st16s=new ScoreTracker(r16S)

ScoreTracker st23s=new ScoreTracker(r23S)

ScoreTracker st5s=new ScoreTracker(r5S)

ScoreTracker st18s=new ScoreTracker(r18S)

ScoreTracker[] trackers=new ScoreTracker[]{stCdsPass,sttRNA,st16s,st23s,st5s,st18s}

public boolean keepAtLeastOneOrf=false

private static ThreadLocal<SingleStateAlignerFlat2> localSSA=new ThreadLocal<SingleStateAlignerFlat2>()

private static ThreadLocal<SingleStateAlignerFlat3> localSSA3=new ThreadLocal<SingleStateAlignerFlat3>()

private static ThreadLocal<SingleStateAlignerFlatFloat> localSSAF=new ThreadLocal<SingleStateAlignerFlatFloat>()

public static int alignmentPadding=300

public static int alignmentPaddingIDA=80

public static boolean useIDAligner=false

public static int breakLimit=12

public static int lookbackPlus=70

public static int lookbackMinus=25

public static float p0=-30f

public static float p1=-0.35f

public static float p2=4.0f

public static float p3=12f

public static float p4=-10f

public static float p5=2.0f

public static float p6=2f

public static float q1=-36f

public static float q2=-1.6f

public static float q3=-12f

public static float q4=3.0f

public static float q5=-40f

private static PrintStream outstream=System.err

static boolean verbose


#Methods
GeneCaller(int minLen_, int maxOverlapSameStrand_, int maxOverlapOppositeStrand_, float minStartScore_, float minStopScore_, float minInnerScore_, float minOrfScore_, float minAvgScore_, GeneModel pgm_)

public ArrayList<Orf> callGenes(ArrayList<Read> reads)

public ArrayList<Orf> callGenes(Read r)

public ArrayList<Orf> callGenes(Read r, boolean breakOrfs)

public ArrayList<Orf> callGenes(Read r, GeneModel pgm_, boolean breakOrfs)

*Generates lists of all max-length non-overlapping Orfs per frame.
*There IS overlap between frames.
*All Orfs come out flipped to + orientation.
ArrayList<Orf>[] makeRnas(String name, byte[] bases)

*Designed for quickly calling a single SSU
public Orf makeRna(String name, byte[] bases, int type)

final Orf pickBest(ArrayList<Orf> list)

*Generates lists of all max-length non-overlapping Orfs per frame.
*There IS overlap between frames.
*All Orfs come out flipped to + orientation.
static ArrayList<Orf>[] makeOrfs(String name, byte[] bases, int minlen)

*Dynamic programming phase.
*@param frameLists
*@param bases
*@return
private ArrayList<Orf> findPath(ArrayList<Orf>[] frameLists, byte[] bases)

*Calculate the best path to this ORF.
*@param orf
*@param frameLists
*@param lastPositionScored
*@param bestIndex
private void calcPathScore(Orf orf, ArrayList<Orf>[] frameLists, int[] lastPositionScored, int[][] bestIndex)

*Calculate the best path to this ORF from a plus-strand previous ORF.
*@param orf
*@param list
*@param listStrand
*@param lastPos
*@param bestPos
private void calcPathScorePlus(Orf orf, ArrayList<Orf> list, int listStrand, int lastPos, int bestPos)

*Calculate the best path to this ORF from a minus-strand previous ORF.
*@param orf
*@param list
*@param listStrand
*@param lastPos
*@param bestPos
private void calcPathScoreMinus(Orf orf, ArrayList<Orf> list, int listStrand, int lastPos, int bestPos)

*Generates a list of maximal-length Orfs only (non-overlapping).
*All Orfs come out in native orientation (unflipped).
static ArrayList<Orf> makeOrfsForFrame(String name, byte[] bases, int startFrame, int strand, int minlen)

*Generates a list of maximal-length RNAs (non-overlapping).
*All RNAs come out in native orientation (unflipped).
ArrayList<Orf> makeRnasForStrand(String name, byte[] bases, int strand, StatsContainer sc, float[] scores, int[] kmersSeen, boolean quitEarly, float bias)

void fillKmersSeen(byte[] bases, int[] kmersSeen, LongHashSet set, int k)

boolean refineRna(Orf orf, byte[] bases, int strand, StatsContainer sc, float[] scores, int[] kmersSeen)

boolean refineByAlignment(Orf orf, byte[] bases, int strand, StatsContainer sc)

boolean refineByAlignment(Orf orf, byte[] bases, int strand, StatsContainer sc, byte[] consensus, int startSlop, int stopSlop, int recurLimit)

boolean refineByAlignment_IDA(Orf orf, byte[] bases, int strand, StatsContainer sc, byte[] consensus, int startSlop, int stopSlop, int recurLimit)

boolean refineByAlignment_SSA(Orf orf, byte[] bases, int strand, StatsContainer sc, byte[] consensus, int startSlop, int stopSlop, int recurLimit)

void fillPoints(int left, int right, byte[] bases, FrameStats fs, float thresh, IntList points, FloatList scores)

*Generate all possible genes from each Orf, and return them in a new set of lists.
*@param frameLists
*@param bases
*@return Lists of orfs.
private ArrayList<Orf>[] breakOrfs(ArrayList<Orf>[] frameLists, byte[] bases)

*Generate an Orf for each possible start codon.
*Retain only the high-scoring ones.
*@param longest Longest open reading frame for a given stop.
*@param bases Bases, oriented for this Orf.
*@return List of Orfs.
private ArrayList<Orf> breakOrf(Orf longest, byte[] bases)

*Return a score of how well this sequence matches a feature based on inner kmer frequencies.
*Intended to see whether a short read matches a feature, or which side matches better.
*Generally this would be called twice, with bases being reverse-complemented in between.
*@param bases Bases, oriented on the intended strand.
*@param type Type of feature, e.g. ProkObject.CDS.
*@return Average score of best-scoring frame for this strand.
public float scoreFeature(byte[] bases, int type)

public static SingleStateAlignerFlat2 getSSA()

public static SingleStateAlignerFlat3 getSSA3()

public static SingleStateAlignerFlatFloat getSSAF()

</class GeneCaller>
<class GeneModel>
*This class is designed to store kmer frequencies related to gene
*starts, stops, and interiors. It can be loaded from a pgm file.
*It's possible to use multiple GeneModels; for example, one for
*each of several GC ranges or clades.
*@author Brian Bushnell
*@date Sep 24, 2018
public class GeneModel

#Fields
public static boolean ADD_CDS_ONLY=false

public final StatsContainer statsCDS=new StatsContainer(CDS)

public final StatsContainer statstRNA=new StatsContainer(tRNA)

public final StatsContainer stats16S=new StatsContainer(r16S)

public final StatsContainer stats23S=new StatsContainer(r23S)

public final StatsContainer stats5S=new StatsContainer(r5S)

public final StatsContainer stats18S=new StatsContainer(r18S)

final StatsContainer[] rnaContainers=new StatsContainer[]{statstRNA,stats16S,stats23S,stats5S,stats18S}

final StatsContainer[] allContainers=new StatsContainer[]{statsCDS,statstRNA,stats16S,stats23S,stats5S,stats18S}

public int numFiles=0

public IntList taxIds=new IntList()

private long maxReads=-1

long readsProcessed=0

long basesProcessed=0

long genesProcessed=0

long filesProcessed=0

long[] baseCounts=new long[5]

public static int kInnerCDS=6

public static int kStartCDS=3

public static int kStopCDS=3

private static int startLeftOffset=21

private static int startRightOffset=8

private static int startFrames=startLeftOffset + startRightOffset + 1

private static int stopLeftOffset=9

private static int stopRightOffset=12

private static int stopFrames=stopLeftOffset + stopRightOffset + 1

private static boolean setStatics=false

public static String[] startCodons=new String[]{"ATG","GTG","TTG"}

public static String[] extendedStartCodons=new String[]{"ATG","GTG","TTG","ATT","CTG","ATA"}

public static String[] stopCodons=new String[]{"TAG","TAA","TGA"}

public static boolean[] isStartCodon=makeIsCodon(startCodons)

public static boolean[] isStopCodon=makeIsCodon(stopCodons)

private static PrintStream outstream=System.err

public static boolean verbose=false

public static boolean errorState=false


#Methods
public GeneModel(boolean fill)

void fillContainers()

public boolean process(String genomeFname, String gffFname)

public boolean process(ArrayList<Read> genome, ArrayList<GffLine> cds, ArrayList<GffLine> rrna, ArrayList<GffLine> trna)

public void add(GeneModel pgm)

public void multiplyBy(double mult)

public float gc()

HashMap<String,ScafData> makeScafMap(ArrayList<ScafData> scafList)

public void fillScafDataCDS(ArrayList<GffLine> cdsLines, HashMap<String,ScafData> scafMap)

public void fillScafDataRNA(ArrayList<GffLine> rnaLines, HashMap<String,ScafData> scafMap)

public void processStrand(ArrayList<ScafData> scafList, int strand)

private void countBases(ArrayList<ScafData> scafList)

private void countBases(byte[] bases)

private static void findStopCodons(byte[] bases, IntList list, BitSet valid)

private static void findStartCodons(byte[] bases, IntList list, BitSet valid)

private static void processGene(GffLine gline, ScafData sd)

private boolean processRnaLine(GffLine gline, ScafData sd, int type)

private float align(byte[] query, byte[] ref, int start, int stop, float minIdentity, int[] coords)

*Each frame byte has a bit marked for valid coding frames.
*For example, if frames[23]=0b100, then base 23 is the last base in a kmer starting at the 3rd base in a codon.
*If frames[23]=0, then no coding kmer end at that location on this strand.
*@param start
*@param stop
*@param frames
*@param k
private static void markFrames(int start, int stop, byte[] frames, int k)

private void processCDS(ScafData sd, int strand)

private static int getGlineType(GffLine gline, ScafData sd)

private void processRNA(ScafData sd, int strand)

void processRnaInner(ScafData sd)

void processRnaEnds(ScafData sd)

private static BitSet processEnds(byte[] bases, FrameStats stats, IntList list, int valid)

@Override public String toString()

public ByteBuilder appendTo(ByteBuilder bb)

public void setStatics()

public static void setInnerK(int k)

public static void setStartK(int k)

public static void setStopK(int k)

public static void setStartLeftOffset(int x)

public static void setStartRightOffset(int x)

public static void setStopLeftOffset(int x)

public static void setStopRightOffset(int x)

public static final boolean isStartCodon(int code)

public static final boolean isStopCodon(int code)

private static boolean[] makeIsCodon(String[] codons)

static int startLeftOffset()

static int startRightOffset()

static int startFrames()

</class GeneModel>
<class GeneModelParser>
public class GeneModelParser

#Fields
final String fname

final ArrayList<byte[]> lines

private final GeneModel gm

int pos=0


#Methods
GeneModelParser(String fname_)

boolean hasMore()

byte[] nextLine()

public static GeneModel loadModel(String fname)

private GeneModel parse()

private StatsContainer parseContainer()

private FrameStats parseStats()

private static String parseString(byte[] line)

private static int parseInt(byte[] line)

private static long parseLong(byte[] line)

public boolean parseHeader(byte[] line)

</class GeneModelParser>
<class MergeRibo>
*Picks one ribosomal (16S) sequence per taxID.
*@author Brian Bushnell
*@date November 19, 2015
public class MergeRibo

#Fields
*Primary input file path
private ArrayList<String> in=new ArrayList<String>()

*Alternate input file path
private String alt=null

*Primary output file path
private String out1=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

ArrayList<Ribo> bestList=new ArrayList<Ribo>()

HashMap<Integer,ArrayList<Ribo>> listMap=new HashMap<Integer,ArrayList<Ribo>>(100000)

ConcurrentLinkedQueue<ArrayList<Ribo>> queue

private TaxTree tree=null

private String treePath="auto"

private boolean useTree=false

private int taxLevelE=-1

private boolean dada2=false

IntHashSet seenTaxID=new IntHashSet(1000000)

byte[] consensus16S

byte[] consensus18S

boolean useConsensus=false

boolean fast=false

int maxns=-1

int minlen=1

int maxlen=4000

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private float minID=0.62f

private boolean process16S=true

private boolean process18S=false

*Primary input file
private final ArrayList<FileFormat> ffin

private final FileFormat ffalt

*Primary output file
private final FileFormat ffout1

final int threads

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public MergeRibo(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ConcurrentLinkedQueue<ArrayList<Ribo>> makeQueue()

private ConcurrentReadInputStream makeCris(FileFormat ff)

private ConcurrentReadOutputStream makeCros()

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, boolean altData)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

private float lengthMult(int len)

private float score(int len, float identity)

private TaxTree loadTree()

int idealLength()

@Override public final ReadWriteLock rwlock()

</class MergeRibo>
<class MergeRibo.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class MergeRibo.ProcessThread

#Fields
SingleStateAlignerFlat2 ssa=new SingleStateAlignerFlat2()

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Thread ID
final int threadID

final boolean processInput

final boolean altData


#Methods
ProcessThread(ConcurrentReadInputStream cris_, int tid_, boolean alt_)

@Override public void run()

*Iterate through the reads
void processInner()

void processInput(ListNum<Read> ln)

void pickBest()

*Get the best sequence and possibly rename it
Ribo pickBest(ArrayList<Ribo> list)

Ribo pickBestInner(ArrayList<Ribo> list)

*Process a read or a read pair.
*@return True if the reads should be kept, false if they should be discarded.
void processRead(Read r)

float align(Read r)

</class MergeRibo.ProcessThread>
<class MergeRibo_Fast>
*Picks one ribosomal (16S) sequence per taxID.
*This is the old version that does not make a consensus per taxID.
*Instead it just picks whatever aligns best to the global consensus.
*@author Brian Bushnell
*@date November 19, 2015
public class MergeRibo_Fast

#Fields
*Primary input file path
private ArrayList<String> in=new ArrayList<String>()

*Alternate input file path
private String alt=null

*Primary output file path
private String out1=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

HashMap<Integer,Ribo> bestMap=new HashMap<Integer,Ribo>(10000000)

HashMap<Integer,ArrayList<Ribo>> listMap=new HashMap<Integer,ArrayList<Ribo>>(10000000)

static byte[] consensus16S

byte[] consensus18S

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private boolean process16S=true

private boolean process18S=false

*Primary input file
private final ArrayList<FileFormat> ffin

private final FileFormat ffalt

*Primary output file
private final FileFormat ffout1

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public MergeRibo_Fast(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris(FileFormat ff)

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class MergeRibo_Fast>
<class MergeRibo_Fast.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class MergeRibo_Fast.ProcessThread

#Fields
IDAligner ssa=aligner.Factory.makeIDAligner()

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@return True if the reads should be kept, false if they should be discarded.
boolean processRead(Read r)

float align(Read r)

</class MergeRibo_Fast.ProcessThread>
<class Orf>
*ORF means Open Reading Frame.
*It starts at the first base of a start codon and ends at the last base of a stop codon.
*The length is divisible by 3.
*@author Brian Bushnell
*@date Sep 20, 2018
public class Orf

#Fields
public final int frame

public final int startCodon

public final int stopCodon

public float startScore

public float stopScore

public float kmerScore

public float orfScore

public float pathScorePlus

public int pathLengthPlus=1

public Orf prevPlus

public float pathScoreMinus

public int pathLengthMinus=1

public Orf prevMinus

public final int type

static float e1=0.35f

static float e2=-0.1f

static float e3=-0.01f

static float f1=0.08f

static float f2=0.02f

static float f3=0.09f


#Methods
*Bases and coordinates are assumed to be the correct strand.
*Minus-strand ORFs can be flipped at the end of the constructor.
*@param scafName_
*@param start_
*@param stop_
*@param strand_
*@param frame_
*@param bases
*@param flip
public Orf(String scafName_, int start_, int stop_, int strand_, int frame_, byte[] bases, boolean flip, int type_)

*Grab the codon starting at from.
*Assumes bases are in the correct strand
*@param from
*@param bases
*@return
private static int getCodon(int from, byte[] bases)

public float calcOrfScore()

*The score of an ORF alone is a factor of the length, start score, stop score, and kmer score.
*The score of an ORF in the context of an overlapping gene also includes a penalty for the overlap length.
*@param overlap
*@return Calculated score
public float calcOrfScore(int overlap)

public float averageKmerScore()

public boolean isValidPrev(Orf prev, int maxOverlap)

public float pathScore()

public float pathScore(int prevStrand)

public Orf prev()

public Orf prev(int prevStrand)

public int pathLength(int prevStrand)

public int pathLength()

*@param orfs A list of called features
*@param types Types of features to retain, e.g. "CDS,rRNA,tRNA"
*@return GffLines subdivided by type
public static ArrayList<GffLine>[] toGffLinesByType(ArrayList<Orf> orfs, String types)

public static ArrayList<GffLine> toGffLines(ArrayList<Orf> orfs)

public String toStringFlipped()

@Override public String toString()

public String toGff()

public ByteBuilder appendGff(ByteBuilder bb)

public boolean isSSU()

public boolean is5S()

public boolean is16S()

public boolean is18S()

public boolean is23S()

public boolean isCDS()

public boolean isRRNA()

public boolean isTRNA()

@Override public float score()

</class Orf>
<class PFeature>
*Represents a genomic feature such as a gene, with start, stop, and strand.
*@author Brian Bushnell
*@date Sep 24, 2018
abstract class PFeature

#Fields
public final String scafName

public final int strand

public final int scaflen

*0-based position of first base of feature *
public int start

*0-based position of last base of feature *
public int stop

private int flipped=0

public static final FeatureComparatorScore featureComparatorScore=new FeatureComparatorScore()


#Methods
public PFeature(String scafName_, int start_, int stop_, int strand_, int scaflen_)

public final void flip()

public final int currentStrand()

public final int length()

@Override public final int compareTo(PFeature f)

public final int flipped()

public float score()

@Override public final int start()

@Override public final int stop()

@Override public final int strand()

@Override public final String name()

@Override public final String seqid()

</class PFeature>
<class PGMTools>
*Static helpers for manipulating pgm files.
*main() merges pgm files.
*@author Brian Bushnell
*@date Sep 24, 2018
public class PGMTools

#Fields
private static PrintStream outstream=System.err

public static boolean verbose=false

*Mix models equally
public static boolean normalize=false


#Methods
*Combines multiple pgm files into a single file
public static void main(String[] args)

public static boolean parseStatic(String arg, String a, String b)

public static ArrayList<GeneModel> loadModels(ArrayList<String> fnames)

public static GeneModel mergeModels(ArrayList<GeneModel> models)

*The first gene model is the dominant one
public static GeneModel mix(double cdsMult, double rRnaMult, double tRnaMult, boolean normalize, GeneModel models)

public static GeneModel loadAndMerge(ArrayList<String> in)

public static boolean writeModel(GeneModel pgm, String out, boolean overwrite)

public static boolean writeModel(GeneModel pgm, FileFormat ffout)

*Ensure files can be read and written
private static void checkFileExistence(ArrayList<String> in, String out, boolean overwrite, boolean allowDupes)

</class PGMTools>
<class ProkObject>
*Contains a lot of statics and static methods for gene-calling
public abstract class ProkObject

#Fields
public static final int CDS=0

public static final int tRNA=1

public static final int r16S=2

public static final int r23S=3

public static final int r5S=4

public static final int r18S=5

public static final int r28S=6

public static final int RNA=7

public static String[] typeStrings=new String[]{"CDS","tRNA","16S","23S","5S","18S","28S","RNA"}

public static String[] typeStrings2=new String[]{"CDS","tRNA","rRNA","rRNA","rRNA","rRNA","rRNA","RNA"}

public static String[] specialTypeStrings=new String[]{null,"tRNA","16S","23S","5S","18S","28S",null}

public static int kInnerRNA=6

public static int kStartRNA=3

public static int kStopRNA=3

public static int kLongSSU=15

public static int kLongLSU=15

public static int kLong5S=15

public static int kLongTRna=15

public static float min16SIdentity=0.62f

public static float min23SIdentity=0.60f

public static float min5SIdentity=0.60f

public static float min18SIdentity=0.60f

static int ssuStartSlop=200

static int ssuStopSlop=0

static int lsuStartSlop=220

static int lsuStopSlop=0

static int r5SStartSlop=50

static int r5SStopSlop=50

public static boolean callCDS=true

public static boolean calltRNA=true

public static boolean call16S=true

public static boolean call23S=true

public static boolean call5S=true

public static boolean call18S=false

public static LongHashSet ssuKmers=null

public static LongHashSet lsuKmers=null

public static LongHashSet r5SKmers=null

public static LongHashSet trnaKmers=null

public static Read[] trnaSequence=null

public static Read[] r16SSequence=null

public static Read[] r23SSequence=null

public static Read[] r5SSequence=null

public static Read[] r18SSequence=null

public static boolean PROCESS_PLUS_STRAND=true

public static boolean PROCESS_MINUS_STRAND=true

public static boolean loadSSUkmers=true

public static boolean loadLSUkmers=true

public static boolean load5Skmers=true

public static boolean loadtRNAkmers=true

private static boolean loadedLongKmers=false

public static boolean loadtRNASequence=false

public static boolean load16SSequence=true

public static boolean load23SSequence=true

public static boolean load5SSequence=true

public static boolean load18SSequence=true

private static boolean loadedConsensusSequence=false


#Methods
public static boolean parse(String arg, String a, String b)

public static boolean processType(int type)

public static int startSlop(int type)

public static int stopSlop(int type)

public static float minID(int type)

public static Read[] consensusReads(int type)

public static LongHashSet kmerSet(int type)

public static int kLongLen(int type)

public static int flagToType(int flag)

public static byte typeToFlag(int type)

public static boolean callType(int type)

public static void loadLongKmers()

private static LongHashSet loadLongKmersByType(int k, String prefix)

private static LongHashSet loadLongKmers(String fname, int k)

private static LongHashSet processList(ListNum<Read> ln, LongHashSet set, int k)

public static void loadConsensusSequenceFromFile(boolean removeMito, boolean removeChloro)

public static Read[] loadConsensusSequenceType(String prefix, boolean removeMito, boolean removeChloro)

private static Read[] loadConsensusSequence(String fname)

private static Read[] stripOrganelle(Read[] array, String key)

public static boolean isSpecialType(String type)

</class ProkObject>
<class RiboMaker>
*Makes a consensus ribosomal sequence using raw reads as input.
*@author Brian Bushnell
*@date October 10, 2019
public class RiboMaker

#Fields
*Primary input file path
private String in1=null

*Secondary input file path
private String in2=null

private String qfin1=null

private String qfin2=null

*Primary output file path
private String out1=null

private String qfout1=null

private String filterFile

private String refFile

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

*Whether interleaved was explicitly set.
private boolean setInterleaved=false

*Original ref
private byte[] ref0

*Padded ref
private byte[] ref

private int padding=100

private int queueLen=20

private int queueWidth=20

private float minID=0.4f

private PriorityQueue<Alignment>[] queues

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Number of reads retained
protected long readsOut=0

*Number of bases retained
protected long basesOut=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

*Primary input file
private final FileFormat ffin1

*Secondary input file
private final FileFormat ffin2

*Filter input file
private final FileFormat fffilter

*Ref input file
private final FileFormat ffref

*Primary output file
private final FileFormat ffout1

private final LongHashSet filter

private final int k=31

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=false


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public RiboMaker(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

*Replace # with 1 and 2 in headers
private void doPoundReplacement()

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Make sure interleaving agrees with number of input and output files
private void adjustInterleaving()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

*Create read streams and process all data
void process(Timer t)

private void loadRef()

public static LongHashSet loadFilter(FileFormat ff, int k)

public static boolean passesFilter(Read r, int k, LongHashSet set)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream makeCros(boolean pairedInput)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream ros)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

boolean addToQueue(Alignment best, PriorityQueue<Alignment>[] queues)

boolean addToQueue(Alignment best, PriorityQueue<Alignment> queue)

@Override public final ReadWriteLock rwlock()

</class RiboMaker>
<class RiboMaker.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class RiboMaker.ProcessThread

#Fields
*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long readsOutT=0

*Number of bases retained by this thread
protected long basesOutT=0

*True only if this thread has completed successfully
boolean success=false

private PriorityQueue<Alignment>[] queuesT

*Shared input stream
private final ConcurrentReadInputStream cris

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read or a read pair.
*@param r1 Read 1
*@param r2 Read 2 (may be null)
*@return True if the reads should be kept, false if they should be discarded.
void processReadPair(Read r1, Read r2)

void processRead(Read r)

</class RiboMaker.ProcessThread>
<class ScafData>
*Tracks information about a scaffold for AnalyzeGenes.
*@author Brian Bushnell
*@date Sep 24, 2018
class ScafData

#Fields
final String name

final byte[] bases

final byte[] frames

final IntList starts=new IntList(8)

final IntList stops=new IntList(8)

private int strand=0

*gLines[strand] holds the GffLines for that strand
ArrayList<GffLine>[] cdsLines=new ArrayList[2]

ArrayList<GffLine>[] rnaLines=new ArrayList[2]


#Methods
ScafData(Read r)

ScafData(String name_, byte[] bases_, byte[] frames_)

void clear()

void reverseComplement()

void addCDS(GffLine gline)

void addRNA(GffLine gline)

byte[] fetch(int start, int stop)

int strand()

public int length()

</class ScafData>
<class ScoreTracker>
public class ScoreTracker

#Fields
long geneStartScoreCount=0

long geneStopScoreCount=0

long geneInnerScoreCount=0

long lengthCount=0

double geneStartScoreSum=0

double geneStopScoreSum=0

double geneInnerScoreSum=0

long lengthSum=0

long genomeSize=0

final int type


#Methods
public ScoreTracker(int type_)

public void add(ScoreTracker st)

public void add(ArrayList<Orf>[] array)

public void add(ArrayList<Orf> list)

public void add(Orf orf)

@Override public String toString()

public JsonObject toJson()

</class ScoreTracker>
<class SplitRibo>
*Splits a mix of ribosomal sequences (such as Silva) into different files per type (16S, 18S, etc).
*@author Brian Bushnell
*@date November 19, 2015
public class SplitRibo

#Fields
*Primary input file path
private String in1=null

private String qfin1=null

*Primary output file path
private String outPattern=null

*Override input file extension
private String extin=null

*Override output file extension
private String extout=null

float minID=0.59f

float refineID=0.70f

private int m16S_index=-2

private int m18S_index=-2

private int p16S_index=-2

*Number of reads processed
protected long readsProcessed=0

*Number of bases processed
protected long basesProcessed=0

*Quit after processing this many input reads; -1 means no limit
private long maxReads=-1

private String[] sequenceTypes=new String[]{"Other","16S","18S","23S","5S","m16S","m18S","p16S"}

private final int numTypes

final Read[][] consensusSequences

*Number of reads retained
final long[] readsOut

*Number of bases retained
final long[] basesOut

*Primary input file
private final FileFormat ffin1

private final ReadWriteLock rwlock=new ReentrantReadWriteLock()

*Print status messages to this output stream
private PrintStream outstream=System.err

*Print verbose messages
public static boolean verbose=false

*True if an error was encountered
public boolean errorState=false

*Overwrite existing output files
private boolean overwrite=true

*Append to existing output files
private boolean append=false

*Reads are output in input order
private boolean ordered=true


#Methods
*Code entrance from the command line.
*@param args Command line arguments
public static void main(String[] args)

*Constructor.
*@param args Command line arguments
public SplitRibo(String[] args)

*Parse arguments from the command line
private Parser parse(String[] args)

private void parseTypes(String b)

*Add or remove .gz or .bz2 as needed
private void fixExtensions()

*Ensure files can be read and written
private void checkFileExistence()

*Adjust file-related static fields as needed for this program
private static void checkStatics()

*Ensure parameter ranges are within bounds and required parameters are set
private boolean validateParams()

private final Read[][] loadConsensusSequenceFromFile()

*Create read streams and process all data
void process(Timer t)

private ConcurrentReadInputStream makeCris()

private ConcurrentReadOutputStream[] makeCrosArray()

private ConcurrentReadOutputStream makeCros(String type)

*Spawn process threads
private void spawnThreads(ConcurrentReadInputStream cris, ConcurrentReadOutputStream[] rosa)

@Override public final void accumulate(ProcessThread pt)

@Override public final boolean success()

@Override public final ReadWriteLock rwlock()

</class SplitRibo>
<class SplitRibo.ProcessThread>
*This class is static to prevent accidental writing to shared variables.
*It is safe to remove the static modifier.
class SplitRibo.ProcessThread

#Fields
IDAligner ssa=aligner.Factory.makeIDAligner()

*Number of reads processed by this thread
protected long readsProcessedT=0

*Number of bases processed by this thread
protected long basesProcessedT=0

*Number of reads retained by this thread
protected long[] readsOutT=new long[numTypes]

*Number of bases retained by this thread
protected long[] basesOutT=new long[numTypes]

*True only if this thread has completed successfully
boolean success=false

*Shared input stream
private final ConcurrentReadInputStream cris

*Shared output stream
private final ConcurrentReadOutputStream[] rosa

*Thread ID
final int tid


#Methods
ProcessThread(ConcurrentReadInputStream cris_, ConcurrentReadOutputStream[] rosa_, int tid_)

@Override public void run()

*Iterate through the reads
void processInner()

void processList(ListNum<Read> ln)

*Process a read.
*@param r1 Read 1
*@return The best-matching type, or 0 for no matches.
private int processRead(Read r)

private float align(Read r, Read[] refs, int minRef, int maxRef)

</class SplitRibo.ProcessThread>
<class StatsContainer>
class StatsContainer

#Fields
FrameStats inner

FrameStats start

FrameStats stop

final FrameStats[] statsArray=new FrameStats[3]

final String name

long lengthSum=0

long lengthCount=0

int lengthAvg=-1

float invLengthAvg

int[] lengths=new int[5000]

public final int type


#Methods
StatsContainer(int type_, int kInner, int framesInner, int kStart, int framesStart, int offsetStart, int kStop, int framesStop, int offsetStop)

StatsContainer(int type_)

void setInner(int kInner, int framesInner)

void setStart(int kStart, int framesStart, int offsetStart)

void setStop(int kStop, int framesStop, int offsetStop)

void setInner(FrameStats fs)

void setStart(FrameStats fs)

void setStop(FrameStats fs)

@Override public String toString()

public ByteBuilder appendTo(ByteBuilder bb)

public void clear()

public void setFrom(StatsContainer sc)

public void add(StatsContainer sc)

public void multiplyBy(double mult)

public void calculate()

public void addLength(int x)

int kLongLen()

LongHashSet kmerSet()

Read[] consensusSequence()

float minIdentity()

public int startSlop()

public int stopSlop()

</class StatsContainer>
